<!DOCTYPE HTML><html><head><meta charset="utf-8"><meta name="viewport" content="with=device-width, initial-scale=1.0"><title>Lucas DiCioccio&#39;s blog - Some notes</title><link rel="icon" type="image/x-icon" href="/images/favicon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="https://lucasdicioccio.github.io/atom.xml"><meta name="author" content="Lucas DiCioccio"><meta name="keywords" content="personal note management"><meta name="description" content="Notes that could become part of articles."><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Lucas DiCioccio&#39;s blog - Some notes"><meta name="twitter:site" content="@lucasdicioccio"><meta name="twitter:creator" content="@lucasdicioccio"><meta property="twitter:description" content="Notes that could become part of articles."><meta name="type" property="og:type" content="article"><meta name="title" property="og:title" content="Lucas DiCioccio&#39;s blog - Some notes"><meta name="url" property="og:url" content="https://lucasdicioccio.github.io/notes.html"><meta property="og:description" content="Notes that could become part of articles."><meta name="ks:article_json" content="/json/notes.cmark.json"><meta name="article:tag" content="personal note management"><style>:root {  --main-background-color: #eeffee;  --tile-background-color: #eef9ee;  --main-outline-color: #d0c4db;  --main-outline-background-color: #ffbfd6;  --main-outline-text-color: white;  --note-title-color: #824e75;  --main-text-color: #646200;  --bubble-text-color: white;  --bubble-background-color: #ff85b0;;  --bubble-border-color: white;}a {  text-decoration: none;}html {  background: var(--main-background-color);  color: var(--main-text-color);}.notes {  display: grid;  grid-template-columns: repeat(1fr);  font-family: sans;}.note {  border: solid var(--main-outline-color);  background: var(--tile-background-color);  border-radius: 12px 12px 0px 0px;  padding: 8px;  margin: 10px auto;  width: 50%;  min-height: 300px;}.note-title {  text-align: center;  margin-bottom: 1em;  color: var(--note-title-color);}.note-info {  display: flex;  justify-content: space-between;  padding: 0 8% 0 8%;  margin-bottom: 10px;  border-top: 2px solid var(--main-outline-color);}.note-info div p {  padding-bottom: 0;}.topics {  width: 80%;  margin: 0;  display: flex;}.topic {  margin-right: 4px;}.note-score {  text-align: right;  text-align: center;  margin: 0;}.score, .topic {  padding: 6px;  border-radius: 8px;  background: var(--bubble-background-color);  border: 1px solid var(--bubble-border-color);  color: var(--bubble-text-color);  font-weight: bold;  font-family: sans;}.note-body, .questions {  padding: 0 8% 0 8%;}.note-body {  overflow: scroll;  font-family: monospace;}.note-body blockquote {  margin: 0;  text-align: justify;}.questions {  margin-top: 1em;  padding-top: 1em;  border-top: 1px solid var(--main-outline-color);  display: flex;  flex-direction: column;}.question p {  font-size: small;}</style></head><body><div id="listing"><div class="main-article"><section class="main-section"><div class="notes">
<div class="note">
<h1 class="note-title">how photos are judged</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">photo</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>little time to judge a #photo, photos without a clear subjet, lack of intentionality, border; follow the theme binary then jury appreciation</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">types of structures</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">engineering</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>A number of structures exists: bookeeping, control, data. We typically have different ideas about performance/usability tradeoffs of these structures. Would be nice to be able to annotate structures to tell whether some substructure serves a domain need or is artificial.</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">mutation tar-pit</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">engineering</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>As stated in the tar-pit paper: there's a combinatorial explosion due to the very nature of mutation, so it can become cumbersome to have a data-type that perfectly espouse the set of valid values. We can go further and say that due to the time there is not a single value but a fluid value where each observer contributes to the combinatorial explosion.</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">complexity increasing</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">engineering</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>as project matures, even small fixes take more time because you need more preconditions to make some piece of code works (coupling creeps in)</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">pareto and exploratory prototypes</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">philosophy</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>There are really various types of prototypes: pareto-prototypes where you know where you're going (e.g., build a query-language) but aim to grow iteratively and exploration-prototypes where you don't know what you're doing.</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">in defense of dense code</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">rant</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>balance between repeated code, golang-amounts of repetition means more to review, more to move, increased amounts of refactorings and branch conflicts</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">unit blindness</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">idea</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>there's already some knowledge about boolean blindness in API-design, we should not miss the unit-blindness, when a 'delete operation' occurs for instance, you should return a `Tombstone =~ Unit`</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">postgrest-table is pretty good</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">idea</span></p></div>
<div class="note-score"><p><span class="score">2</span></p></div>
</div>
<div class="note-body"><blockquote>could re-use the table model outside of postgrest-though</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">encapsulation of db access is no better than lazy-io</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">dev practices</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>people like to dunk on Haskell lazy structures and often don't know what LazyIO is. still encapsulation with 'providers' that then fetch data when needed is akin to lazy IO, rather code should ask for the already-provided data to move fetching to common glue code only</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">autoformatters and reviews</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">dev practices</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>as much as i think code formatter are an advanced in engineering, other tools are a bit lagging/not-ready or there's a mismatch. in particular code reviews and diff tools</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">sloppy code slows readers down and leads to decision paralysis</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">dev practices</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>when some sloppy code has caveats but it's fine in context, and you need to recreate or reuse the same or similar logic; it hurts when you read, it makes impossible to know whether the sloppiness is acceptable or WAI, and makes it harder to gauge re-use-and-fix or reinvent the wheel</blockquote></div>
<div class="questions"><div class="question"><p><span>should I write a tweet thread?</span></p></div></div>
</div>
<div class="note">
<h1 class="note-title">csv-like api would be better</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">dev practices</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>many apis would be better if they were returning tabledump-likes with integrity references rather than json objects</blockquote></div>
<div class="questions"><div class="question"><p><span>should I write a tweet thread?</span></p></div></div>
</div>
<div class="note">
<h1 class="note-title">null fatigue</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">dev practices</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>I have some fair amount of null fatigue.  When it's in your code you lose a couple of hours a week (still close to 5% of your work). When it's in public-APIs of large services I can't help but feel the scaling factor of these couple of hours across users of the API.</blockquote></div>
<div class="questions"><div class="question"><p><span>should I write a Tweet thread?</span></p></div></div>
</div>
<div class="note">
<h1 class="note-title">a thing I find is bad taste in design</h1>
<div class="note-info">
<div class="topics"></div>
<div class="note-score"><p><span class="score">2</span></p></div>
</div>
<div class="note-body"><blockquote>sometimes it feels like you need to add code to remove features, that is you build a feature by restricting a more general tool (e.g., middle-ware skipping logic)</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">being accurate vs being useful</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">products</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>in data-analytics there is a tension between being accurate with whatever data you have and being synthetic and helpful</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">onFoo handlers</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">idea</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>when you return some code capable of reacting some event, vs when you call the handler code -- mix of dual concepts (e.g., SWR returns a mutate function onFooChanged that is employed as an onClick handler)</blockquote></div>
<div class="questions"><div class="question"><p><span>should I write a POC?</span></p></div></div>
</div>
<div class="note">
<h1 class="note-title">need for tools</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">idea</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>- a tool to help with API diffs - and a tool to help with templating live</blockquote></div>
<div class="questions"><div class="question"><p><span>should I write a POC?</span></p></div></div>
</div>
<div class="note">
<h1 class="note-title">components do not compose well</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">web</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>CSS and layout are global-constraint problems, they do not compose well. hence components are somewhat doomed in complex environments unless the view aspects are constrained to what composes for real. current components merely combine</blockquote></div>
<div class="questions"><div class="question"><p><span>should I write a blog post?</span></p></div></div>
</div>
<div class="note">
<h1 class="note-title">JS frameworks and components</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">soft</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>components dependencies are orthogonal to display nesting

would be nice to instantiate components (with their sub components) but allow to nest views independently from the component hierarchy

for instances a button inserted in a toolbar actually appears because it is in a component elsewhere

in short, components exist in two realms:
- hierarchical reasons to exists (a button is an active component because a particular pane is active)
- visual embedding (a button is displayed within a particular location)

what i want is to define a component with input/output/events/queries like in halogen
and separately map that onto HTML+DOM-bindings-with-events

</blockquote></div>
<div class="questions"><div class="question"><p><span>is there prior work?</span></p></div><div class="question"><p><span>should I write a POC?</span></p></div></div>
</div>
<div class="note">
<h1 class="note-title">golang after 1year</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">soft</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>after around a year using it, I still sincerely think that Golang power/weight ratio is pretty bad and doesn't feel modern.
Pro: it compiles fast
Con: but while doing so it checks so little and provides no affordance
Perf-bound, I'd go for Rust, else a member of the ML-family.
</blockquote></div>
<div class="questions"><div class="question"><p><span>should I tweet that?</span></p></div></div>
</div>
<div class="note">
<h1 class="note-title">encoding info in URLs</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">web</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>discussions on https://news.ycombinator.com/item?id=31310564 seem to tell that one should encode information in the hierarchy, seems like a failure to encode information in the page `meta` headers</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">example of optim</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">optim</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>good-fast-cheap triangle is a good example to discuss about pareto-optimality</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">lack of elegance can be simple</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">system</span></p></div>
<div class="note-score"><p><span class="score">2</span></p></div>
</div>
<div class="note-body"><blockquote>Sometimes having a brutalist solution is good because you can use it all the time with little second thoughts. Our desire to do things right wants us to use parcimony and elegance. However being nit-picky, extra complications arise due to combinatorics. Imperfect on many aspects but no-brainer to use and understand (see: bell-curve meme).</blockquote></div>
<div class="questions"></div>
</div>
<div class="note">
<h1 class="note-title">dependencies in OOP and IO</h1>
<div class="note-info">
<div class="topics"><p><span class="topic">oop</span></p></div>
<div class="note-score"><p><span class="score">1</span></p></div>
</div>
<div class="note-body"><blockquote>About OOP hiding states. It's pretty common to bundle all dependencies in the object, say a Summarry object.
Then there is no distinction between methods that make use of none, some, or all of these dependencies. Even when internally-occurring as private methods. Turns out it makes code-auditing and code-reviewing painful. As time passes, objects accrete more and more dependencies for single new methods.
We should have more fine-grained
</blockquote></div>
<div class="questions"><div class="question"><p><span>should I write an article?</span></p></div></div>
</div>
</div>
</section><section class="main-section"><script type="text/javascript">
(function(){
  const xs = [... document.getElementsByTagName("h1")];
  xs.forEach((x) => {
    const title = x.innerHTML ?? 'about your blog';
    const subject = `About your note: ${title}`;
    const elt = document.createElement("a");
    elt.innerHTML = " ðŸ“§";
    elt.setAttribute("class", "enquire-link")
    elt.setAttribute("href", `mailto:lucas@dicioccio.fr?subject=${subject}`);
    x.appendChild(elt);
  });
})()
</script>
</section></div></div></body></html>