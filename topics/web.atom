<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title type="text">
        Lucas DiCioccio's blog
    </title>
    <id>
        https://dicioccio.fr/atom.xml
    </id>
    <updated>
        2022-01-30T12:00:00Z
    </updated>
    <entry>
        <id>
            https://dicioccio.fr/kitchen-sink.html
        </id>
        <title type="text">
            Introducing Kitchen Sink
        </title>
        <updated>
            2022-10-01T01:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;Kitchen Sink embodies my way of imagining personal sites: messy but allows to experiment with a bit of everything. Personal and &lt;a href="/hashtags/experimental.html"&gt;&lt;span class="hashtag" data-hashtag="experimental"&gt;#experimental&lt;/span&gt;&lt;/a&gt;, but still built on solid &lt;a href="/hashtags/foundations.html"&gt;&lt;span class="hashtag" data-hashtag="foundations"&gt;#foundations&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Rather than writing a long post here, this page only is an announcement. You‚Äôll find long post on the project‚Äôs website.&lt;/p&gt; &lt;p&gt;I encourage you to read these Kitchen-Sink links here:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://kitchensink-tech.github.io/philosophy.html"&gt;The Kitchen-Sink Philosophy&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://kitchensink-tech.github.io/features.html"&gt;A feature list&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/kitchensink-tech/kitchensink"&gt;The code on GitHub&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/kitchen-sink.html" rel="alternate"/>
        <summary type="text">
            After having written a [number of articles](/topics/web.html) about my blog-engine. And motivated by curious people wanting to see how it's built, I've open-sourced my blog-engine and named it _Kitchen Sink_.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/dhall-section-demo.html
        </id>
        <title type="text">
            Scripting subsets of page contents in Dhall.
        </title>
        <updated>
            2022-05-03T01:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;Since I‚Äôve started building my own blog engine, I wanted some limited &lt;a href="/hashtags/scripting.html"&gt;&lt;span class="hashtag" data-hashtag="scripting"&gt;#scripting&lt;/span&gt;&lt;/a&gt; capabilities in the text-processing engine. A specific case I had in mind was to generate some tables or listings for what you currently find on the &lt;a href="/readings.html"&gt;/readings.html&lt;/a&gt; or on the &lt;a href="/tips.html"&gt;/tips.html&lt;/a&gt; page. I would like something like &lt;a href="http://microformats.org/"&gt;Microformats&lt;/a&gt;, but tactically applied to individual articles, with little ceremony.&lt;/p&gt; &lt;p&gt;A more telling example could be a &lt;a href="/hashtags/photo.html"&gt;&lt;span class="hashtag" data-hashtag="photo"&gt;#photo&lt;/span&gt;&lt;/a&gt; gallery where we list a dozen of images. For each image you‚Äôd want a title, an URL, a preferred background color for the frame, maybe a caption etc. Hand-editing such galleries is a lot of work, and the extra ceremony to store less than 100 records in a DB is not worth it. There‚Äôs a gap to fill&lt;/p&gt; &lt;p&gt;This article demonstrates and discusses a PoC using the Dhall programming language as a specific step.&lt;/p&gt; &lt;h2 id="high-level-need"&gt;high-level need&lt;/h2&gt; &lt;p&gt;What is common in the type of pages where I would like some minimal templating is:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;I want to reference and organize a moderately large amount of items. &lt;/li&gt; &lt;li&gt;items within a collection have a common structure (e.g., a link to a page would have a title, an URL, some language, and some description from myself). &lt;/li&gt; &lt;li&gt;I want to present, ideally with some mechanical template to keep the styling/HTML-structure consistent. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Thus I have &lt;strong&gt;three distinct characteristics to carve out&lt;/strong&gt;:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;ol&gt; &lt;li&gt;define the structure of items &lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;&lt;ol start="2"&gt; &lt;li&gt;list a collection of items &lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;&lt;ol start="3"&gt; &lt;li&gt;implement some template I use to present these &lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Separating 1. and 2. is a matter of getting some type and some syntax to write values. Separating 3. requires a novel feature in my blog-engine: to interpret some structure into some HTML chunk to embed in a longer article. Current generators only produce targets as fully-contained output objects (that then must be embedded via other HTML primitives like &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags).&lt;/p&gt; &lt;h2 id="mini-design"&gt;mini design&lt;/h2&gt; &lt;p&gt;Let‚Äôs go through my design process. This is a retroactive recount of the process I took rather than an upfront design-doc.&lt;/p&gt; &lt;h3 id="current-situation"&gt;current situation&lt;/h3&gt; &lt;p&gt;Absent a proper solution for this need, I so far hand-write all these pages. A downside is that I need to carefully write CommonMark if I want to apply some CSS uniformly. More annoying is if I want to add a non-trivial and verbose annotations (e.g., adding a &lt;code&gt;mailto:&lt;/code&gt; link). This process is &lt;em&gt;fastidious&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;I do not want to trade fastidiousness for significant extra complexity. Indeed, in these tasks there is a risk to end up for a similarly-fastidious process involving more moving bits‚Ä¶ What I want to avoid is:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;a. having a separate database, connectors, and section capable of reading the database at production-time &lt;/li&gt; &lt;li&gt;b. writing data structures in the Haskell-side of the blog-engine, including templates just for each type of listing &lt;/li&gt; &lt;li&gt;c. writing some JS that fetches a JSON-list and render only in the client &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Adding a database (a.) is the latest thing I would like to do because of all the deployment and extra changes required. I know this time will come if I want to do things like comments, but let me push it further. At this point, even SQLite would be too much overhead to add schemas, populate data etc.&lt;/p&gt; &lt;p&gt;Writing Haskell-code (b.) and would be fine regarding the structure definition, however I do not like to ‚Äúsplit‚Äù an article between multiple sources. A reason why I wrote a blog-engine was to avoid distractions while focusing on writing an article.&lt;/p&gt; &lt;p&gt;Of the three, I think that writing all the logic client-side (c.) probably would be the least intrusive to my writing flow. However, clients that do not support JavaScript would miss the content. I‚Äôm fine with JavaScript when it is &lt;em&gt;required&lt;/em&gt; or when it is a &lt;em&gt;nice to have&lt;/em&gt;. Usage of JS for just laying-out the meaty-content is something I frown upon.&lt;/p&gt; &lt;p&gt;Summarizing, I was searching for some way to embed logic that would return some HTML provided some type locally-defined and locally-filled in an article document.&lt;/p&gt; &lt;h3 id="filling-in-the-gap"&gt;filling in the gap&lt;/h3&gt; &lt;p&gt;To fill the gap, there are a two key decisions to make:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;a. what scripting language(s) to support? &lt;/li&gt; &lt;li&gt;b. at which point of the computation pipeline should I incorporate this engine? &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For the first question (a), I want some minimal and non-trivial language. I do not want to invest much time on the particular choice because I want to try different things rather than do some proper analysis to answer the second (b) question. Indeed, if the cost for demonstrating (a) happens to be small, then I get a pretty good starting point to answer or try &lt;a href="/hashtags/trade-off.html"&gt;&lt;span class="hashtag" data-hashtag="trade-off"&gt;#trade-off&lt;/span&gt;&lt;/a&gt; in (b).&lt;/p&gt; &lt;p&gt;Working on the &lt;a href="/halogen-demo.html"&gt;Halogen demo article&lt;/a&gt; I was reminded about &lt;a href="https://dhall-lang.org/"&gt;Dhall&lt;/a&gt; as an improved YAML/JavaScript for configuration. Configurations are very similar to Microformats, so why no try Dhall first?&lt;/p&gt; &lt;p&gt;Rather than providing a lengthy discussion, I‚Äôll leave only bullet points around pro/cons (note that I realize that these bullet points for pro/cons could themselves become microformats).&lt;/p&gt; &lt;h4 id="advantages"&gt;Advantages&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;incorporating Dhall is a full demonstration of how scripted evaluations (I want some opaque IO returning some CommonMark) &lt;/li&gt; &lt;li&gt;still a first stone in some more advanced form of pipeline/build-system &lt;/li&gt; &lt;li&gt;Dhall has the ability to import libraries with little package management pain, I could use this to re-use parts across articles, it‚Äôs a good nice to have &lt;/li&gt; &lt;li&gt;interoperability between Dhall and Haskell is a bliss (the &lt;a href="https://twitter.com/GabriellaG439"&gt;Dhall author&lt;/a&gt; is a &lt;a href="https://www.haskellforall.com/"&gt;prolific Haskell engineer&lt;/a&gt;) &lt;/li&gt; &lt;/ul&gt; &lt;h4 id="limitations"&gt;Limitations&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;so far, no extra environment is passed to the Dhall interpreter (the Dhall code does not know about its surroundings, article title or any other data &lt;span class="emoji" data-emoji="arrow_right"&gt;‚û°Ô∏è&lt;/span&gt; for later) &lt;/li&gt; &lt;li&gt;no dependency between sections are planned (need to do detection cycles or find other approaches &lt;span class="emoji" data-emoji="arrow_right"&gt;‚û°Ô∏è&lt;/span&gt; for later) &lt;/li&gt; &lt;/ul&gt; &lt;h4 id="drawbacks"&gt;Drawbacks&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;evaluating Dhall code costs extra time, CPUs, and file-descriptors (especially important while I care about automatic reloads of previews when editing articles) &lt;/li&gt; &lt;li&gt;intermediary results are opaque and hidden, if some final HTML is wrong, I need to know what has been generated as intermediary &lt;/li&gt; &lt;li&gt;risk of adding non-deterministic content generation (e.g., breaking because I‚Äôve no network, some hackers inserting duck picks or spam because the evaluator fetches from the Internet) &lt;/li&gt; &lt;/ul&gt; &lt;h4 id="summary"&gt;Summary&lt;/h4&gt; &lt;p&gt;Dhall still seems a darn-good choice. None of the drawbacks are fatal flaws and can be mitigated. The most dangerous in my opinion is the evaluation costs. I will likely mitigate it using some cacheing in the future. I need to keep in mind that there are two evaluation phases in my blog engine: one computing targets and another one rendering targets. Both have their trade-offs.&lt;/p&gt; &lt;p&gt;Non-determinism is heavily mitigated while sticking to Dhall, so I expect no big surprises. When adapting the pattern to other languages (e.g., if I ever want to run some python) then I will have to be more careful.&lt;/p&gt; &lt;h2 id="result"&gt;result&lt;/h2&gt; &lt;p&gt;I spent less than two hours, including family interruptions &lt;span class="emoji" data-emoji="baby"&gt;üë∂&lt;/span&gt; and babbling-around time. The implementation so far is extremely primitive, though.&lt;/p&gt; &lt;p&gt;I decided to interpret the Dhall code while loading the Site targets rather than while generating targets. As much as I wanted to avoid this option, it is the pragmatic choice: on the one hand, I interpret sections‚Äô Commonmark in different places (e.g., for rendering HTML but also when analyzing content or generating a JSON AST). On the other hand, cache control and idempotency is more obvious to control at this early phase: one execution of the script gives one website-worth of recipes.&lt;/p&gt; &lt;p&gt;Overall I had to do the following changes:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;add a new format (defining a new pattern, and parser pattern) in my section-files &lt;/li&gt; &lt;li&gt;import the Dhall package and runtime (it‚Äôs a Haskell library, nothing different from importing an HTTP-client here) &lt;/li&gt; &lt;li&gt;insert some case-switch on the section format in the code that loads an Article &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;And that‚Äôs all.&lt;/p&gt; &lt;p&gt;You can see for yourself in &lt;a href="/gen/out/dhall-section-demo.cmark__full-diff"&gt;the commit diff&lt;/a&gt; . And you can see this &lt;a href="/gen/out/dhall-section-demo.cmark__source-cmark"&gt;whole article source&lt;/a&gt; including the &lt;code&gt;dhall&lt;/code&gt; section.&lt;/p&gt; &lt;p&gt;Later, I added a local ‚Äúcache‚Äù of the Dhall prelude so that live-reloading my Dhall-code does not reload the Dhall prelude from the internet each time. Since Dhall supports cached import, the local cache requires little extra work: I just have this &lt;a href="/gen/out/dhall-section-demo.cmark__local-dhall-prelude-cache"&gt;file with a checksum-verified network import&lt;/a&gt;, which I then import as a filesystem-local import with &lt;code&gt;let prelude = ./dhall/Prelude.dhall&lt;/code&gt;.&lt;/p&gt; &lt;h3 id="future"&gt;future&lt;/h3&gt; &lt;p&gt;In the future, the Dhall object to return will be a beefier record rather than just a blob &lt;code&gt;List Text&lt;/code&gt;. For instance, we could return extra information as metadata or as extra instructions that do not find their way in the HTML. Also, the Dhall code could return something else than Commonmark, we could &lt;a href="https://github.com/andrewthad/dhall-html"&gt;directly generate HTML&lt;/a&gt; or JSON values.&lt;/p&gt; &lt;/section&gt;&lt;section class="main-section"&gt;&lt;div id="generated-section"&gt; &lt;p&gt;‚Äì‚Äì start of generated section ‚Äì‚Äì&lt;/p&gt; &lt;h1 id="this-section-is-generated"&gt;this section is generated&lt;/h1&gt; &lt;p&gt;This whole &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt; is interpreted from Dhall to Cmark to HTML. The content likely is the boundary at which point I enjoy having some templating mechanism over repeating the same thing many times. Indeed, if my data-type changes (adding columns) I need some help. Same if the template changes (adding fields, changing the markup).&lt;/p&gt; &lt;p&gt;In this example, I use two Dhall functions as two templates for a same dataset. Styling is then done in CSS.&lt;/p&gt; &lt;h2 id="table-layout"&gt;table layout&lt;/h2&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;author&lt;/th&gt; &lt;th&gt;note&lt;/th&gt; &lt;th&gt;website&lt;/th&gt; &lt;th&gt;personal comment&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Alice&lt;/td&gt; &lt;td&gt;7/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;secret santa barbara&lt;/a&gt;&lt;/td&gt; &lt;td&gt;good to learn about the city&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;8/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;sponge's den&lt;/a&gt;&lt;/td&gt; &lt;td&gt;other cartoons are funnier but okay&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Cindy&lt;/td&gt; &lt;td&gt;3/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;hello world I'm Cindy&lt;/a&gt;&lt;/td&gt; &lt;td&gt;abandonned site&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dave&lt;/td&gt; &lt;td&gt;9/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;blog of a developer&lt;/a&gt;&lt;/td&gt; &lt;td&gt;he sings so well&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Emil&lt;/td&gt; &lt;td&gt;2/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;eating some chewing gum&lt;/a&gt;&lt;/td&gt; &lt;td&gt;French movies...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Felicia&lt;/td&gt; &lt;td&gt;6/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;yet another a website&lt;/a&gt;&lt;/td&gt; &lt;td&gt;average&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Gerard&lt;/td&gt; &lt;td&gt;3/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;tech lead lead leader&lt;/a&gt;&lt;/td&gt; &lt;td&gt;lots of words to say nothing&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Hortense&lt;/td&gt; &lt;td&gt;8/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;lotta tasty recipes&lt;/a&gt;&lt;/td&gt; &lt;td&gt;miam miam&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;h2 id="tiles-layout"&gt;tiles layout&lt;/h2&gt; &lt;div class="tileset"&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Alice&lt;/span&gt; &lt;span class="note"&gt;7/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;secret santa barbara&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;good to learn about the city&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Bob&lt;/span&gt; &lt;span class="note"&gt;8/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;sponge's den&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;other cartoons are funnier but okay&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Cindy&lt;/span&gt; &lt;span class="note"&gt;3/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;hello world I'm Cindy&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;abandonned site&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Dave&lt;/span&gt; &lt;span class="note"&gt;&lt;i class="heart"/&gt;&amp;hearts;&lt;/i&gt;9/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;blog of a developer&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;he sings so well&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Emil&lt;/span&gt; &lt;span class="note"&gt;2/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;eating some chewing gum&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;French movies...&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Felicia&lt;/span&gt; &lt;span class="note"&gt;6/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;yet another a website&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;average&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Gerard&lt;/span&gt; &lt;span class="note"&gt;3/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;tech lead lead leader&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;lots of words to say nothing&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Hortense&lt;/span&gt; &lt;span class="note"&gt;8/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;lotta tasty recipes&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;miam miam&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;‚Äì‚Äì end of generated section ‚Äì‚Äì&lt;/p&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/dhall-section-demo.html" rel="alternate"/>
        <summary type="text">
            A demo of using Dhall as an intermediary step for my blog-engine sections.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/how-this-blog-works.html
        </id>
        <title type="text">
            The technology behind this blog
        </title>
        <updated>
            2022-01-30T12:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;I wasn‚Äôt &lt;a href="/hashtags/blogging.html"&gt;&lt;span class="hashtag" data-hashtag="blogging"&gt;#blogging&lt;/span&gt;&lt;/a&gt; much. I used to prefer giving meetup &lt;a href="/talks.html"&gt;talks&lt;/a&gt;, then the pandemic came and I wanted to start blogging a bit. I wrote nothing, mostly due to the lack of blogging platform I liked. This year, one resolution I took is to remediate this situation and start writing some technical content. After past and more recent attempts at using a SAAS blogging platform, hosting a Wordpress, or generating a Jekyll site, or hand-written HTML files; I always got frustrated.&lt;/p&gt; &lt;p&gt;I always felt some friction between writing content and laying-out content. Writing requires some uninterrupted stream of thought, whereas formatting HTML require focus and repeated trial-and-errors cycles. Writing the text in one document and then formatting the HTML aside in another tool typically is not sufficient because any change requires modifications in multiple places.&lt;/p&gt; &lt;p&gt;Without much surprise, I ended up writing my own engine. This article explains what I really want of a blog-engine and how I‚Äôve implemented it. Little code is shown and ideas are applicable whatever tech-stack you pick.&lt;/p&gt; &lt;h1 id="requirements"&gt;Requirements&lt;/h1&gt; &lt;p&gt;Let‚Äôs make a checklist&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;input type="checkbox" disabled&gt; static-site first, APIs second &lt;/li&gt; &lt;li&gt;&lt;input type="checkbox" disabled&gt; live preview with auto reload &lt;/li&gt; &lt;li&gt;&lt;input type="checkbox" disabled&gt; markdown for the meaty content, functional layouts &lt;/li&gt; &lt;li&gt;&lt;input type="checkbox" disabled&gt; customizable CSS, JS per article &lt;/li&gt; &lt;li&gt;&lt;input type="checkbox" disabled&gt; metadata for layout and stats &lt;/li&gt; &lt;/ul&gt; &lt;h3 id="static-site-first-serving-second"&gt;static-site first, serving second&lt;/h3&gt; &lt;p&gt;Hosting a static site is much simpler. GitHub does it for free. At this point I cannot justify maintaining API endpoints for posting comments, nor a database to store them. I still would like to be able to fluidly move to something beefier with a web server. When such a move arises, I would not want to have to port all the meaty content. That is, if I occasionally need an API call, I can still imagine having a static-site first, with only a meager amount of web-serving.&lt;/p&gt; &lt;p&gt;A nice side-effect is that &lt;code&gt;git&lt;/code&gt; is a natural database of content, and git-based flows could serve in multi-authors situations (or for instance to let people use GitHub to add invited-content/comments on the blog).&lt;/p&gt; &lt;h3 id="developer-mode-with-live-preview"&gt;developer mode with live-preview&lt;/h3&gt; &lt;p&gt;I like quick feedback loops. The fastest feedback loop I can think of is a WYSIWYG editor. However my experience with WYSIWYG is not great. To make WYSIWYG works, tools require pretty stringent feature constraints. For instance it is hard to be consistent across pages due to the free-hand nature of WYSIWYG tools. WYSIWYG tools work with their internal and opaque data structures, which then hinder composition with other software and may have challenging upgrade paths.&lt;/p&gt; &lt;p&gt;From experience with LaTeX and markdown in GitHub/GitLab documents, I think a fast-preview is good enough. A Live-preview like in HTML-IDE is almost as good as the immediacy of WYSIWYG. Given that I am writing HTML content, I could use a JS script to automatically reload after changes like some JS applications frameworks (e.g., NextJS) offer.&lt;/p&gt; &lt;h3 id="markdown-for-the-meaty-content-functional-layouts"&gt;markdown for the &lt;em&gt;meaty&lt;/em&gt; content, functional layouts&lt;/h3&gt; &lt;p&gt;To make a blog page you need two broad set of HTML information, the meaty content and the layout parts. The meaty content is the large amount of words and paragraphs and images that make the core of the site. This is what readers are interested in. The layout is what readers (and robots) need to navigate and discover the content. The layout adds some wrapping and normalization of headers, footers etc.&lt;/p&gt; &lt;p&gt;To write meaty-content, you typically want a language with little line-noise than then renders to HTML chunks. Platforms have a variety of syntax for this. For instance, Wikipedia has its own format with specific features to recognize links between articles etc. Beside supporting a ‚Äòflow of consciousness‚Äô approach, these formats are good because we can easily re-use existing tooling such as the &lt;code&gt;aspell&lt;/code&gt; spellchecker, &lt;code&gt;grep&lt;/code&gt; to locate some keywords without too much false-positive. For my own blog I settled on &lt;a href="https://commonmark.org/"&gt;Commonmark&lt;/a&gt; which is roughly &lt;em&gt;enhanced-markdown-with-a-proper-spec&lt;/em&gt;. Commonmark has been invented by one author of Pandoc, which gives a lot of credit to the initiative.&lt;/p&gt; &lt;p&gt;In tension with the ‚Äúmeaty content‚Äù is the ‚Äúlayout‚Äù. We need to wrap out meaty content with repetitive information but also with a fair amount of article-specific dynamic information (e.g., the publication date should always be at the same position, a list of keywords should be present when keywords are present). I need some automated templating to achieve a proper layout, some templating languages exist like &lt;a href="https://mustache.github.io/"&gt;Mustache&lt;/a&gt;, &lt;a href="https://haml.info/"&gt;Haml&lt;/a&gt;, &lt;a href="https://pkg.go.dev/text/template"&gt;GoTemplate&lt;/a&gt;, but I always felt the overhead of learning these specific syntaxes and using these outweighs their benefit. Let me elaborate a bit: these templating languages are constrained to avoid doing things like starting a web-server while rendering some HTML. They support constructs like iterations into structures for repeated information (e.g., for each tag add a &lt;code&gt;&amp;lt;li&amp;gt;{{tag.name}}&amp;lt;/li&amp;gt;&lt;/code&gt; content). This is all good, however for any non-trivial layout, you end up preparing a very specific data structure with all the right computations (e.g., sorting, numbering things). In the end, you need to morally prepare your template twice: first in the rendering to HTML in the template language itself, a second time in the data structure you pass to the template engine. Maintenance is complicated, and you lose a lot of type checking benefits at the boundary between your main language and your templating language. In short, you gained little at extra cost.&lt;/p&gt; &lt;p&gt;In my opinion, templating and layout are solved by restricting oneselves to pure-functions from some dataset to an HTML structure &lt;code&gt;DataSet -&amp;gt; HTML&lt;/code&gt;. Hence, functional programming is &lt;strong&gt;the right tool for the job&lt;/strong&gt;. I happen to know Haskell well, the author of Commonmark wrote a couple of libraries in Haskell &lt;span class="emoji" data-emoji="arrow_right"&gt;‚û°Ô∏è&lt;/span&gt; overall I have no reasons to shy away and pick something different.&lt;/p&gt; &lt;h3 id="customizable-metadata-css-js-per-article"&gt;customizable metadata, CSS, JS per article&lt;/h3&gt; &lt;p&gt;I have ideas for some articles that would benefit from having special CSS or special JS scripts (e.g., to add some interactivity). Ideally, I want the ability to insert assets on a per-page basis. Since there are different reasons for inserting a specific asset (e.g., the layout is different for a generated article listing than for a normal article), customization could be written at the Haskell side or in the meaty content but in most cases we should configure that from the meaty content. Ideally, I would type multiple sections in a single file to avoid spreading what is a single article into many files with a proper directory structure (I don‚Äôt enjoy structuring directories until I feel enough pain to do so). An example of files with sections are &lt;a href="https://en.wikipedia.org/wiki/MIME#Multipart_messages"&gt;multipart-emails&lt;/a&gt;. And your email client can totally make sense of images, HTML parts, text parts from a condensed text file. Let‚Äôs take inspiration on this.&lt;/p&gt; &lt;h2 id="synthesis-of-requirements"&gt;Synthesis of requirements&lt;/h2&gt; &lt;p&gt;The thing I want is some Haskell-variant that (a) interprets markdown-like files for the &lt;em&gt;meaty content&lt;/em&gt; then passes that into (b) some rendering function. These files could (c) be augmented with extra data and extra CSS/JS. The tool I want would have a generate-static-site and a serve-on-the-fly-files to accommodate the ambivalent ‚Äòstatic but also live but also with an API if I want one day‚Äô aspects.&lt;/p&gt; &lt;p&gt;I don‚Äôt really want to invest time in learning something that will be irritating in one of these dimensions. Established tools may be too rigid to accommodate some of my quirks. The closest tool I found likely is &lt;a href="https://jaspervdj.be/hakyll/"&gt;Hakyll&lt;/a&gt;, a Haskell static-site generation library. It supports some form of metadata per-article for customizing the article (e.g., picking a certain layout) but I really want to insert multiple sections.&lt;/p&gt; &lt;p&gt;Thus, overall, I got a pretext to &lt;strong&gt;invent my own&lt;/strong&gt; &lt;span class="emoji" data-emoji="nerd_face"&gt;ü§ì&lt;/span&gt; .&lt;/p&gt; &lt;h1 id="implementation"&gt;Implementation&lt;/h1&gt; &lt;p&gt;Let‚Äôs first say that the implementation I present here does not represent the whole iterations. I first started with a simple file-to-file generator taking exactly one &lt;code&gt;.cmark&lt;/code&gt; file with multiple sections and turning that into &lt;code&gt;.html + .css&lt;/code&gt; . Proper layouts and live-reloads came later, the whole blog has been a single Haskell file until long (i.e., when compilation time where too long while changing only the layout).&lt;/p&gt; &lt;p&gt;This section does not speak about Haskell but rather focuses on the general architecture. Thus when I say ‚Äúa function‚Äù you can imagine it‚Äôs ‚Äúa monad‚Äù if you feel compelled to entertain an annoying clich√© about Haskellers detached from reality.&lt;/p&gt; &lt;h2 id="main-architectural-blocks"&gt;Main Architectural Blocks&lt;/h2&gt; &lt;p&gt;The following picture sketches roughly the blog engine pipeline.&lt;/p&gt; &lt;p&gt;&lt;img src="/gen/images/blog-phases.dot.png" alt="pipeline" /&gt;&lt;/p&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;compile&lt;/strong&gt; &lt;code&gt;ghc&lt;/code&gt; turns Haskell code into a &lt;code&gt;binary&lt;/code&gt; that contains the blog layout and advanced rules &lt;/li&gt; &lt;li&gt;&lt;strong&gt;read&lt;/strong&gt; collects all input files, possibly other sources &lt;/li&gt; &lt;li&gt;&lt;strong&gt;assemble&lt;/strong&gt; builds an understanding of everything that needs to be generated, copied etc. &lt;/li&gt; &lt;li&gt;&lt;strong&gt;produce&lt;/strong&gt; writes all the needed files to the right location &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;So overall it is pretty simple and nothing is ground-breaking. Assuming the compile step is already done you have a binary. The binary will have a fixed layout that can generate a blog for new content. To illustrate, adding a &lt;em&gt;new article&lt;/em&gt; is done by adding a new &lt;code&gt;.cmark&lt;/code&gt; file but &lt;strong&gt;requires no recompilation&lt;/strong&gt;. But &lt;em&gt;changing the HTML&lt;/em&gt; structure to display the social links &lt;strong&gt;requires a code-change and a recompilation&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;To motivate the next sections it is worth detailing the assembly-part of the blog engine. Let‚Äôs focus on &lt;code&gt;read -&amp;gt; assemble -&amp;gt; produce&lt;/code&gt; steps.&lt;/p&gt; &lt;h3 id="detailed-assembly-pipeline"&gt;detailed assembly pipeline&lt;/h3&gt; &lt;p&gt;A more detailed conceptual pipeline of the three last steps is as follows. In the following graph arrows represent the data flow (i.e., starting from inputs data representations progress towards the output files).&lt;/p&gt; &lt;p&gt;&lt;img src="/gen/images/blog-engine.dot.png" alt="pipeline" /&gt;&lt;/p&gt; &lt;p&gt;At the top you get input files such as CSS or Commonmark files. We could easily add external inputs as well. All these sources get stuffed into an object named &lt;code&gt;Site&lt;/code&gt; which sort of contains the whole knowledge about inputs for a Site.&lt;/p&gt; &lt;p&gt;An &lt;code&gt;assemble&lt;/code&gt; function then takes the &lt;code&gt;Site&lt;/code&gt; and turns that into &lt;code&gt;Targets&lt;/code&gt; objects. The Targets themselves are not yet concrete files. Rather, they are annotated recipes about how to produce a single output. The recipe itself is named a &lt;code&gt;Production Rule&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;Production Rules&lt;/code&gt; then can be executed on demand to either generate static files or being generated on the fly by a web-server (if the web-server is written in Haskell). We are lucky enough to have very good web-servers and web-API libraries in Haskell which allows to compose such an hybrid system ‚Äì this hybrid system is handy for the developer-mode.&lt;/p&gt; &lt;p&gt;A key aspect of the pipeline (highlighted in the picture) is that the &lt;code&gt;assemble&lt;/code&gt; function actually is a bit more complicated than a mere mapping from JS, Markdown etc. There are two complications:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Extra-Targets can be computed from main targets, for instance each topic gets a listing page. These rules mainly are written in Haskell: the &lt;code&gt;index.cmark&lt;/code&gt; also needs the list of all &lt;code&gt;Article&lt;/code&gt; targets to generate extra content on top of some text written in Commonmark; for each &lt;code&gt;tag&lt;/code&gt; we create an index Target page and they all use the same &lt;code&gt;tags.cmark&lt;/code&gt; instructions &lt;/li&gt; &lt;li&gt;&lt;code&gt;Articles&lt;/code&gt; are written in Commonmark however the blog engine expects a special format that contains &lt;code&gt;Sections&lt;/code&gt;, these Sections contain the meaty content but also metadata information in JSON and commands that could lead to generating more files &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Overall, I need to use an ad-hoc mix of Haskell and Commonmark to generate pages and their templates. This mix is means there sometimes is two ways to do a thing (e.g., should I add some default CSS file in the layout or via includes in the CSS-section of individual articles so that I can override it entirely?) with no clear immediate tradeoff.&lt;/p&gt; &lt;h3 id="sample-output"&gt;sample output&lt;/h3&gt; &lt;p&gt;When the binary executes you get an uninteresting log of what occurs. This log can help understand what happens.&lt;/p&gt; &lt;div id="sample-output-txt"&gt; &lt;pre&gt;&lt;code class="language-text"&gt;found site-src/talks.md found site-src/how-this-blog-works.md found site-src/snake-cube.md found site-src/alphabets.md found site-src/tags.md found site-src/santa-wrap.md found site-src/about-me.md found site-src/index.md generating out/gen/out/index.md__gen-date.txt executing `date` with args [] generating out/gen/out/index.md__gen-git-head-sha.txt executing `git` with args [&amp;quot;rev-parse&amp;quot;,&amp;quot;HEAD&amp;quot;] assembling out/talks.html assembling out/how-this-blog-works.html assembling out/snake-cube.html assembling out/alphabets.html assembling out/santa-wrap.html assembling out/about-me.html assembling out/index.html copying out/images/snake-cube-folded.jpeg copying out/images/snake-cube-l-shape.png copying out/images/snake-cube-mzn-003.png copying out/images/snake-cube-coords.png copying out/images/snake-cube-mzn-001.png copying out/images/sword.png copying out/images/layout-restricted.png copying out/images/geost-doc.png copying out/images/parts.png copying out/images/background.png copying out/images/snake-cube-mzn-002.png copying out/images/layout-robot-200x240.png copying out/images/deps.png copying out/images/layout-190x150.png copying out/images/layout-190x160.png copying out/images/haddock-jp.png copying out/images/snake-cube-unfolded.jpeg copying out/images/linear-layout.png generating out/gen/images/blog-phases.dot.png executing `dot` with args [&amp;quot;-Tpng&amp;quot;,&amp;quot;-o&amp;quot;,&amp;quot;/dev/stdout&amp;quot;,&amp;quot;site-src/blog-phases.dot&amp;quot;] generating out/gen/images/blog-engine.dot.png executing `dot` with args [&amp;quot;-Tpng&amp;quot;,&amp;quot;-o&amp;quot;,&amp;quot;/dev/stdout&amp;quot;,&amp;quot;site-src/blog-engine.dot&amp;quot;] copying out/css/index-wide.css copying out/css/index-narrow.css copying out/css/main.css copying out/js/autoreload.js assembling out/topics/about-me.html assembling out/topics/constraint-programming.html assembling out/topics/formal-methods.html assembling out/topics/fun.html assembling out/topics/haskell.html assembling out/topics/minizinc.html assembling out/topics/optimization.html assembling out/topics/sre.html assembling out/topics/web.html generating out/json/paths.json generating out/json/filecounts.json &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;(this excerpt is out of date but not you get the boring feeling)&lt;/p&gt; &lt;/div&gt; &lt;h2 id="section-based-file-format"&gt;Section-based file format&lt;/h2&gt; &lt;p&gt;An input file for an Article is suffixed &lt;code&gt;.cmark&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The content of a single file with multiple sections is a file like the following example:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;=base:build-info.json {&amp;quot;layout&amp;quot;:&amp;quot;article&amp;quot; } =base:preamble.json {&amp;quot;author&amp;quot;: &amp;quot;Lucas DiCioccio&amp;quot; ,&amp;quot;date&amp;quot;: &amp;quot;2022-02-01T12:00:00Z&amp;quot; ,&amp;quot;title&amp;quot;: &amp;quot;An article about Haskell&amp;quot; } =base:topic.json {&amp;quot;topics&amp;quot;:[&amp;quot;haskell&amp;quot;, &amp;quot;some-tag&amp;quot;] ,&amp;quot;keywords&amp;quot;:[&amp;quot;some keyword&amp;quot;] } =base:social.json {&amp;quot;twitter&amp;quot;: &amp;quot;me&amp;quot; ,&amp;quot;linkedin&amp;quot;: &amp;quot;myself&amp;quot; ,&amp;quot;github&amp;quot;: &amp;quot;again-me&amp;quot; } =base:summary.cmark Some summary. =base:main-content.cmark # this is an h1 title ## this is an h2 title lorem ipsum ... =base:main-css.css @import &amp;quot;/css/main.css&amp;quot; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Each section is a textual block starting with a special delimiter like &lt;code&gt;=base:build-info.json&lt;/code&gt;. The layout code actually interprets these sections and look for various information. For instance, the &lt;code&gt;=base:topic.json&lt;/code&gt; contains information to add some topic-index and &lt;code&gt;meta&lt;/code&gt; tags. The &lt;code&gt;=base:main-css.css&lt;/code&gt; section allows to write some CSS that will be inlined in the HTML (conversely, &lt;code&gt;.css&lt;/code&gt; files found in the source directory will be copied around).&lt;/p&gt; &lt;p&gt;These sections could all be collapsed in a single section however I find it convenient to have one small datatype per logical ‚Äòmetadata‚Äô piece.&lt;/p&gt; &lt;h2 id="dev-mode-and-auto-reload"&gt;Dev-mode and auto-reload&lt;/h2&gt; &lt;p&gt;The dev-server API itself is written with my &lt;a href="https://github.com/lucasdicioccio/prodapi"&gt;prodapi&lt;/a&gt; API library, which curates some good Haskell libraries for building APIs. There is enough to help running background tasks in the process (e.g., to watch for file-changes), and also to expose other dev-mode-only endpoints.&lt;/p&gt; &lt;p&gt;Examples of dev-mode-only endpoints are:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;a listing of all targets (which is useful when I lose track of what targets exist) &lt;/li&gt; &lt;li&gt;an endpoint I can call to rebuild the static-file outputs from the dev-server directly (rather than running the binary with different parameters) &lt;/li&gt; &lt;li&gt;build-time statistics &lt;/li&gt; &lt;li&gt;autoreload-helpers (see the dedicated section below) &lt;/li&gt; &lt;/ul&gt; &lt;h3 id="autoreload"&gt;autoreload&lt;/h3&gt; &lt;p&gt;I have a poor-man‚Äôs &lt;code&gt;autoreload.js&lt;/code&gt; script (source here &lt;a href="/js/autoreload.js"&gt;source of auto-reload script&lt;/a&gt;). That perform long-polling to a API route &lt;code&gt;/dev/watch&lt;/code&gt; that only the dev-webserver knows about (i.e., there won‚Äôt be a Target to generate for this URL path). The &lt;code&gt;autoreload.js&lt;/code&gt; script performs a full-page reload, which is acceptable as most of the articles I will ever write will mostly be stateless texts but.&lt;/p&gt; &lt;p&gt;The current implementation works using the amazing Software Transactional Memory (STM) support in Haskell and supports live-reloading mutliple pages simultaneously from different clients connected to a same server (not like I really use this feature but it does not incur much more work). Implementation of the live-reload is illustrated as follows:&lt;/p&gt; &lt;p&gt;&lt;img src="/gen/images/autoreload-watches.dot.png" alt="autoreload" /&gt;&lt;/p&gt; &lt;p&gt;The server API route mediates a rendez-vous between:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;The &lt;code&gt;Web Browser&lt;/code&gt; who waits for an answer to the API call &lt;/li&gt; &lt;li&gt;&lt;code&gt;Filesystem&lt;/code&gt; changes that are propagated via inotify &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Overall, from a high-level perspective the live-reload follows these four simple steps:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Step-0. after loading the &lt;code&gt;.js&lt;/code&gt; a browser starts a watch over the HTTP request API handler &lt;/li&gt; &lt;li&gt;Step-1. inotify notifies the file-system change &lt;/li&gt; &lt;li&gt;Step-2. the watch terminates &lt;/li&gt; &lt;li&gt;Step-3. the HTTP request finishes, the browser reloads (which will return to Step-0) &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Three threads co-exist in the server:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;the &lt;code&gt;inotify&lt;/code&gt; callbacks loads targets then propagates them in a &lt;em&gt;Site&lt;/em&gt; (using a &lt;code&gt;TMVar Site&lt;/code&gt;), this thread is like if an event-stream of updated Sites was available but we only hold-on to the latest value &lt;/li&gt; &lt;li&gt;the &lt;code&gt;api&lt;/code&gt; registers a &lt;em&gt;Watch&lt;/em&gt; (using one &lt;code&gt;TMVar ()&lt;/code&gt; per HTTP-request) and inserts it in a list of pending watchers &lt;em&gt;[Watch]&lt;/em&gt; , then waits for the Watch to end &lt;/li&gt; &lt;li&gt;the server &lt;code&gt;background&lt;/code&gt; waits for the filesystem flag changes, clears the flag, then fans-out the signal to waiting HTTP-clients, all of this is atomic outside the STM area (all the changeds are annotated &lt;code&gt;flush&lt;/code&gt; in orange on the picture) &lt;/li&gt; &lt;/ul&gt; &lt;h1 id="experience-report"&gt;Experience report&lt;/h1&gt; &lt;p&gt;It has been fun to write some get-stuff-done Haskell. I sincerely believe this blog engine does not have to shy away in face of other tools. I will surely try to extract the library code as a standalone engine at some point, but for now my repository mixes library, specific layout and rules for my own blog, and content.&lt;/p&gt; &lt;p&gt;Let me explain a few things that I find rather pleasant.&lt;/p&gt; &lt;h2 id="sections-and-file-generators"&gt;Sections and file generators&lt;/h2&gt; &lt;p&gt;Some interesting Sections and ProductionRules:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;dotfile conversion: turn a &lt;code&gt;.dot&lt;/code&gt; file into a &lt;code&gt;.png&lt;/code&gt; with &lt;a href="https://graphviz.org/"&gt;GraphViz&lt;/a&gt;; the live-reload in the output web-page without leaving &lt;code&gt;vim&lt;/code&gt; makes it a breeze (see video below) &lt;/li&gt; &lt;li&gt;section command-gen: generates a file from a UNIX command (e.g., to get a special file with the git-sha or build timestamp) &lt;/li&gt; &lt;li&gt;section summary: short Commonmark content that appear in article listings (it also gets stripped down to text to add a meta tag) &lt;/li&gt; &lt;li&gt;section taken-off: stuff that is in the source but will be ignored, useful for draft sections &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The following video gives an idea of how the live-reload of GraphViz-generated images work:&lt;/p&gt; &lt;video width="640" height="480" controls&gt; &lt;source src="/videos/demo-blog.webm.mp4" type="video/mp4"&gt; &lt;source src="/videos/demo-blog.webm" type="video/webm"&gt; &lt;/video&gt; &lt;p&gt;I find this live-reload good enough to now run my blog-engine when I need to quickly edit such a graph for work.&lt;/p&gt; &lt;h2 id="commonmark-is-great"&gt;Commonmark is great&lt;/h2&gt; &lt;p&gt;The Commonmark package &lt;a href="https://github.com/jgm/commonmark-hs/tree/master/commonmark-extensions"&gt;supports extensions&lt;/a&gt;. For instance, I have enabled the emoji syntaxt that turns &lt;code&gt;:smiley:&lt;/code&gt; into &lt;span class="emoji" data-emoji="smiley"&gt;üòÉ&lt;/span&gt;. I also enabled support for directly adding HTML tags (including JS) or annotating sections of code with HTML attributes if the rendering is not sufficient. Another use case is when you want to drop down to HTML or if you need small-scripting capabilities.&lt;/p&gt; &lt;p&gt;With HTML-tagging and JS inclusion, the following code:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;::: {.example} press to get an alert &amp;lt;button class=&amp;quot;example-button&amp;quot; onClick=&amp;quot;alert('hi from commonmark')&amp;quot;&amp;gt;press me&amp;lt;/button&amp;gt; ::: &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;‚Ä¶ gives the following rendering (with some CSS style defined in the CSS-section).&lt;/p&gt; &lt;div class="example"&gt; &lt;p&gt;&lt;strong&gt;press to get an alert&lt;/strong&gt; &lt;button class="example-button" onClick="alert('hi from commonmark')"&gt;press me&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;h2 id="you-can-get-creative"&gt;You can get creative&lt;/h2&gt; &lt;p&gt;Direct-embedding of JavaScript allows me to write JavaScript as page-enhancement snippets (e.g., adding a ‚Äòmail-to‚Äô tag for each talk in the &lt;a href="/talks.html"&gt;Talks&lt;/a&gt; page). What excites me the most is that I can also build some full-blown visualizations (e.g., the graph-view on the &lt;a href="/index.html"&gt;home page&lt;/a&gt;). The Haskell-side of the blog-engine allows me to implement pretty much arbitrary logic to prepare some JSONs objects as special targets. Such objects typically are article-specific or site-wide summaries. I can then treat these targets as API endpoints that have fixed content once the site is entirely-produced but where the data is dynamically-recomputed while in developer mode.&lt;/p&gt; &lt;h3 id="site-wide-statistics"&gt;site-wide statistics&lt;/h3&gt; &lt;p&gt;An example of this JavaScript usage below shows you can embed JavaScript for visualizations (example with &lt;a href="https://vega.github.io/vega-lite/usage/embed.html"&gt;Vega-Lite&lt;/a&gt;). Further, the visualization loads a special file &lt;a href="/json/filecounts.json"&gt;json-file-counts&lt;/a&gt; that has been generated as a special Target part of the layout. However, a generator section could also create a similar target.&lt;/p&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vega@5.21.0"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vega-lite@5.2.0"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vega-embed@6.20.2"&gt;&lt;/script&gt; &lt;div id="vis"&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var yourVlSpec = { $schema: 'https://vega.github.io/schema/vega-lite/v5.json', description: 'A simple bar chart with embedded data.', data: { url: "/json/filecounts.json" }, mark: 'bar', encoding: { x: {field: 'srctype', type: 'ordinal'}, y: {field: 'count', type: 'quantitative'} } }; vegaEmbed('#vis', yourVlSpec); &lt;/script&gt; &lt;h3 id="article-shape-statistics"&gt;article-shape statistics&lt;/h3&gt; &lt;p&gt;I typically try to balance-out my articles. While writing LaTex, it‚Äôs easy to see the page/column count per page. In HTML we do not really have an immediate equivalent.&lt;/p&gt; &lt;p&gt;A good example of per-article statistics is a histogram made with &lt;a href="https://echarts.apache.org"&gt;Apache ECharts&lt;/a&gt; that I produce and display while in developer-mode to get a visual glimpse of how the article is shaped.&lt;/p&gt; &lt;script src="js/echarts.min.js"&gt;&lt;/script&gt; &lt;script src="js/jquery-3.6.0.min.js"&gt;&lt;/script&gt; &lt;script src="js/echart-histogram.js"&gt;&lt;/script&gt; &lt;div id="histogram"&gt; &lt;/div&gt; &lt;p&gt;On the X-axis you get an index of text blocks in the Commonmark file. Whereas the Y-axis is the cumulative number of words so far. This way I can visualize what is the shape of the article and detect highly-imbalanced paragraphs. This histogram is ‚Äúwork in progress‚Äù and I tend to adapt it when I feel like it (I would like to also have markers for images/links). This visualization is automatically-inserted in the ‚Äúdeveloper mode‚Äù layout. However, given that the JSON object target with the article stats is &lt;a href="/json/how-this-blog-works.cmark.json"&gt;a generated target&lt;/a&gt;, I can show you in this article by manually inserting the &lt;a href="/js/echart-histogram.js"&gt;JavaScript&lt;/a&gt;. The JavaScript code knows the URL to the special target for the current article with statistics by looking up a custom &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tag, so that the JavaScript include does not require tweaking or per-page configuration. Longer term, I may decorate every article with such a navigation help.&lt;/p&gt; &lt;h2 id="future-ideas"&gt;Future ideas&lt;/h2&gt; &lt;p&gt;Besides open-sourcing the engine (which means tracking hardcoded things or personal-layouts, plus maintaining an external project). There is much I would like to implement. Unfortunately, these ideas have an activation function a bit higher than I have energy these days. More bluntly, I‚Äôd rather focus on writing more content rather than working on the blog engine itself.&lt;/p&gt; &lt;p&gt;Regarding &lt;em&gt;templating&lt;/em&gt;. I still would like some interpreted templating (e.g., Mustache) for some very specific cases such as data tables, with data generated from another section. The reason is that to add a new article I should write code only for the article rather than splitting haskell and Commonmark around (exceptions are special pages like &lt;code&gt;tags.md&lt;/code&gt; and &lt;code&gt;index.md&lt;/code&gt;).&lt;/p&gt; &lt;p&gt;This will require some extra wiring in the Target-assembly part and some difficult decision as to what is really-static and what is in-fact dynamic. My main inspiration are &lt;a href="https://jupyter.org/"&gt;Jupyter&lt;/a&gt; notebooks.&lt;/p&gt; &lt;p&gt;Regarding new &lt;em&gt;sections&lt;/em&gt;, &lt;em&gt;targets&lt;/em&gt;, or &lt;em&gt;layouts&lt;/em&gt;. I would like to allow to have scripting-language sections (for now I only have direct shell commands). For instance to generate a picture using &lt;code&gt;R&lt;/code&gt; or &lt;code&gt;Python&lt;/code&gt;. It would be nice as well to inline the dot-source of GraphViz pictures directly in the &lt;code&gt;.cmark&lt;/code&gt; file. RSS targets also are on my wishlist, however I do not use a lot of RSS myself. I also would like to have some article-type layouts for photo albums and snippet-like entries (e.g. to improve on the &lt;a href="/tips.html"&gt;Tips page&lt;/a&gt;).&lt;/p&gt; &lt;p&gt;Regarding &lt;em&gt;dependency-graphs&lt;/em&gt;. I would like to have a section where required URLs can be declared. Doing so will enable more interesting build sequences.&lt;/p&gt; &lt;p&gt;As a &lt;em&gt;fluid static to web-app engine&lt;/em&gt;, I think this blog-engine is a good starting-point for mixed website where some pages or endpoint are dynamic API calls. I already have a ‚Äúserve mode‚Äù for the day where I feel compelled to move out of GitHub pages. The ‚Äúserve-mode‚Äù for now is just the ‚Äúdev mode‚Äù but without the special-routes and special-layouts but it would need some extra configurations and simple caching strategies to reduce security-risk vectors (e.g., to prevent arbitrary-commands generators and costly targets to be run on demand).&lt;/p&gt; &lt;p&gt;Some inspiration for future work can also be found in the &lt;a href="/readings.html#static-and-personal-site-technology"&gt;Readings&lt;/a&gt; page (section ‚ÄúStatic and personal site technology).&lt;/p&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/how-this-blog-works.html" rel="alternate"/>
        <summary type="text">
            The overengineering behind this blog. Or is it not over-engineered?
        </summary>
    </entry>
</feed>
