<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title type="text">
        Lucas DiCioccio's blog
    </title>
    <id>
        https://dicioccio.fr/atom.xml
    </id>
    <updated>
        2022-09-14T12:00:00Z
    </updated>
    <entry>
        <id>
            https://dicioccio.fr/always-refactoring.html
        </id>
        <title type="text">
            My devs are always refactoring! why? [part-2]
        </title>
        <updated>
            2022-09-14T12:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;div class=".note"&gt; &lt;p&gt;This article is the second in a series of articles on refactoring.&lt;/p&gt; &lt;/div&gt; &lt;p&gt;From a non-developer viewpoint, it may be hard to connect with developers who are &lt;strong&gt;always refactoring&lt;/strong&gt;. I wrote this article to fill a gap I noticed during multiple discussions with non-technical stakeholders: some stakeholders have the feeling that tech teams are “always refactorin’”. Depending on the type of relationships between developers and other roles, the question whether to refactor or not can become a point of acute tension.&lt;/p&gt; &lt;h1 id="refactoring-to-support-project-scope-changes"&gt;Refactoring to support &lt;a href="/hashtags/project-scope.html"&gt;&lt;span class="hashtag" data-hashtag="project-scope"&gt;#project-scope&lt;/span&gt;&lt;/a&gt; changes&lt;/h1&gt; &lt;p&gt;Let’s recollect what we introduced in the &lt;a href="/what-is-the-project-scope.html"&gt;previous article about project scopes&lt;/a&gt; and the &lt;a href="/scope-explorer.html"&gt;complementary toy-application&lt;/a&gt;. As software projects grow, we accumulate code to enable features.&lt;/p&gt; &lt;p&gt;When a new feature is required, we are faced with an easy decision: pause in-progress work and prioritize on new features or continue on what is in progress. Conversely, when a new technical or process requirement pops-up, we are faced with more difficult decisions: we need to revisit everything in scope that has been shipped already. A decision to implement or postpone is required for each individual feature already shipped and in scope. Typically, one can live with some gaps for some time (e.g., missing tests, hardcoded parameters, outdated libraries, manual approval in an otherwise automated process, un-even edge-case coverages for two flavors of a same system). However, at some point the infamous &lt;em&gt;technical debt&lt;/em&gt; weighs too much and a feature can be considered unfinished. In short, as requirements pile-up there is some risk that your &lt;strong&gt;effective coverage reduces even though the amount of delivered tasks increases&lt;/strong&gt;, an effect that I refer to as a &lt;em&gt;coverage cave-in effect&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;&lt;img src="/images/project-scope-timeline.png" alt="scope can suffer from cave-in" /&gt;&lt;/p&gt; &lt;p&gt;Refactoring is an attempt at mitigating cave-ins for upcoming requirements. The mitigation can be either anticipated or reacted-upon. If you anticipated, you do not observe the “cave-in” gap but the totalled amount of refactoring work incurs some delay. If the refactoring work is reactive you get to do the same amount of work anyway, except that you do it while your effective coverage is reduced. Overall, engineers tend to like refactors: they will recognize the risks of cave-ins and will often express the need to “refactor first”. As refactor are pushed in the future engineers keep discussing the need to refactoring. When the refactoring starts, it takes longer than expected and leaves even more extra work. Overall, I have witnessed, and I can see a number of scenarios in which product managers grow the feeling that engineers are always refactoring.&lt;/p&gt; &lt;h2 id="refactoring"&gt;Refactoring&lt;/h2&gt; &lt;p&gt;Refactoring is a technical task and a technical challenge: change how a component operates without affecting the external behavior. People obsessed with “customer value” raise eyebrows because a refactor brings “no value” to a product. Pedantic engineers will note that &lt;strong&gt;business value is not only customer value&lt;/strong&gt;. Indeed, engineers do not refactor for the desire of challenges: engineers refactor to reach a more favorable state than from where they started.&lt;/p&gt; &lt;p&gt;Examples of goals for refactors are:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;uniformize some idioms in a code-base so that (e.g., when merging two implementations from two different maturity levels a your product) &lt;/li&gt; &lt;li&gt;keep an acceptable pain-level for people who need to maintain or operate the system &lt;/li&gt; &lt;li&gt;prepare for planned ulterior scope changes (e.g., in order to internationalize a service) &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;In the first example, the value resides in paying-up some “tech debt”. In the second example, the value is pairwise: liberate resources for higher-value tasks and improve the satisfaction of team members (employee churn is an active threat to teams’ success). Finally, the third example is merely time-shifting future work into the present, without changing much the actual customer value.&lt;/p&gt; &lt;p&gt;Among engineers, some purely-technical tasks like “changing the logging format” may not be recognized as “a honest to god refactor”. Somehow, as far as our discussion is concerned, and as far as engineer-product communication goes, the decisive characteristics we care about is the absence of customer-value. The “refactoring” label merely is a shorthand for how to classify this task: it takes work but if you are not an engineer you need not know how the sausage is made.&lt;/p&gt; &lt;p&gt;Misunderstanding the goal of a refactoring task may lead to some &lt;em&gt;breach of trust&lt;/em&gt; between product and engineering &lt;span class="emoji" data-emoji="warning"&gt;⚠️&lt;/span&gt;. The main catch is: developers’ happiness and morale are part of their productivity and you have an incentive and some moral obligation to create virtuous cycles rather than self-defeating feedback loops.&lt;/p&gt; &lt;h1 id="i-believe-my-team-is-always-refactoring-what-should-i-do"&gt;I believe my team is always refactoring what should I do?&lt;/h1&gt; &lt;p&gt;Now that background is setup, let start the real discussion. You are in a frustrating situation where the team delivery feels slow, and engineers seem to do refactoring over refactoring.&lt;/p&gt; &lt;h2 id="first-is-it-really-true"&gt;First, is it really true?&lt;/h2&gt; &lt;p&gt;In all companies, you need to settle on some acceptable amount of technical work, which includes refactors. In a sense, it is the “cost of doing business”. A fork of accepted technical work varies from 20% to 50% of technical work . The proportion you observe should probably fluctuate within this range and could deviate more depending on the erratic aspects of companies’ timelines.&lt;/p&gt; &lt;p&gt;However, a team deviating for too long may be a reason for concern: too little technical work probably means you are post-poning tasks you should have done already, too much time spent on technical work may mean your team lacks purposeful tasks or maybe they are circling and figuring things out (in the latter case, they need hindsights from senior engineers/architects).&lt;/p&gt; &lt;p&gt;&lt;img src="/images/always-refactoring-tunnel-01.jpeg" alt="technical work acceptable band" /&gt;&lt;/p&gt; &lt;p&gt;As illustrated in the above picture, if you plot the fraction of work spent along time, you should expect some team to stay in the 20-50% band. In this example, the green-plain line is okay, the two dashed-lines probably deserve some investigation. The 20%-50% bracket is more a rule of thumb speaking from experience (personal, colleagues, also a &lt;a href="https://twitter.com/lucasdicioccio/status/1568665141662851073"&gt;recent Twitter poll I made in preparation of this article&lt;/a&gt;) than anything.&lt;/p&gt; &lt;p&gt;One caveat here is that you need some fair assessment of how much engineer time is taken by refactorings. From experience, I’ve seen that it may be challenging for tech leaders to provide such a fair assessment. Without turning this post into some advertisment, &lt;a href="https://www.echoeshq.com/"&gt;my current company&lt;/a&gt; provides a service to solve this question among many other questions.&lt;/p&gt; &lt;p&gt;Now, assuming that you have legitimate concerns regarding some refactoring work, let’s discuss the &lt;em&gt;timing of refactoring&lt;/em&gt;. Then we’ll discuss avenues to challenge and &lt;em&gt;push back&lt;/em&gt; a team member who wants to refactor something when you think there are better things to do.&lt;/p&gt; &lt;h2 id="the-timing-of-the-refactoring-is-key"&gt;The timing of the refactoring is key&lt;/h2&gt; &lt;p&gt;Project planning, sprint sessions, and similar corporate ceremonies are venues where teams discuss the need for refactorings. Alas, no-one is encitivized to tell the truth in such ceremonies: time or complexity estimates always are fudged and a complex meta-game between makers and askers happens around roadmaps. Such ceremonies deserve better. If your teams are always refactoring, you have likely witness a heated discussion when a developer brings up a refactoring task. In this situation, it is a good idea to keep in mind that developers will bring up refactoring tasks for a reason, and in general to avoid some functional cave-in.&lt;/p&gt; &lt;p&gt;Refactorings exist mostly to prevent some form of looming or occurred functional cave-in. Thus you cannot get a lot of information by challenging “why” people refactoring. A more interesting characteristics for a refactor is the question of “when”. A refactor can be preliminary work, wrap-up work, or intermediary work.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;em&gt;As preliminary work&lt;/em&gt;. Most features benefit from chunking into many small tasks. Preliminary refactors (e.g., moving all functions into some common umbrella module) are easy to plan and scope ahead of time. Consider these as stepping stones reducing the risk of a particular delivery.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;em&gt;As wrap-up work&lt;/em&gt;. One may consider a feature unfinished from a technical standpoint while it is already delivering on a functional standpoint. It is common to deploy some Proof of Concept early to test a feature. These Proof of Concept often are “too large”. The hindsight gained from running a system is light shedding. Engineers will find flaws and limitations in their system that would have been better handled in other ways. I would advise budgetting some time to perform such wrap-up as engineers still have a lot of working knowledge of the code. On the opposite, moving onto to new features in a haste with no time to wrap-up is a longer-term risk.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;em&gt;As intermediary work&lt;/em&gt;. The fractal nature of projects’ scopes and the erratic nature of scope discovery ensure that hiccups occur. Some severe obstacle may pop-up while implementing some feature (e.g., a third-party API exhibits severe rate-limitations on an endpoint you used to rely on and you need to pass some cache in a whole slice of code, adapt tests and so on). You may not be aware of most of these refactors as small refactors occur as part of the normal flow of development. Incredible delays may occur when the larger system or infrastructure require changes. A way to rationalize these intermediary refactors is to consider them preliminary or wrap-up of some subtask.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Thus, in the bad cases, for one single feature, team members may argue three times in favour of refactoring. Given that many features are discussed in ceremonies, engineers may come across as people who are always refactoring.&lt;/p&gt; &lt;p&gt;At this point, I mostly gave arguments in favor of refactor: they tend to go in the right direction. The real issue of refactoring is that they take up time from other concerns. Thus, if you feel like your team is always refactoring, the main problem is the one of arbitraging against other topics. You have two main ways to reduce the “refactoring-tax”: one one hand you can push-back on refactoring, on the other hand you can reduce the prevalence of refactoring with some prevention.&lt;/p&gt; &lt;h2 id="preventing-refactorings"&gt;Preventing refactorings&lt;/h2&gt; &lt;p&gt;In an ideal world, you never have debates about refactoring because the team orchestrate development with a perfect context and good understanding of the situational challenges of the day. As a leader you need to be candidly honest about upcoming tasks and deadlines. Having an idea for a feature it’s not the same as having a customer request and it’s not the same as having twenty customer requests. Needing something for next week is not the same as needing it for next month nor is the same as potentially needing it.&lt;/p&gt; &lt;p&gt;Summarily, engineers need to gauge the amount of uncertainty you have with a feature. Of critical importance are the following characteristics:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;whether the feature will be in active use or in potential use &lt;/li&gt; &lt;li&gt;whether a requirement is definite or a sketch of an idea &lt;/li&gt; &lt;li&gt;what is the freedom for digressing &lt;/li&gt; &lt;li&gt;what are the business gains and risks &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Having this information at hand helps engineers understand how to shape the delivery of the code and associated “non-functional requirements”. For instance, if a feature requires some good amount of data-crunching, a preliminary data-exploration phase is welcome to help understand where edge cases lurk. If the task requires a system and not just some code, extra monitoring, sometimes ad-hoc, will have to be built. If engineers understand the business opportunities and risks associated with a feature, they’ll be in better place to gauge how-much these “extras” are required.&lt;/p&gt; &lt;h2 id="pushing-back-on-refactorings"&gt;Pushing back on refactorings&lt;/h2&gt; &lt;p&gt;Having in mind that refactorings are mostly-positive for the health of a software. Senior engineers on a &lt;a href="/hashtags/project.html"&gt;&lt;span class="hashtag" data-hashtag="project"&gt;#project&lt;/span&gt;&lt;/a&gt; may resent push backs and even identify such push-backs as a threat to the qualify of the system. Therefore, a goal to keep in mind is not to say “no” to a refactor. Rather, a productive conversation seeks a good &lt;a href="/hashtags/tradeoff.html"&gt;&lt;span class="hashtag" data-hashtag="tradeoff"&gt;#tradeoff&lt;/span&gt;&lt;/a&gt; for every party.&lt;/p&gt; &lt;p&gt;There are a few avaialble directions to tackle a “refactor-or-not” discussion.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;em&gt;Bluff&lt;/em&gt; it out. Bluffing is a good way to lose trust from your colleagues. You’ll come across someone who is dishonest if you bluff without success to celebrate aside. Some bluffing techniques are along delaying to improve the understanding of the system you want to refactor, or some planned work that will make the to-be-refactored system obsolete.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;em&gt;Clarify&lt;/em&gt; whether the refactoring is a pure-technical change or whether the refactoring enables new features. Sometimes refactoring is an enabler for pushing more feature (e.g., when you have data to filter/sort by a set of fixed criteria and suddenly it’s better to change some querying-scheme such as supporting “arbitrary” and likely-requested future criterias). This is the best situation as you’ll learn better what are/are-not low-hanging fruit features.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;em&gt;Characterize&lt;/em&gt; qualitatively and if possible quantitatively the friction induced by the absence of refactoring. You should be able to tell if the refactoring specifically adress the pain point. You should understand whether the gain is on the long-term or on the short-term. Maybe a piece of code is garbage, but is not touched very often leading to “one horrible day every quarter”, which may be acceptable pain.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;em&gt;Chunk&lt;/em&gt;. Like most software endeavours, it’s better to split refactoring in consecutive well-defined chunks. Often, one can split and time-box the refactoring effort: for instance, do some code re-organization in a first part then apply fundamental changes in a second part. If you frame a long-refactor as a low-risk migration tasks spread over weeks you also train your team for more dangerous and longer-to-rollout migrations. The risk here is that being low-ROI the task never finishes.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;In summary, you do not have a large number of options to push back on refactorings. Bringing more people on the team can help with a punctual increase in work. Oftentimes you’ll have a better luck ensuring the overall team momentum is maintained.&lt;/p&gt; &lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt; &lt;p&gt;Cautionary tale: challenging whether a refactoring is necessary or not is a sure-fire way to sow dissent and lose momentum. If you’ve read my long article on &lt;a href="/tactical-projects.html"&gt;successful tactical projects&lt;/a&gt;, you’ll know how much I care about momentum.&lt;/p&gt; &lt;p&gt;In general you should pay attention to functional cave-in and anticipate when your project will go sideways. Sometimes a business-requirement may ask for technical changes throughout the project (for instance, data-modeling changes incur verification on already-shipped code).&lt;/p&gt; &lt;p&gt;Allocate a fair amount of work onto technical tasks. Consider that purely-technical work is part of the cost of doing business. If engineers keep bringing-up refactorings over refactoring there are things you can do to push-back without too much trouble. Ask clarification around the functional benefits of the change, characterize with the team what pain-points the refactoring addresses, consider chunking the refactoring in a few steps to allievate only the most pressing pain-point.&lt;/p&gt; &lt;p&gt;If nothing works, consider the help from senior engineers (architects, lead-developers) because your team may lack from technical direction. Of course, if egos prevent your team members from seeking external consulting, you will have a hard time convincing them to change their way of doing thing.&lt;/p&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/always-refactoring.html" rel="alternate"/>
        <summary type="text">
            I have ran into a number of product-owner puzzled by how often #developers in their team express a need to "refactor". Cannot they do it once for the quarter? This prompted me to write some notes and eventually an article to demistify a bit the "always-refactoring team".
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/scope-explorer.html
        </id>
        <title type="text">
            Scope explorer
        </title>
        <updated>
            2022-06-01T12:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;div class="surrounding-laius"&gt; &lt;p&gt;This month I’m adventuring into a new way of telling stories. Specifically, I want to explore how &lt;em&gt;micro-applications&lt;/em&gt; can help convey some information.&lt;/p&gt; &lt;p&gt;This article consists mainly of an application with an interactive tutorial. The story we illustrate is from &lt;a href="/what-is-the-project-scope.html"&gt;previous article about the scope of projects&lt;/a&gt;, so make sure to scan through the article first.&lt;/p&gt; &lt;p&gt;In the future I’ll try to intersperse such micro-applications into articles. This first attempt taught me that my current default article layout is interacting a bit too-much with the application so far. As a result the application may not work nor render well on mobile. Also, I do not promise the code is bug-free, however the steps made in the interactive Tutorial work well at least. I apologize for such recklessness.&lt;/p&gt; &lt;p&gt;In general, feedback is highly appreciated as I need to calibrate how much time to budget on micro-applications versus textual content.&lt;/p&gt; &lt;/div&gt; &lt;/section&gt;&lt;section class="main-section"&gt;&lt;div id="scope-explorer-div"&gt; &lt;/div&gt; &lt;script type="text/javascript" src="/js/scope-explorer.js" async&gt;&lt;/script&gt; &lt;/section&gt;&lt;section class="main-section"&gt;&lt;div class="surrounding-laius"&gt; &lt;h1 id="an-exercise-to-go-further"&gt;an exercise to go further&lt;/h1&gt; &lt;p&gt;As an exercise, at the end of the tutorial you could say that your application is now encoutering some success, in that case you need to be able to receive money. To receive money you’ll need some “Billing” feature(s). Have fun adding “Billing” as a feature, zooming-in and studying how to split the Billing-scope in sub-scopes.&lt;/p&gt; &lt;h1 id="help"&gt;help&lt;/h1&gt; &lt;h2 id="legend-for-edit-table"&gt;legend for: EDIT table&lt;/h2&gt; &lt;table class="legend"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; cell &lt;/th&gt; &lt;th&gt; status &lt;/th&gt; &lt;th&gt; details &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class="table-cell state-done"&gt;&lt;/td&gt; &lt;td class="legend"&gt;done&lt;/td&gt; &lt;td class="legend"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="table-cell state-todo"&gt;&lt;/td&gt; &lt;td class="legend"&gt;todo&lt;/td&gt; &lt;td class="legend"&gt;intermediary node (computed)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="table-cell state-unexplored"&gt;&lt;/td&gt; &lt;td class="legend"&gt;todo&lt;/td&gt; &lt;td class="legend"&gt;leaf of scope tree&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="table-cell state-disagreement"&gt;&lt;/td&gt; &lt;td class="legend"&gt;in disagreement&lt;/td&gt; &lt;td class="legend"&gt;intermediary node is claimed done but internal status is not&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;h2 id="the-scope"&gt;the scope&lt;/h2&gt; &lt;p&gt;As you define a matrix of &lt;em&gt;tech steps&lt;/em&gt; by &lt;em&gt;features&lt;/em&gt; , the scope of your &lt;a href="/hashtags/project.html"&gt;&lt;span class="hashtag" data-hashtag="project"&gt;#project&lt;/span&gt;&lt;/a&gt; grows.&lt;/p&gt; &lt;p&gt;If you zoom on a given tile (you over the mouse on a tile and press the 🔽 “zoom” button) then the scope displayed changes. You get prompted the whole path in your hierarchy, for instance &lt;p&gt;&lt;span&gt;&lt;button&gt;🔼&lt;/button&gt;&lt;/span&gt;&lt;span&gt;&lt;span class="path-component"&gt; TechStepName :: FeatureName&lt;/span&gt;&lt;/span&gt;&lt;span class="path-component"&gt;🌐 global&lt;/span&gt;&lt;/p&gt;&lt;/p&gt; &lt;p&gt;As you press the &lt;button&gt;🔼&lt;/button&gt;, you navigate upward. When (and only when) you reach the &lt;span class="path-component"&gt;🌐 global&lt;/span&gt; &lt;a href="/hashtags/project-scope.html"&gt;&lt;span class="hashtag" data-hashtag="project-scope"&gt;#project-scope&lt;/span&gt;&lt;/a&gt; the graphs are updated.&lt;/p&gt; &lt;h2 id="understanding-the-graphs"&gt;understanding the graphs&lt;/h2&gt; &lt;p&gt;The graphs represent the progress of the scope at the &lt;span class="path-component"&gt;🌐 global&lt;/span&gt; scope only.&lt;/p&gt; &lt;p&gt;All graphs start grayed out and represent a normalized value (i.e., the largest value of the whole series takes 100% of the height of the bar). Most recent values are on the right.&lt;/p&gt; &lt;p&gt;&lt;em&gt;scope&lt;/em&gt; is how many “tiles” there are in total&lt;/p&gt; &lt;p&gt;&lt;em&gt;delivery&lt;/em&gt; is how many “tiles” are claimed or effectively delivered (claimed correspond to the checkbox on the tile, effective correspond to a majority of the subscope being delivered, the definition is recursive)&lt;/p&gt; &lt;p&gt;&lt;em&gt;progress&lt;/em&gt; has two colors and represents the fraction of “delivered scope” as well as the size of the scope, having both on the same graphs lets you see when the scope grows compared to previous values at a same time as when the delivery grows at fixed scope&lt;/p&gt; &lt;p&gt;&lt;em&gt;coverage&lt;/em&gt; is the percentage of declared features (i.e., verticals) that are fully-delivered&lt;/p&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/scope-explorer.html" rel="alternate"/>
        <summary type="text">
            An application to illustrate how the changing scope of projects affects the delivery, coverage.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/what-is-the-project-scope.html
        </id>
        <title type="text">
            My devs are always refactoring! why? [part-1]
        </title>
        <updated>
            2022-05-21T12:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;div class="note"&gt; &lt;p&gt;This article is the first in a series of articles on refactoring and is focused on discussing what is the “scope” of a project and how the dynamics of the scope affect a project.&lt;/p&gt; &lt;/div&gt; &lt;p&gt;From a non-developer viewpoint, it may be hard to connect with developers who are &lt;strong&gt;always refactoring&lt;/strong&gt;. I wrote this article to fill some gap I observed a number of times with non-technical stakeholders worried that tech teams where “always refactorin’”. Cannot developers refactor once and move to something more useful?&lt;/p&gt; &lt;p&gt;We must discuss some key dynamics of projects before being able to fully-appreciate topics like what is a refactoring. In particular, we need to be clear about the effects how changes in &lt;em&gt;scope of projects&lt;/em&gt; affects the delivery. Thus in this article we’ll have a refresher on what development looks like: a non-linear and discontinuous process.&lt;/p&gt; &lt;h1 id="a-refresh-on-the-development-process"&gt;A refresh on the development process&lt;/h1&gt; &lt;p&gt;The main tangible output of software development is software: an increased amount of lines of code, extra kilobytes of configurations, a flurry of new packages and services. All these deliverables need to be organized, cleared of bugs, key limitations need to be documented. Meanwhile, new business questions are raised, technical questions are raised, and hairbrows are raised too &lt;span class="emoji" data-emoji="thinking"&gt;🤔&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Two key characteristics we can emphasize are the fact that developing software is &lt;em&gt;agglomerative&lt;/em&gt; and &lt;em&gt;non-linear&lt;/em&gt;.&lt;/p&gt; &lt;h2 id="the-development-process-is-agglomerative"&gt;The development process is agglomerative&lt;/h2&gt; &lt;p&gt;We write software to fill a given vaccum, to address a set of problems. The amount of vaccum to fill is the &lt;em&gt;scope&lt;/em&gt; of the software.&lt;/p&gt; &lt;p&gt;Most software features will require a similar set of technical steps (e.g., writing tests, writing a data schema, writing an API provider or consumer, performing some quality-assurance). Thus it makes sense to categorize these technical steps as layers of work. A single developer can work on a single step at a time. Also developers will specialize into some of these layers, forcing the project management to get some ordering between technical steps. For two different features the steps may not have to share the same ordering, however it’s generally the case that there is some bottom-up sequence in a &lt;em&gt;vertical&lt;/em&gt; fashion.&lt;/p&gt; &lt;p&gt;To fill a scope, you need many features, which means that if we collect all the steps for all features, we get a tiling of tasks to fill a given scope.&lt;/p&gt; &lt;p&gt;Graphically you could display that as a set of tiles, each tile corresponding to a technical unit for a given feature.&lt;/p&gt; &lt;p&gt;&lt;img src="/images/project-scope-tiles.png" alt="scope to be delivered is a set of tiles" /&gt;&lt;/p&gt; &lt;p&gt;This model is a simplification of real-world projects, in real-world projects you have more dimensions to consider and you do not need to fill a full-rectangle as some features may not have the same requirements. I believe this model is good for a number of reasons: first, this model serves the purpose of illustration and the model is complex enough to make my point, second the model is simple enough to allow making graphical visualisations, finally we could say that not having the same requirements just means that the requirements exists but takes zero effort to fill.&lt;/p&gt; &lt;p&gt;To fill a scope, you have thus two broad strategies:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;follow the &lt;em&gt;horizontal&lt;/em&gt; axis: focus on some technical layer, assuming that batching everything together is gonna be more efficient. For instance, it is easier to write database schemas when you know all requirements, and is sensible when all requirements are laid out. &lt;/li&gt; &lt;li&gt;follow the &lt;em&gt;vertical&lt;/em&gt; axis: deliver one feature and then move to the next one, assuming that getting some subset of the scope early is a favourable outcome (early revenues, first-mover advantage, reduce pressure from the C-suite) &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;img src="/images/project-scope-delivery-directions.png" alt="scope delivered horizontally or vertically" /&gt;&lt;/p&gt; &lt;p&gt;In modern software practices, it is admitted that the vertical is best as the scope is too hard to discover upfront. We’ll discuss scope changes in the next section though.&lt;/p&gt; &lt;p&gt;Whether one writes code along verticals or horizontals, both strategies eventually accumulate code, configurations, packages, documentations and what not. Thus overall software projects inflate and &lt;em&gt;agglomerate&lt;/em&gt;. As time passes, gaps are filled, &lt;strong&gt;two opposing forces are at play&lt;/strong&gt;:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;the agglomeration of software is more and more complex and &lt;em&gt;friction&lt;/em&gt; drags your developers down &lt;/li&gt; &lt;li&gt;developers get more experienced on the project and find or build ways to &lt;em&gt;accelerate&lt;/em&gt; the delivery &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Which of these forces is winning will determine the fate of your project. In particular, too much friction or not enough time spent on accelerating will lead to losing momentum. If your team loses momentum, your project is doomed to fail, if your team gains momentum… you get to play for longer.&lt;/p&gt; &lt;p&gt;If you are lucky enough to play longer, your project will accumulate features. On top of features, software projects also accumulate bugs, customer tickets, and are shaked by changes in the scope of the problem. In short, the evolution of software projects is erratic, with non-linearities, asperities, and discontinuities.&lt;/p&gt; &lt;h2 id="the-development-process-is-discontinuous-and-not-linear"&gt;The development process is discontinuous and not linear&lt;/h2&gt; &lt;p&gt;Let’s assume your team has been working on a project for some time now. You are roughly half-done. Let’s illustrate it graphically.&lt;/p&gt; &lt;p&gt;&lt;img src="/images/project-scope-delivery-3of5.png" alt="scope delivered a bit more than 2 of 5 verticals" /&gt;&lt;/p&gt; &lt;p&gt;You have shipped (in green) two verticals and one fourth of third vertical as illustrated in the following picture. Remains a &lt;em&gt;backlog&lt;/em&gt; (rose) of three fourth for the third vertical plus two full verticals.&lt;/p&gt; &lt;p&gt;When changes of scope occur, two things can happen:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;the scope &lt;em&gt;deflates&lt;/em&gt;: this is so rare we won’t dicuss it at length here, softwares allows you to isolate dead weight like un-needed features somewhat easily; however if some feature drags you down you should spend some time cleaning it out (in a refactoring hehehe) &lt;/li&gt; &lt;li&gt;the scope &lt;em&gt;inflates&lt;/em&gt;: this is the typical scenario, software often risk something named &lt;em&gt;feature creep&lt;/em&gt; where we want to support so many things that the complexity exploses compared to the team capacity &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Changes in the scope of a project are not without consequences on your project.&lt;/p&gt; &lt;h1 id="effects-of-scope-changes"&gt;Effects of scope changes&lt;/h1&gt; &lt;p&gt;In this essay we are looking at two dimensions of the scope: features and technicals. The scope changes may be blurry. Although scope may change in both dimensions at a time, it is still valid to studying both dimensions independently. Also, individual tasks are not well-defined boxes, when we zoom on a single task, we realize there is more to it as each task can itself be a small project with its own varying scope.&lt;/p&gt; &lt;h2 id="new-features"&gt;New features&lt;/h2&gt; &lt;p&gt;New features are the routine of software projects. As your system collects more data, as business discussions uncover new pain-points and opportunities, new features are needed.&lt;/p&gt; &lt;p&gt;Graphically, we can illustrate the new features has new verticals that we append.&lt;/p&gt; &lt;p&gt;&lt;img src="/images/project-scope-increase-feature.png" alt="scope changes adding a new column of feature" /&gt;&lt;/p&gt; &lt;p&gt;I used a slightly darker red to distinguish the verticals corresponding to the new features. In this situation, the main problem that arises is whether to prioritize iterations on the new features or not. If the prioritization is very high, you may even pause the current vertical where it is.&lt;/p&gt; &lt;p&gt;One key thing to remark is when scope grows horizontally, the software is still deemed perfectly adequate. Thus, whatever value delivered is not at risk and life is good as the future will be a continuation of what worked. Vertical changes are bit more annoying.&lt;/p&gt; &lt;h2 id="new-technical-requirements"&gt;New technical requirements&lt;/h2&gt; &lt;p&gt;You know where we’re aiming at. Technical requirements changes are disruptive. Such changes can either have endogenous causes (e.g., you have a reached a point where there are too many defects and you need to increase testing) or exogeneous causes (e.g., regulatory changes like the &lt;a href="https://gdpr-info.eu/"&gt;GDPR&lt;/a&gt;).&lt;/p&gt; &lt;p&gt;&lt;img src="/images/project-scope-increase-technical.png" alt="scope changes adding a new row of technicals" /&gt;&lt;/p&gt; &lt;p&gt;As the technical landscape changes, we need two colors to disinguish what happens to software that exists and is shipped (crimson red) and future software that you will write later (middle-tone red).&lt;/p&gt; &lt;p&gt;The later a vertical change of scope occurs, the larger the impact on your backlog. A late vertical scope change is like a late realization that you were partying on borrowed money. I also like the image of realizing that you were playing in easy mode after subscribing to a video-game tournament: you’re set for some reckoning.&lt;/p&gt; &lt;p&gt;For future verticals, you have one simple decision to make: cut or keep in scope. Cutting an already-started vertical will incur a sunk-cost. Thus, beware the &lt;a href="https://en.wikipedia.org/wiki/Sunk_cost"&gt;sunk-cost fallacy&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;For existing verticals, I picked crimson red for a good reason: new technical requirements are difficult to retrofit. Here you have three broad choices:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;(a) dropping already-shipped verticals &lt;/li&gt; &lt;li&gt;(b) fill the gap for previous verticals &lt;/li&gt; &lt;li&gt;(c) ignoring the new requirements for previous verticals. You can make a different decision for each vertical. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Dropping the whole vertical (a) may not be just a sunk-cost but a visible cost as some customer already relies on the corresponding feature.&lt;/p&gt; &lt;p&gt;Filling the gap for a vertical (b) can be hard to sell to other stakeholders as you are not solving new problems. You also need to prioritize these new tasks and consider delaying the ongoing vertical.&lt;/p&gt; &lt;p&gt;Ignoring new requirements (c) may be sensible, but as scope will continue to grow vertically you may just be post-poning the choice (with an increasingly gap to fill to put in balance with dropping an even older vertical).&lt;/p&gt; &lt;p&gt;Summarizing, vertical scope changes are dangerous for projects as they force difficult choices and have compounding effects.&lt;/p&gt; &lt;h1 id="the-scope-is-a-fractal"&gt;The scope is a fractal&lt;/h1&gt; &lt;p&gt;Another problem of software projects is how fractally complex they end up. Individual tasks often have no good “definition of done”. A whole vertical may have some, but individual tasks are left to implementers. Which means developer will likely need to experiment around.&lt;/p&gt; &lt;p&gt;Overall, individual tasks themselves are small projects with a scope. Oftentimes we realize that there is some an abundant amount of details and extra technical bits and internal features to implement. Anticipating whether a task has enough scope to be split upfront is a difficult betting game.&lt;/p&gt; &lt;p&gt;When picking a single task and zoom-ing in, we often can formulate the scope of the task. Within this contour, we may lay down verticals and horizontals like we did for our project earlier. For instance, if the whole task is to add some visual representation of some statistics for a customer, the sub-tasks may be about defining edge cases, verifying against historical data, deciding to present a single statistics or an evolution in time etc. Overall a seemingly simple feature in itself can have a rich scope. If we keep zooming, the code organization, making sure that business rules are decoupled from glue code and so-on and so forth also are mini-scopes within a task substasks.&lt;/p&gt; &lt;p&gt;Graphically we can give a feeling of what it means by zooming on a task as follows:&lt;/p&gt; &lt;p&gt;&lt;img src="/images/project-scope-fractal.png" alt="scope actually are fractals" /&gt;&lt;/p&gt; &lt;p&gt;A result of this fractal complexity is that there is no definite answer to say a given task has ended. A hand-wavy rule may be to say a task is mark as done when “enough” of the scope of the task is actually covered. If we try to put numbers, in our case we could define that a task is green when a majority of the subtasks are green. In our example a tile has nine sub-tasks. Which means that the task is done when at most four tasks are “skipped” (yellow) – which we distinguish from “not encountered yet” (rose).&lt;/p&gt; &lt;p&gt;Such a rule is reasonable, and individual tasks may be left in various patterns. Some tasks will have led to code that is complete in many aspects. Some others will have a few edge cases unhandled. Some patchy tasks will have disorganised code but it does the job. Often, the documentation and tests are lacking, and so on and so forth.&lt;/p&gt; &lt;p&gt;Overall, our project is a mosaic that can be scrutinized at a variety of resolutions. Non-developers stakeholders will look at the big-picture&lt;span class="emoji" data-emoji="tm"&gt;™️&lt;/span&gt; of the project and with coarse granularity. Looking at a low-resolution you may get the impression that tasks are fully-done and indeed the project delivers features. However if you had the possibility to &lt;strong&gt;increase the resolution&lt;/strong&gt; of the whole project, you would see the delicate complexity of feature deliveries. We can illustrate this with our example by replacing each task by a set of smaller tasks. We replace every box by nine smaller boxes and we keep the rule that “to make the tile green, we need at most four yellow”.&lt;/p&gt; &lt;p&gt;&lt;img src="/images/project-scope-fractal-tesselation.png" alt="scope actually are fractals" /&gt;&lt;/p&gt; &lt;p&gt;This picture shows that looking closely we may realize that our shiny project where everything is on track actually has a number of holes like a good &lt;a href="https://en.wikipedia.org/wiki/Emmental_cheese"&gt;Emmental cheese&lt;/a&gt;. Projects with partially-delivered tasks is the normal life of software, thus it is not a immediate cause of concern (and Swiss cheese is delicious). However it is important to understand the dynamics of the system.&lt;/p&gt; &lt;p&gt;Developers have to live in the reality of high-resolution projects, and the cavities left behind to progress on the project may cave-in as the time passes. Indeed, remember that each task in the project has a scope that may inflate (often) or deflate (rarely). If it occurs that an already-shipped feature has a vertical or horizontal scope change, then we also must make a choice between dropping a task or filling-it at 50% again. The extra difficulty is that if you drop or postpone for too long, a task that is green now will become red. Let’s illustrate again on our high-resolution picture: assume that scope changes affect two already-shipped verticals at the second horizontal-layer.&lt;/p&gt; &lt;p&gt;&lt;img src="/images/project-scope-fractal-cave-in.png" alt="scope actually are fractals" /&gt;&lt;/p&gt; &lt;p&gt;Here both affected tasks used to be filled six out of nine sub-tasks (67%) and are now filled six out of sixteen (38%)! Such a situation is dangerous. Figuratively, two of the already-shipped verticals are deemed unsatisfactory and your project risks a figurative cave-in.&lt;/p&gt; &lt;h1 id="summary"&gt;Summary&lt;/h1&gt; &lt;p&gt;We’ve studied a simple model of software project which is split into tasks to fill a given scope. Project scopes can be described along a number of axes, we focus in particular on the feature-scope (verticals) and on the technical-scope (horizontals). Adding a new vertical has low impact besides prioritization. Adding a new horizontal forces to cut scope or heavily de-prioritization of ongoing features.&lt;/p&gt; &lt;p&gt;Scope is discovered as the project progresses: the scope inflates. Beginning of projects often have a steep inflationnary phase and then the scope accrues more requirements at a lower rate as the project matures. Occasionally, the scope deflates. As delivery of tasks progresses, features get shipped and the coverage of the scope effectively grows in increments. When the scope changes, you risk a cave-in effect where already-shipped features are no-longer passing the bar can no longer be considered as filling the user needs.&lt;/p&gt; &lt;p&gt;All of this can be summarized in the following picture.&lt;/p&gt; &lt;p&gt;&lt;img src="/images/project-scope-timeline.png" alt="scope can suffer from cave-in" /&gt;&lt;/p&gt; &lt;p&gt;In the next article, which we can expect in a few weeks (meanwhile you can see the &lt;a href="/always-refactoring.html"&gt;progress in draft&lt;/a&gt;), we’ll discuss what refactorings are and how they help avoid cave-ins.&lt;/p&gt; &lt;div class="note"&gt; &lt;p&gt;This article also now has an accompanying &lt;code&gt;micro-application&lt;/code&gt; at &lt;a href="/scope-explorer.html"&gt;Scope Explorer&lt;/a&gt;.&lt;/p&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/what-is-the-project-scope.html" rel="alternate"/>
        <summary type="text">
            In past experiences I ran into a number of product-owner and staekholders puzzled by how often developers in their team express a need to "refactor". Cannot they do it once for the quarter? This prompted me to write some notes and eventually an article. This article will be followed by a second part focused on the topic of refactoring. However before jumping directly into hard topics, we must discuss some key dynamics of a #project, in particular regarding the scope of projects (#project-scope).
        </summary>
    </entry>
</feed>
