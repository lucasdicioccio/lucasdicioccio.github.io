<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title type="text">
        Lucas DiCioccio's blog
    </title>
    <id>
        https://dicioccio.fr/atom.xml
    </id>
    <updated>
        2022-03-27T01:00:00Z
    </updated>
    <entry>
        <id>
            https://dicioccio.fr/on-dualities.html
        </id>
        <title type="text">
            On Dualities
        </title>
        <updated>
            2022-03-27T01:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;Functional programming has taught me to &lt;em&gt;simplify&lt;/em&gt; superfluous concepts: identify what are primitive concepts and what are constructions on top these primitives. The constructions themselves need not be multiplied out of proportion: it is better to stick to few ways of combining entities and concepts. Overall, I think I found some internal peace with programming languages when I could recognize enough of such primitives and how to make use of them in various programming styles. Among the techniques that I use to recognize when two concepts complement each other is to emphasize when two things are in a &lt;em&gt;duality&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;A situation of &lt;a href="/hashtags/duality.html"&gt;&lt;span class="hashtag" data-hashtag="duality"&gt;#duality&lt;/span&gt;&lt;/a&gt; is when two concepts cohabit well while appearing in opposition. In a sense, two dual concepts connect and perform some symmetrical dance. I would say that finding that two things are dual is like realizing that it’s not the Earth that rotates around the Moon, nor the Moon rotates around Earth, but in fact both celestial bodies dance and rotate around a same point &lt;a href="https://en.wikipedia.org/wiki/Barycenter#/media/File:Orbit3.gif"&gt;(the barycenter)&lt;/a&gt;. Discovering such rules brings clarity and simplicity to our understanding of a problem. Since a key part of our job in software engineering is to tame complexity, recognizing such simplifications are useful.&lt;/p&gt; &lt;p&gt;The existence of the barycenter of the Earth-Moon system is a consequence of the mathematical formulas we use to model the physical world. It is worth training our sense starting from simple (even simplistic) equations. For instance, let’s take the simplest form of duality: the equality of two values. The two sides of an equality &lt;code&gt;a = b&lt;/code&gt; are in a dual relationship: what happens to &lt;code&gt;a&lt;/code&gt; requires a commensurate compensation on &lt;code&gt;b&lt;/code&gt;. In the real world you rarely encounter some simple rule saying &lt;code&gt;a = b&lt;/code&gt;, more often terms like &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; actually are contraptions. For instance &lt;code&gt;b&lt;/code&gt; is the result of something involving &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; and other values. Whatever the particular instance you find, what happens to &lt;code&gt;a&lt;/code&gt; likely has implications on these &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; and other values. As systems grow in complexity, such equalities may blossom unexpectedly, and if the formula for the equality is too obscured to be spelled-out, unfathomable dynamics will happen.&lt;/p&gt; &lt;p&gt;Although software is not cosmology, and even if no Great Watchmaker seems needed to enforce laws of equalities (we trust CPU founders to do so), dualities exist in software. Software can be modeled with mathematical concepts from &lt;em&gt;discrete logic&lt;/em&gt; rather than calculus and differential equations. If I had to choose, I would say that the root of all dualities in software are &lt;a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws"&gt;De Morgan’s laws&lt;/a&gt; (in particular, see the section about extensions to predicate and modal logic). Let’s say that a “negated” value is a &lt;em&gt;consumer&lt;/em&gt; whereas a “positive” value is a &lt;em&gt;producer&lt;/em&gt;. Also, let’s say that a &lt;code&gt;OR&lt;/code&gt; encodes alternatives whereas a &lt;code&gt;AND&lt;/code&gt; encodes co-occurrences. Applying De Morgan’s law &lt;code&gt;NOT (x OR y) = (NOT x) AND (NOT y)&lt;/code&gt; could be read as &lt;strong&gt;to consume either X or Y we need the co-occurrence of a consumer of X and a consumer of Y&lt;/strong&gt;. We will leave such a bureaucratic formalism out of this article but there is not much more to it: a simple logical rule. Instead, I’ll spend time elaborating at a higher-level. In particular I would like to stress how important the producer/consumer duality is in software and how this duality is interlocked with yet another important duality: the alternative/co-occurrence duality.&lt;/p&gt; &lt;h2 id="the-producerconsumer-duality"&gt;The producer/consumer duality&lt;/h2&gt; &lt;p&gt;We do not write code in a vacuum. Even if we write code for no purpose, the programming language has logical rules, running a program happens on a physical machine subject to physical and logical rules of the CPU or those of the virtual machine. Even if we only imagine some code without writing it (e.g., while sketching out an API in our mind), our imaginary simulation of the running code will entail some logical rules. In any case some dualities are likely to arise. In particular, a useful program either consumes some data (e.g., a configuration file), or produces some data (e.g., a PNG image). More often, a programs both consume and produce some data but &lt;strong&gt;the data-consumption-side and data-production-side of a program operate on distinct sets&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;I specifically want to avoid conflating inputs and outputs with produced and consumed data. Although I believe that input and output are in a consumer/producer duality, I also want to encompass side-effects in this duality. A trick in functional programming is to pretend that the external world is a hidden input and hidden output of a pure function. The problem I find with this external-world object is that the external world is both consumed and produced, apparently giving a symmetrical role to the external-world object (for the better or the worst, our programming practice focuses almost only on the program and takes the executing environment as an unprogrammable thing with its own will). I prefer to conceptualize side-effects as entities merely produced by programs. Side-effects then are consumed by their executing environment. In this viewpoint, the program and the executing environment are the two partners performing a tango dance (or the two opponents in a tennis-game if you prefer sport over artistic metaphors). This viewpoint brings the question: what is the dual to a side-effect? It is something that an executing environment provides and that a program consumes (and hence it may destroy it), and I claim that would be pre-conditions. Summarizing, in this viewpoint &lt;strong&gt;a program consumes pre-conditions and produces side-effects&lt;/strong&gt; and could be illustrated as follows:&lt;/p&gt; &lt;p&gt;&lt;img src="gen/images/producer-consumer.dot.png" alt="producer-consumer duality" /&gt;&lt;/p&gt; &lt;p&gt;I spoke about “programs” without precisely describing the kind of program I wanted to describe. Indeed, I believe that such a duality exists at different scales of programming. When zooming in at the individual module, object, or function, we can easily outline pieces of code that produce and consume objects or data-structures. I believe the same rule exists when zooming out a the service level. We just lack proper nouns to disambiguate whether a service mainly produces or consumes other services (indeed, much like the external-world object trick in FP: we conflate the co-occurrence of two distinct phenomenon because when focusing on a sole viewpoint both ends meet). I do not have excellent suggestions to make, but if I were to pick some words today I would say that, a service is being a &lt;strong&gt;producer of functionalities that are consumed as capabilities&lt;/strong&gt; by external-services.&lt;/p&gt; &lt;p&gt;What are the consequences of the dual roles of producers and consumers? Well, there is a point that when you need to modify a producer you need consumers to adapt in a dual way. It’s common to speak about API &lt;em&gt;contracts&lt;/em&gt; to provide a way to match consumers with producers. However I find that speaking at length about the value of contracts falls short. Contracts are shallow, they merely are the tips of the consumers and producers code. We actually can derive much more information than “OK the consumers and producers must agree on a contract”. In particular, we need to be precise about the consequences of changing a producer linked to a consumer. To answer such questions, we need to take a close look at how the producers/consumers duality interacts with the alternative/co-occurrences duality.&lt;/p&gt; &lt;h2 id="the-alternativeco-occurrences-duality"&gt;The alternative/co-occurrences duality&lt;/h2&gt; &lt;p&gt;Alternatives (&lt;a href="/hashtags/alternatives.html"&gt;&lt;span class="hashtag" data-hashtag="alternatives"&gt;#alternatives&lt;/span&gt;&lt;/a&gt;) and co-occurrences are well captured with what are called &lt;em&gt;sum-types&lt;/em&gt; and &lt;em&gt;product-types&lt;/em&gt; in typed-programming languages. Product-types are pervasive in programming, they correspond to your day-to-day data structure that is made of a set of fields. For instance, a user could be represented in some informal pseudo-code &lt;code&gt;type User = { Name x Email x FavoriteColor }&lt;/code&gt;. This notation means that a when you are presented a &lt;code&gt;User&lt;/code&gt; object, you also have the co-occurrence of three separate entities: &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Email&lt;/code&gt;, and &lt;code&gt;FavoriteColor&lt;/code&gt;, and you can splice them out at will and independently.&lt;/p&gt; &lt;p&gt;Sum-types, for no clear reason, have less support in the most-established programming languages. To be precise, user-declared sum-types are not really available. A boolean is the simplest example of sum-types, it presents two alternatives &lt;code&gt;type Bool = { False | True }&lt;/code&gt;, that is when you have a &lt;code&gt;Bool&lt;/code&gt;, you may have either a &lt;code&gt;False&lt;/code&gt; or a &lt;code&gt;True&lt;/code&gt; but not both at a same time. You could have a type with three alternatives (e.g., to encode a subscription plan with three tiers &lt;code&gt;type Plan = { Free, Pro, Enterprise }&lt;/code&gt;).&lt;/p&gt; &lt;p&gt;With knowledge of product types and sum types, a compiler or a linter can tell you that you made a mistake (e.g., you forgot to give an &lt;code&gt;Email&lt;/code&gt; to build a &lt;code&gt;User&lt;/code&gt;, or you forgot to provide a template for the &lt;code&gt;Pro&lt;/code&gt; subscription email). Indeed, automated tools have enough information about all possible alternative and all required fields that must co-occur. Since we are discussing dualities and we have discussed about the producer/consumer duality. You may already sense where this post is going: we need to explore what happens to the consumer-side of a produced sum-type or of a produced product type.&lt;/p&gt; &lt;p&gt;Given that a product type is a co-occurrence of independent facts, when you produce a product type, the consumer &lt;em&gt;CAN&lt;/em&gt; have multiple independent data handlers and all can execute. Whereas when you produce a sum type, the consumer &lt;em&gt;MUST&lt;/em&gt; have independent data handlers and only one executes.&lt;/p&gt; &lt;p&gt;Finally, let’s note that a data handlers can also be stored in data types (e.g., with lambdas if the language supports it, or with factory-patterns otherwise). Such data types – containing handlers – themselves can be product and sum types. Putting everything together, we note that &lt;strong&gt;producers of alternatives require a the co-occurrence of consumers&lt;/strong&gt; whereas &lt;strong&gt;producers of co-occurrences require alternatives of consumers&lt;/strong&gt;. That’s it, our two dualities are interlocked.&lt;/p&gt; &lt;p&gt;We can illustrate this duality with pictures by displaying a producer and a consumer being matched together.&lt;/p&gt; &lt;p&gt;On the one hand, we shall illustrate a producer of product-type. Visually we try to convey the code that is written with the yellow boxes with &lt;code&gt;...&lt;/code&gt; ellipsis text in them.&lt;/p&gt; &lt;p&gt;&lt;img src="images/product-producer.png" alt="product-producer" /&gt;&lt;/p&gt; &lt;p&gt;The Producer returns a co-occurrence of three pieces of information (the product type &lt;code&gt;{A,B,C}&lt;/code&gt;). Therefore, the Producer must have code to introduce or carry-over these three independent piece of information. Given that the Producer’s output contains these three pieces of information, the Consumer is free to pick any alternative combining &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, or &lt;code&gt;C&lt;/code&gt;. When Producer and Consumer are &lt;em&gt;decoupled&lt;/em&gt;, the Consumer may not even have code to consume &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;C&lt;/code&gt; and only cares about &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;On the other hand, we also need to illustrate the dual situation where the Producer provides a sum-type.&lt;/p&gt; &lt;p&gt;&lt;img src="images/product-consumer.png" alt="product-consumer" /&gt;&lt;/p&gt; &lt;p&gt;Given that the Producer provides an alternative (again, it may be that there is code for only one possible case), if the Consumer is decoupled from the Producer, then the Consumer must be ready to handle every case.&lt;/p&gt; &lt;p&gt;Much like when we first introduced the producer/consumer duality, we have been pretty indiscriminate about the exact family of producer and consumers.&lt;/p&gt; &lt;p&gt;Indeed, &lt;strong&gt;the alternative/co-occurence duality stands for all scales&lt;/strong&gt;. The only requirement for the duality to exhibit consequences is that a consumer and producer establish some communication (i.e., when we match a consumer with a producer). For instance at the library-scale, the producer could be a library function you call. Your own code would be the consumer of this function. When the library function returns a sum-type (for instance, either an error or a successful result) you should forcefully verify that you have a piece of code to handle either branches. At a service-scale, a web-API with multiple routes or a gRPC service with multiple methods can be framed as a collection of endpoints (i.e., a co-occurrence of handlers) whereas the client-side has the choice to pick any endpoint (i.e., and alternative of endpoints). In summary, the party that can force the dual party to behave in a certain way is the party deciding on the alternative picked in the sum-type side of the producer/consumer interface.&lt;/p&gt; &lt;p&gt;It is worth stressing that the alternative/co-occurrence duality shows up irrespective of the particular role (consumer or producer) of the API-client versus the web-API. Indeed, whether the client of the API is seen as a consumer (e.g., fetching data) or a producer (e.g., pushing data) does not change the fact that at the interface level, the client holds the choice of picking the endpoint. This distinction is important to recognize the proper interface between a producer and a consumer. In real-world situations, software components take both roles in alternation: a web-API may be seen as a producer of endpoints, but to implement an handler for such endpoint, the web-API is a consumer of other services or a consumer of libraries, and so-on and so-forth. Therefore, recognizing the particular interface may be difficult. Indeed, when we say a web-API client is a consumer, the &lt;em&gt;payload&lt;/em&gt; that the web-API produces could either be a product-type (i.e., the servers returns a co-occurrence of data and the client is then free to act starting from this data), but the result could also be a sum-type (i.e., the server returns a particular alternative to force a behaviour on the client – for instance an unauthorized response would force a client to initialize an authentication challenge). When analyzing real-world systems, we realize that communications between systems is a fractal of consumers and producers matched with each others and communicating of product-types and sum-types. Thus, when conceptualizing a system, we need to find the right levels where systems interface with each others and we must study a few nested layers of messages they interact with.&lt;/p&gt; &lt;p&gt;A key reason for studying more than a single level of interface is that it is possible to mechanically flatten nested layers of alternatives/co-occurrences. Such a flattening is useful both as a concept but also as a refactoring tool. The flattening law comes straight out of arithmetic, and is “just” the distributivity property of products over sums.&lt;/p&gt; &lt;p&gt;Formally the distributivity is written as &lt;code&gt;a * (b + c) = (a * b) + (a * c) &lt;/code&gt; In plain English, the two following statements are equivalent:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;you certainly get an &lt;code&gt;a&lt;/code&gt; and alternatively get a &lt;code&gt;b&lt;/code&gt; and a &lt;code&gt;c&lt;/code&gt; &lt;/li&gt; &lt;li&gt;you alternatively get an &lt;code&gt;a&lt;/code&gt; paired with a &lt;code&gt;b&lt;/code&gt; with certainty or &lt;code&gt;a&lt;/code&gt; paired with a &lt;code&gt;c&lt;/code&gt; with certainty &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Much like arithmetic formula we can theorize systems at various scales with similar formulas, and then factorize or develop these formulas. We will expand on this key property in the next section, but let’s first summarize what we’ve seen.&lt;/p&gt; &lt;h3 id="summary"&gt;Summary&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;in a general sense, consumers and producers are in a duality relationship &lt;/li&gt; &lt;li&gt;alternatives (sum-types) and co-occurrences (product-types) also are dual of each other &lt;/li&gt; &lt;li&gt;both dualities interact following some interaction law &lt;ul&gt; &lt;li&gt;producers of sum-types match product-types consumers &lt;/li&gt; &lt;li&gt;producers of product-types match sum-types consumers &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;these properties are invariant of the scale (i.e., it holds at the function, library, service level) &lt;/li&gt; &lt;li&gt;communicating systems involve layered consumer/producers, producers/consumers may alternate from one layer to another &lt;/li&gt; &lt;li&gt;there is a distributivity law to factorize or develop layers of {sum,products}-of-{sum,products}. &lt;/li&gt; &lt;/ul&gt; &lt;h2 id="consequences"&gt;Consequences&lt;/h2&gt; &lt;p&gt;The important consequence of the interactions of product/sum with consumer/producer is that you do not need to be a compiler to foresee whether two pieces of software “connect” well or not. You can foresee errors, plan refactoring, and prepare architecture documents for splitting a monolith into services (or when agglomerating too-thin services into larger ones).&lt;/p&gt; &lt;h3 id="flattening-an-http-response"&gt;flattening an HTTP response&lt;/h3&gt; &lt;p&gt;Say that you are calling a library function that returns an &lt;code&gt;a * (b+c)&lt;/code&gt;, for instance, an HTTP response could be represented as &lt;code&gt;headers ~= a&lt;/code&gt; and &lt;code&gt;body ~= b if the response is valid, c if it's an error message&lt;/code&gt;. Since &lt;code&gt;a * (b + c)&lt;/code&gt; is equivalent to &lt;code&gt;(a * b) + (a * c)&lt;/code&gt;. You can decide to write a handler for “HTTP headers with a body” return value separately from a handler for “HTTP headers with an error”, and collate these two in a single handler for “HTTP headers with either a body or an error”.&lt;/p&gt; &lt;p&gt;If we go further and it happens that &lt;code&gt;b = c + d&lt;/code&gt; (e.g., &lt;code&gt;d&lt;/code&gt; is a decoded JSON object and &lt;code&gt;c&lt;/code&gt; is an error message), we can write down the consequences:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; a * (b + c) = (a * b) + (a * c) [distributivity] = (a * (c + d)) + (a * c) [b=c+d] = (a * c) + (a * d) + (a * c) [distributivity] = (a * c) + (a * c) + (a * d) [commutativity*] &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This series of equation means that the HTTP-response handler in our example actually is made of two possibly-independent error-handler pieces of code &lt;code&gt;(a * c)&lt;/code&gt; and a success-handler taking a decoded JSON value &lt;code&gt;(a * d)&lt;/code&gt;. We have not discussed about commutativity here but in general depending on what your operations entails, they may not commute, for the case of decoding JSON values we could safely assume that decoding commutes as one would expect decoding to be deterministic and require no exogenous side-effects.&lt;/p&gt; &lt;p&gt;That’s a lot of information about the code when only looking at a type-description!&lt;/p&gt; &lt;h3 id="refactoring-api-services-with-multiple-endpoints"&gt;refactoring API services with multiple endpoints&lt;/h3&gt; &lt;p&gt;We’ve said earlier than a web-API is a product of handlers. Thus, to say that an API implements &lt;code&gt;a * (b + c)&lt;/code&gt; at a conceptual level means the web-API has two routes (the &lt;code&gt;*&lt;/code&gt; at the first layer) and the payload of the second type is known to be a sum-type (&lt;code&gt;b+c&lt;/code&gt;). If we apply distributivity we get &lt;code&gt;(a * b) + (a* c)&lt;/code&gt; , that is a single endpoint (no &lt;code&gt;*&lt;/code&gt; operand at the first layer) with a payload that is a sum of products.&lt;/p&gt; &lt;p&gt;We can illustrate this operation with the following pseudo-API description of two web-APIs.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;POST /route-one {&amp;quot;payload-a&amp;quot;:&amp;quot;a&amp;quot;} &amp;lt;=&amp;gt; POST /route-combined?branch=case-b {&amp;quot;payload-a&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;payload-b&amp;quot;: &amp;quot;b&amp;quot;} POST /route-two?branch=case-b {&amp;quot;payload-b&amp;quot;: &amp;quot;b&amp;quot;} &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Both situations allow to match similar clients and servers exchanging similar information. However we can see that on the left-side, the client of the API is free to call &lt;code&gt;route-two&lt;/code&gt; even if it does not have a &lt;code&gt;payload-a&lt;/code&gt; to offer, whereas in the right situation, the client of the API must have a &lt;code&gt;payload-a&lt;/code&gt; to call &lt;code&gt;route-combined&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Note that when we say the representations are equivalent, we mean that either &lt;code&gt;a * (b+c)&lt;/code&gt; or &lt;code&gt;(a*b) + (a*c)&lt;/code&gt; are entirely produced and consumed. Commutativity is important in the first case.&lt;/p&gt; &lt;h4 id="some-api-refactoring-where-this-rule-fail"&gt;some API refactoring where this rule fail&lt;/h4&gt; &lt;p&gt;Let’s see an a negative example where you would believe that you can introduce the same transformation. Say you have to pick between using one endpoint or a series of endpoints. Such a situation arises when &lt;strong&gt;in both case you need to encode some branching logic&lt;/strong&gt;: in the URL path or in the payload.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;POST /foo/bar POST /foo {&amp;quot;hello&amp;quot;: &amp;quot;world&amp;quot;} {&amp;quot;hello&amp;quot;: &amp;quot;world&amp;quot;, &amp;quot;branch&amp;quot;: &amp;quot;bar&amp;quot;} &amp;lt;=&amp;gt; POST /foo/baz POST /foo {&amp;quot;hello&amp;quot;: &amp;quot;world&amp;quot;} {&amp;quot;hello&amp;quot;: &amp;quot;world&amp;quot;, &amp;quot;branch&amp;quot;: &amp;quot;baz&amp;quot;} &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The key issue here is that we have product types at the API layer, i.e., our only way to factorize this is to use what is known as … you guess it, an exponential type.&lt;/p&gt; &lt;p&gt;&lt;code&gt;a x a x .... [k times] = a ^ k&lt;/code&gt;&lt;/p&gt; &lt;p&gt;And they correspond to functions with an argument. In short, if you had five handlers, you can factorize that into one handler having an extra argument taking five possible values. There is no duality involved here, but it is interesting to note that the product/sum extends to more arithmetic.&lt;/p&gt; &lt;p&gt;Exponentials &lt;code&gt;a ^ k&lt;/code&gt; varies from products &lt;code&gt;a * k&lt;/code&gt; because if we keep this sense of fully-consuming either inputs, you would need to consume multiple &lt;code&gt;a&lt;/code&gt; versus consuming a single &lt;code&gt;a&lt;/code&gt;. Indeed, a client that has the alternative to pick many different A with various handlers, to get the same behaviour we still need the possibility to handle &lt;code&gt;a&lt;/code&gt; differently based on the &lt;code&gt;branch&lt;/code&gt; taken.&lt;/p&gt; &lt;h3 id="monoliths-micro-services-and-it-system-architectures-roll-outs"&gt;monoliths, micro-services, and IT-system architectures roll-outs&lt;/h3&gt; &lt;p&gt;Most companies with a large amount of software need to evolve their code base. Thus, I recommend to recognize three key aspects:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;what is constant about the system? &lt;/li&gt; &lt;li&gt;what is the product/sum nature of the changed system? &lt;/li&gt; &lt;li&gt;are you flattening/nesting the changed system? &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Having these information at hand is like accumulating equations to solve an system of equations until the system is well defined.&lt;/p&gt; &lt;p&gt;For instance, the exercise of splitting a monolith is like going from a large product into some more nested products &lt;code&gt;a * b * c * d&lt;/code&gt; to something more nested &lt;code&gt;(a * b) * (c) * (d)&lt;/code&gt;. The overall number of services is constant and we still have a gigantic product type of endpoints. The latter seems more complicated, so why do we dread monoliths? Well, imagine that now you want to support a new key customer with a new business use-case &lt;code&gt;c = c1 + c2&lt;/code&gt;. Then we can see what happens to monoliths if we want to isolate customers for a reason or another (i.e., if we expose an alternative of sets of simple endpoints rather than exposing a single set of more-complicated endpoints). We distribute the &lt;code&gt;+&lt;/code&gt; and get the following: &lt;code&gt;a * b * (c1 + c2) * d = (a * b * c1 * d) + (a * b * c2 * d)&lt;/code&gt; you need to fork the whole &lt;code&gt;a * b * _ * d&lt;/code&gt; part of the monolith to please the new business. Whereas in the already-factored out situation, we get &lt;code&gt;(a*b) * (c1) * (d) + (a*b) * (c2) * (d)&lt;/code&gt;, that is some set of endpoints are stable and can be re-used more directly.&lt;/p&gt; &lt;h1 id="another-duality"&gt;Another duality&lt;/h1&gt; &lt;p&gt;Before concluding, I would like to pinpoint some related duality that also stems from the producer/consumer viewpoint.&lt;/p&gt; &lt;h2 id="null-and-default-values-are-duals"&gt;null and default-values are duals&lt;/h2&gt; &lt;p&gt;Much has been written about &lt;em&gt;null&lt;/em&gt; being Tony Hoare’s &lt;a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/"&gt;billion-dollar mistake&lt;/a&gt;. Well, my sincere belief if we should regard implicit &lt;em&gt;defaults&lt;/em&gt; (default values) with the same scrutiny. In many languages, &lt;em&gt;null&lt;/em&gt; actually is “THE default value”, but I want to stress that &lt;em&gt;defaults&lt;/em&gt; in itself is a problem.&lt;/p&gt; &lt;p&gt;Why do I believe that &lt;em&gt;null&lt;/em&gt; and &lt;em&gt;defaults&lt;/em&gt; are dual? Well, let’s look at some usages:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;em&gt;null&lt;/em&gt; is here to &lt;em&gt;provide&lt;/em&gt; no-values to some consumer that will &lt;em&gt;consume&lt;/em&gt; one &lt;/li&gt; &lt;li&gt;&lt;code&gt;default&lt;/code&gt; is here to &lt;em&gt;consume&lt;/em&gt; no-value from some producer that should have &lt;em&gt;produced&lt;/em&gt; one &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If we connect to my viewpoint that programs and environment are in a dual dance, we can see that &lt;em&gt;null&lt;/em&gt; affects the program whereas &lt;em&gt;defaults&lt;/em&gt; affect the environment. Indeed, &lt;strong&gt;null shortcuts the program downstream&lt;/strong&gt;, whereas &lt;strong&gt;defaults shortcut the environment upstream&lt;/strong&gt;. Taking the alternate viewpoint of side-effects and pre-conditions, we could say that &lt;strong&gt;null prevents side-effects&lt;/strong&gt; by crashing the system, whereas &lt;strong&gt;defaults prevents wanted pre-conditions&lt;/strong&gt; by not operating on the environment.&lt;/p&gt; &lt;p&gt;An example that makes such a distinction clear is a situation where a networked client needs to perform an authentication challenge. If the authentication challenge occurs and produces a null token, the client will crash. If no authentication-challenge occurs and a default token-value is produced, the client will continue and may leak data or have a failure at a much-later “distance” from where the bug actually is rooted.&lt;/p&gt; &lt;p&gt;I don’t know what is the dual of a billion-dollar mistake, but I hope you will join me in saying that default-values defeat a large number of automated analyses one could hope to make about the correctness of a program.&lt;/p&gt; &lt;h1 id="closing-remarks"&gt;Closing remarks&lt;/h1&gt; &lt;p&gt;This article took me a while to write because the topic I scratched is much deeper than I anticipated. I think that most of the discussion could be re-written entirely as a more formal exercise in mapping the discussions about product/sum-types and API endpoints using &lt;a href="https://en.wikipedia.org/wiki/Linear_logic"&gt;linear logic&lt;/a&gt; rather than my sketchy arithmetic. I definitely care enough about this topic to ask readers to point me works they find (a) introductory enough and (b) related to this discussion.&lt;/p&gt; &lt;p&gt;I reserve myself the right to write about this topic a few more times even if such new articles would have a lot of redundant information. Indeed, I took off bits about negative types, bits about category-theory, and bits about covariance/contra-variance. Overall, there is much to say and we probably longer illustrative examples as well. It feels like there is much, but at a same time these concepts are only just a few.&lt;/p&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/on-dualities.html" rel="alternate"/>
        <summary type="text">
            Duality is technical jargon for "complementary". Programmers often overlook the role dualities in programming and hence fail to recognize them, even if they are hiding in plain sight. In this article we focus on two important pairs of dual concepts: producers and consumers, sum types and product types. I also spend some time ranting about default values being as bad as null values.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/snake-cube.html
        </id>
        <title type="text">
            Solving the Snake Cube puzzle
        </title>
        <updated>
            2022-01-01T12:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;In 2021, Santa brought me this puzzle: &lt;img src="images/snake-cube-unfolded.jpeg" alt="an unfolded Snake-Cube" /&gt; This is sometimes named the “Snake-Cube” because the device looks like a snake &lt;span class="emoji" data-emoji="snake"&gt;🐍&lt;/span&gt; when unfolded. The goal of this game is to fold it into a cube &lt;span class="emoji" data-emoji="package"&gt;📦&lt;/span&gt; like this. &lt;img src="images/snake-cube-folded.jpeg" alt="a folded snake cube" /&gt; The device is built with cubes that are drilled across some faces so that a strap runs trough cubes like beads. Cubes thus have some degree of freedom to rotate around the strap. Overall, two cubes are terminal and the other ones then either are straight or corners depending on the shape of hole. Whether you can visualize how “it works” or not, you should definitely check this link can give you an appreciation of the &lt;a href="https://woodgears.ca/puzzles/snake_cube.html"&gt;craft behind a wooden Snake Cube&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;After solving the Snake-Cube by hand, the puzzle started pinching my interest. I could imagine a procedure to invent “new” Snake-Cube puzzles (by drawing a path that fills the cube in 3D, a common graph-theory problem) but I wanted to convince myself: is there only one solution? Can I make a program to solve the Snake-Cube automatically and somewhat efficiently? I decided to give it a try with &lt;a href="https://www.minizinc.org/"&gt;MiniZinc&lt;/a&gt;, a &lt;em&gt;constraint programming&lt;/em&gt; toolbox. This article is an introduction to MiniZinc and illustrates how one can solve real-world problem with MiniZinc. We explain basic formal modeling techniques and touch on some advanced topics as well. No prior knowledge of MiniZinc is required although we will not run you through the menus of the IDE before showing screenshots.&lt;/p&gt; &lt;h1 id="a-minizinc-model"&gt;A MiniZinc model&lt;/h1&gt; &lt;p&gt;MiniZinc is a language for finite-search discrete programming. These complicated words mean that you get to declaratively specify, in a restricted formal language, what the characteristics of your problem are. A key restriction is that all variables are known and have a finite number of possible states. This restriction is not really a limitation in our case. A computer program then ingests the formal specification and automatically find solutions to the problem, or proves there are none.&lt;/p&gt; &lt;h2 id="basic-formalism-for-the-snake-cube"&gt;Basic formalism for the Snake-Cube&lt;/h2&gt; &lt;p&gt;To solve the Snake-Cube we need to capture interesting properties of the puzzle with &lt;em&gt;variables&lt;/em&gt;. Introducing variables is like &lt;strong&gt;having words to discuss concepts&lt;/strong&gt;. Variables must have a name and a &lt;em&gt;domain&lt;/em&gt; (i.e., a range of allowed values).&lt;/p&gt; &lt;p&gt;For instance, the snake is made of small &lt;em&gt;cubes&lt;/em&gt;. There are 27 (3x3x3) cubes in total. Thus we can give a name to each individual cube in the snake. Since solvers work with numbers, the easiest way is to use numerical names (i.e., indexing of values).&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: CUBE = 1..27; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This MiniZinc statement says that we number each individual cube starting from &lt;code&gt;1 up to 27&lt;/code&gt;. We could have used &lt;code&gt;0..26&lt;/code&gt; or another &lt;em&gt;indexing scheme&lt;/em&gt;. The choice is a matter of preference but sometimes in MiniZinc it is convenient to leave &lt;code&gt;0&lt;/code&gt; as a special index to represent ‘absence of cube’.&lt;/p&gt; &lt;p&gt;Another way to imagine the Snake-Cube, rather than focusing on the snake &lt;span class="emoji" data-emoji="snake"&gt;🐍&lt;/span&gt;, let’s focus on the cube &lt;span class="emoji" data-emoji="package"&gt;📦&lt;/span&gt; . Let’s introduce the concept of &lt;em&gt;folded-cube&lt;/em&gt;, which represents the cube as a collection of 27 slots or &lt;em&gt;positions&lt;/em&gt;. This concept of position allows-us to explain the rules of Snake-Cube. Thus, let’s give a numerical index to each final position.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: POS = 1..27; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Astute readers may wonder why both &lt;code&gt;CUBE&lt;/code&gt; and &lt;code&gt;POS&lt;/code&gt; are numbered &lt;code&gt;1..27&lt;/code&gt;. The enumeration of values 1 to 27 is merely the representation of integers backing the individual and separate concepts. Another way to put it, is to say that &lt;code&gt;POS&lt;/code&gt; and &lt;code&gt;CUBE&lt;/code&gt; represent two different sets, and hence have different types. Which means that whenever we use a &lt;code&gt;CUBE&lt;/code&gt; in a function or as an array index, we get a MiniZinc compiler warning.&lt;/p&gt; &lt;p&gt;At this point, we have not achieved much yet, but we set up the basics of the problem. We can start recognizing and formulating the puzzle in a more formal way. Goal of the Snake-Cube: we need to &lt;strong&gt;attribute exactly one of the 27 positions to each one of the 27 cubes&lt;/strong&gt;. The new concept here is the &lt;em&gt;assignment&lt;/em&gt;, and we will need to introduce new variables in MiniZinc to be able to speak about the assignment. Further, the &lt;code&gt;POS&lt;/code&gt; and &lt;code&gt;CUBE&lt;/code&gt; concepts are immanent in our problem, there is not much work for MiniZinc, whereas this new concept of assignment is like a guess or a blank that MiniZinc will have to fill-in. We refer to these variables as &lt;em&gt;decision variables&lt;/em&gt; which are annotated with the &lt;code&gt;var&lt;/code&gt; keyword. Since we need to guess one position for each cube, we need as many decision variables as there are cubes. Rather than writing 27 times &lt;code&gt;var POS&lt;/code&gt; , we can bundle these variables in a &lt;em&gt;dimensional arrays&lt;/em&gt;. Like variables, dimension variables must have some initial domain. For instance machine integers, 1..100, or some set introduced beforehand. In our case, for each &lt;code&gt;CUBE&lt;/code&gt; we want a &lt;code&gt;var POS&lt;/code&gt;. So let’s introduce one array, indexed by &lt;code&gt;CUBE&lt;/code&gt; and containing &lt;code&gt;var POS&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;array[CUBE] of var POS: positions; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Repeating for clarity: this statement says that &lt;code&gt;positions&lt;/code&gt; is an array, which is indexed by &lt;code&gt;CUBE&lt;/code&gt; (i.e., it has one item for each of the 27 cubes) and of which items are positions to be decided.&lt;/p&gt; &lt;p&gt;If we run the solver like this, MiniZinc will happily find a solution (that is, it will be able to determine a concrete &lt;code&gt;POS&lt;/code&gt; for each &lt;code&gt;var POS&lt;/code&gt; in the &lt;code&gt;positions&lt;/code&gt; array &lt;img src="images/snake-cube-mzn-001.png" alt="solution showing all-ones" /&gt;&lt;/p&gt; &lt;p&gt;This screenshot shows an output of MiniZinc in the bottom pane (with our trivial problem model in the top pane). The message roughly said that MiniZinc found a correct assignment so far: every cube is put in the same position. This solution is unsatisfactory for the puzzle, but the reason is obvious: we have not given any “rules” of the Snake-Cube yet.&lt;/p&gt; &lt;h2 id="modeling-the-rules-of-snake-cube"&gt;Modeling the rules of Snake-Cube&lt;/h2&gt; &lt;p&gt;I claim there are two broad set of rules in the Snake-Cube.&lt;/p&gt; &lt;p&gt;On the first hand, some rules &lt;strong&gt;are enforced by physics&lt;/strong&gt;. For instance, cubes cannot overlap in space, corners force a change of direction, the rubber band filing through the cube forces a sort of continuity. On the other hand, other rules are &lt;strong&gt;enforced by our curiosity&lt;/strong&gt;, in the Snake-Cube the fact that the final shape actually is a cube, rather than, say, a L-shape is quite important. Otherwise, Snake-Cube would not be a puzzle but a mere toy to hammer things and make noise.&lt;/p&gt; &lt;p&gt;Encoding such rules into a model requires some process to &lt;strong&gt;express a vague intention&lt;/strong&gt; of a high-level statement – like the rules I stated above – &lt;strong&gt;into some given formalism&lt;/strong&gt;. Such a translation takes some practice, but you do not have to be intimidated. I would say that the formulating a constraint-programming problem has some similarities with formulating complicated SQL queries given an imprecise business requirement: you need to take care of NULLs, whether a RIGHT or LEFT join and all these sorts of things that can ruin the validity or the performance of the query.&lt;/p&gt; &lt;p&gt;The MiniZinc formalism, is built around a set of &lt;em&gt;constraints&lt;/em&gt; statements with a small set of basic logic introduction rules rules (equality, negation, inequalities, connectives: roughly what you get in &lt;a href="https://en.wikipedia.org/wiki/First-order_logic"&gt;predicate logic&lt;/a&gt;). Constraints add some coupling between variables, and allow the solver to perform some reasoning to shrink the domain of decision variables via a series of deductions. For instance, if you must guess a number between 1 to 10 but you learn that doubling this number is at least 16, then you can reduce the choice to 8, 9, or 10. In a proper business setup 16 could represent a target number of sales and the guess could represent the amount to spend on advertisement. In this example you would try to find the least amount to spend that still hit the target. In more involved examples, the target 16 could instead also be a decision variable in relationship with other commitments (i.e., there are more indirect coupling between two sets of decisions but the solver can still reason about these). Summarizing, a model requires to formalize how variables are linked to each other with a web constraints. These constraints have limited expressively so that a solver can propagate information between variables and along the connections that constraints impose.&lt;/p&gt; &lt;p&gt;Coming back to the Snake-Cube, let’s take for instance a physical rule that cubes cannot overlap. Let’s iteratively reformulate this statement in the MiniZinc language. Without doing to much maths ceremony, we could say that &lt;strong&gt;cubes cannot overlap&lt;/strong&gt; means that &lt;strong&gt;there can be at most one CUBE per POS&lt;/strong&gt;. Alas &lt;code&gt;at most one&lt;/code&gt; is a pretty complicated term, we so far only have &lt;code&gt;CUBE&lt;/code&gt;, &lt;code&gt;POS&lt;/code&gt;, and &lt;code&gt;positions&lt;/code&gt; as objects to manipulate. Thus, if we want to count how many &lt;code&gt;CUBE&lt;/code&gt; exists in each &lt;code&gt;POS&lt;/code&gt; we would have to introduce variables for counting occurrences of POS. All theses variables seem like a lot of extra work and we can try to find simpler expressions of the same rule. If we try to rephrase further, we could find a “simpler” way to encode our rule. We don’t need to count every occurrence but rather we should prevent co-occurrences. That is, to say, in a formal tone &lt;strong&gt;no two distinct CUBEs can be attributed to the same POS in the position array&lt;/strong&gt;. Even if this formulation hurts the ears, this formulation is good because we already have everything at our disposal. In MiniZinc, this statement would be written like this&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;constraint forall(c1, c2 in CUBE c1 != c2) (position[c1] != position[c2])`; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;constraint&lt;/code&gt; keyword introduces a new constraint. The &lt;code&gt;forall&lt;/code&gt; keyword has two sets of braces: an iteration binds variable names, in that case over all pairs of distinct &lt;code&gt;CUBE&lt;/code&gt;. The second set of braces contains another constraint, which in this case is merely looking up the positions of &lt;code&gt;CUBEs&lt;/code&gt; and requesting that their &lt;code&gt;POS&lt;/code&gt; are different, since &lt;code&gt;position&lt;/code&gt; is an array indexed by &lt;code&gt;CUBE&lt;/code&gt; we just need to perform a lookup. This indexing illustrates how natural it becomes to have arrays indexes by variables defined. You do not have to translate back to numerical indices starting at zero (or one depending on your typical programming language), MiniZinc translates indices for you.&lt;/p&gt; &lt;p&gt;Such a constraint of uniqueness of decision variables often arises while formalizing problems. Even if terse, it would be cumbersome to rewrite such a constraint every single time. Fortunately MiniZinc has a number of features to help with repetitive work: &lt;em&gt;functions&lt;/em&gt; and &lt;em&gt;predicates&lt;/em&gt; functions are like your typical programming function with arguments and an output. However they behave morally more like macros (i.e., MiniZinc will expand their content). Whereas predicates are functions that return constraints. As a modeler you would use predicates and functions to create increasingly-high level constraints from atomic constraints. You will find a library predicate in MiniZinc named &lt;code&gt;all_different&lt;/code&gt;. Thus we can rewrite our statement above with&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;include &amp;quot;all_different.mzn&amp;quot;; constraint all_different(positions); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This formulation is better than the &lt;code&gt;forall&lt;/code&gt; because it is more declarative: you cannot really mix it up. This formulation also has an incredible advantage: solvers can recognize these predicates and implement special routines to solve them faster. In constraint programming, such predicates are named &lt;em&gt;globals&lt;/em&gt; because &lt;strong&gt;globals can efficiently propagate information to all variables at once&lt;/strong&gt;, rather than the more point-to-point propagation which occurs with the “pedestrian” implementation. If a specific solver doesn’t know how global, MiniZinc defaults to a semantically-equivalent implementation (in short: the compatibility matrix is built-in). If we run MiniZinc we now get something better.&lt;/p&gt; &lt;p&gt;&lt;img src="images/snake-cube-mzn-002.png" alt="solution showing all-differents but not a real folded-cube" /&gt;&lt;/p&gt; &lt;p&gt;The assignment we get now looks &lt;em&gt;more correct&lt;/em&gt; (whatever that means). In a sense we can convince ourselves that we already have forced every &lt;code&gt;CUBE&lt;/code&gt; to fit in a box, and that no two cubes will ever be in the same position. Remember that we have 27 &lt;code&gt;CUBEs&lt;/code&gt;. All stars align, &lt;strong&gt;we have enforced the folded-cube rule without thinking too much&lt;/strong&gt; about it! Did we? actually it is not &lt;em&gt;that&lt;/em&gt; simple. Constraint programming is a bit like an evil genie: it will answer your wishes but did you clearly state your wish? Let’s recap what we have done.&lt;/p&gt; &lt;p&gt;So far we have discussed MiniZinc and brushed some vague explanation about how a constraint-solver works. We have seen the basics of what formalizing a game with variables and constraints. We managed to define variables to name every &lt;code&gt;CUBE&lt;/code&gt; in the snake and every &lt;code&gt;POS&lt;/code&gt; in the folded-cube. We recognized that we need to find one &lt;code&gt;POS&lt;/code&gt; for every &lt;code&gt;CUBE&lt;/code&gt; and thus built an array to store a decision &lt;code&gt;POS&lt;/code&gt; for every &lt;code&gt;CUBE&lt;/code&gt;. We also used the global predicate &lt;code&gt;all_different&lt;/code&gt; to force every &lt;code&gt;CUBE&lt;/code&gt; to be in a different POS, hence encoding some rules. All of this setup was mostly introductory.&lt;/p&gt; &lt;p&gt;Now what’s left: well, the folding problem is left! At this point, there are no connections between individual cubes. It’s like if we torn apart the Snake and stacked all the cubes and re-ordered them. We have not spoken about geometry at all. We don’t even know if the &lt;code&gt;POS&lt;/code&gt; numbering represents a 3x3x3 object because we have not inserted that into our model at all. To go further we’ll need to introduce some notion of coordinates.&lt;/p&gt; &lt;h2 id="a-coordinates-system"&gt;A coordinates system&lt;/h2&gt; &lt;p&gt;Coordinates will be useful for two things: first, ensure that our &lt;code&gt;POS&lt;/code&gt; numbering represents a 3x3x3 cube (remind that if you somehow forget this, the evil genie will mis-interpret your wish). And the coordinates will also be able to enforce the rules of what are valid folds that do not tear the snake apart.&lt;/p&gt; &lt;h3 id="3d-coordinates-of-positions"&gt;3d-coordinates of positions&lt;/h3&gt; &lt;p&gt;Let’s take a direct approach and define one type per dimension. Each &lt;code&gt;POS&lt;/code&gt; will have one coordinate value in every dimension. We can model this characteristics with three array indexed by &lt;code&gt;POS&lt;/code&gt; and that contains one dimensional value.&lt;/p&gt; &lt;p&gt;In object-oriented programming you would model that with a list of Position object, each containing three coordinates named x, y, and z. In MiniZinc you have three lists in parallel, each one encoding a single coordinate. Such a modeling with “one column per field” is typical in ‘columnar databases’ or in ‘ECS frameworks’, or even good old ‘CSV files’.&lt;/p&gt; &lt;p&gt;In MiniZinc you write:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: X = 0..2; set of int: Y = 0..2; set of int: Z = 0..2; array[POS] of X: xs = [ (p - 1) mod 3 | p in POS ]; array[POS] of Y: ys = [ ((p - 1) div 3) mod 3 | p in POS ]; array[POS] of Z: zs = [ ((p - 1) div 9) mod 3 | p in POS ]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;An important note here is that we restrict upfront the interesting coordinates to be 0, 1, or, 2. Indeed, the folded-cube is only 3x3x3 and hence we do not really need to discuss what happens outside the folded-cube. On the opposite, if we limit ourself to a narrow world with 3 values per dimension, we can make sure our folded-cube does not “leak” because each &lt;code&gt;CUBE&lt;/code&gt; has a &lt;code&gt;POS&lt;/code&gt; via the &lt;code&gt;position&lt;/code&gt; array, and hence each &lt;code&gt;CUBE&lt;/code&gt; transitively has a X, a Y, and a Z in the 0..2 range, which means that every &lt;code&gt;CUBE&lt;/code&gt; is born to live ‘constrained’ in our 3x3x3 world, without explicitly adding constraints like &lt;code&gt;constraint forall(c in CUBE)( position[CUBE] &amp;lt;= 2 ) &lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt; merely is arithmetic to give 3d coordinates for a ‘natural’ numbering of cube as shown in the following poor diagram I made&lt;/p&gt; &lt;p&gt;&lt;img src="images/snake-cube-coords.png" alt="diagram of 3d 3x3x3 cube" /&gt;&lt;/p&gt; &lt;p&gt;On this picture, the numbers correspond to &lt;code&gt;POS&lt;/code&gt; objects; not shown the values along X, Y, and Z start at &lt;code&gt;0&lt;/code&gt; at the ‘origin’ (and thus, &lt;code&gt;POS-1&lt;/code&gt; is at coordinates &lt;code&gt;{0,0,0}&lt;/code&gt;).&lt;/p&gt; &lt;p&gt;Also, since this computation is entirely determined from the input data, nothing is variable (i.e., MiniZinc runs the arithmetic before asking the solver to run guesses).&lt;/p&gt; &lt;h3 id="segmenting-the-snake"&gt;Segmenting the Snake&lt;/h3&gt; &lt;p&gt;Now that it’s clear that the folded-cube is 3x3x3, let’s talk about the snake. I decided to model the snake as a series of &lt;code&gt;SEGMENTs&lt;/code&gt; which are characterized by a starting and an ending &lt;code&gt;CUBE&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;For instance the following snake as initial segments &lt;code&gt;[1,3] [3,5] [5,7] [7,9]...&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code&gt; 1 2 3 9 o-o-o o-.... | | 4 o o 8 | | o-o-o 5 6 7 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This is the part of the puzzle where I had to verify five times I did the right counting because I’m not very good at counting above ten.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: SEGMENT = 1..17; array[SEGMENT,1..2] of CUBE: segments = [|1,3|3,5|5,7|7,9|9,10|10,11|11,12|12,14|14,16|16,17|17,18|18,20|20,21|21,23|23,24|24,25|25,27|]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This compact syntax allows to declare a &lt;em&gt;two-dimensional array&lt;/em&gt; and its content. The array is declared as having two indexing keys and contains &lt;code&gt;CUBEs&lt;/code&gt;. The index &lt;code&gt;1..2&lt;/code&gt; represents the start or the end of the segment. Thus &lt;code&gt;segments[5,1] = 9&lt;/code&gt; is the &lt;code&gt;CUBE&lt;/code&gt; that starts the fifth &lt;code&gt;SEGMENT&lt;/code&gt; of the snake, whereas &lt;code&gt;segments[5,2] = 10&lt;/code&gt; is the &lt;code&gt;CUBE&lt;/code&gt; that ends the fifth &lt;code&gt;SEGMENT&lt;/code&gt; of the snake. Alternatively we could have two separate arrays for starting end ending &lt;code&gt;CUBEs&lt;/code&gt; of &lt;code&gt;SEGMENTS&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Now what’s interesting in the physical version of the puzzle is that handling this snake is a bit overwhelming. Each segment is stiff, however between two segments the snake can rotate (or pivot around). That is, &lt;em&gt;along&lt;/em&gt; a segment, the &lt;code&gt;CUBEs&lt;/code&gt; of a &lt;code&gt;SEGMENT&lt;/code&gt; cannot move. However at &lt;code&gt;junctions between two segments&lt;/code&gt;, segments are free to rotate.&lt;/p&gt; &lt;h3 id="enforcing-the-physics-of-the-game"&gt;Enforcing the physics of the game&lt;/h3&gt; &lt;p&gt;We just need to encode these two rules (which will refer to as &lt;em&gt;pivot&lt;/em&gt; or &lt;em&gt;straight&lt;/em&gt;) and we will be done. There are no major difficulty for this but it is not entirely straightforward given how many indirections exist in our model. To recap, our main input is a list of &lt;code&gt;SEGMENTs&lt;/code&gt;, which inform us about how &lt;code&gt;CUBEs&lt;/code&gt; can be laid out relative to each other. Each &lt;code&gt;CUBE&lt;/code&gt; must be given a &lt;code&gt;POS&lt;/code&gt; and each &lt;code&gt;POS&lt;/code&gt; has three coordinates. We now need to link every &lt;code&gt;CUBE&lt;/code&gt; in a &lt;code&gt;SEGMENT&lt;/code&gt; with some &lt;code&gt;straight&lt;/code&gt; rule to force coordinates to form a line. And we need to link the coordinates of the &lt;code&gt;POS&lt;/code&gt; of connecting &lt;code&gt;CUBEs&lt;/code&gt; in consecutive &lt;code&gt;SEGMENTs&lt;/code&gt; to form a &lt;code&gt;corner&lt;/code&gt; . Yes it’s a lot of words but when you handle the puzzle it becomes very intuitive.&lt;/p&gt; &lt;p&gt;&lt;img src="images/snake-cube-l-shape.png" alt="diagram of L-shape cubes illustrating straight and corner rules" /&gt;&lt;/p&gt; &lt;p&gt;The above picture summarizes the two rules with two &lt;code&gt;SEGMENT&lt;/code&gt; forming an L-shape. Along the arrow, &lt;code&gt;CUBEs:{1,2,3}&lt;/code&gt; must follow each other and form a &lt;code&gt;straight&lt;/code&gt;, whereas at &lt;code&gt;CUBE:3&lt;/code&gt; a junction forces &lt;code&gt;CUBES:{2,3,4}&lt;/code&gt; to form a &lt;code&gt;corner&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;I said two rules? sorry I was too fast. Actually the rule &lt;code&gt;straight&lt;/code&gt; is sufficient &lt;span class="emoji" data-emoji="thinking"&gt;🤔&lt;/span&gt; Why? the argument needs to connect three clues together:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;each &lt;code&gt;SEGMENT&lt;/code&gt; of the Snake will have at least two &lt;code&gt;CUBEs&lt;/code&gt; &lt;/li&gt; &lt;li&gt;with the ‘straight’ rule, each &lt;code&gt;SEGMENT&lt;/code&gt; will span at least 2 in any dimension &lt;/li&gt; &lt;li&gt;we forced coordinates to be in the 0..2 range, and at the time I stressed how useful that was Thus you cannot align two &lt;code&gt;SEGMENT&lt;/code&gt; without leaking outside the &lt;code&gt;CUBE&lt;/code&gt; &lt;span class="emoji" data-emoji="exploding_head"&gt;🤯&lt;/span&gt; . &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;In typed-programming languages like Haskell and OCaml, we speak about making impossible states representables, this reasoning is roughly similar. Such shortcuts, however, in constraint-programming are a point of attention. You need to be careful when iterating on your models. The model does not represent the reality, where I can unfold the Snake along one dimension, but I only care about arrangements where the Snake is folded. That is, my model explicitly departs from the physics of the game. Such a shortcut is convenient because there is likely less typing, the solver will likely be faster because it will not be spending time evaluating solutions doomed to fail. However I cannot just extend my model to the 4x4x4 case without some extra work first because our elaborate argument for the lazy modeler would fall apart.&lt;/p&gt; &lt;h3 id="minizinc-formalization-of-the-physics"&gt;MiniZinc formalization of the physics&lt;/h3&gt; &lt;p&gt;Let’s now formulate the &lt;code&gt;straight&lt;/code&gt; rule. Remember that MiniZinc speaks of constraints, and a way to build re-usable constraints is a &lt;code&gt;predicate&lt;/code&gt;. I’m deliberately developing and elaborating bits by bits what &lt;code&gt;straight&lt;/code&gt; formally means in &lt;strong&gt;top-to-bottom fashion&lt;/strong&gt; so that the motivation for introducing a “sub-predicate” is to break-down the higher-level predicate we wrote before. A number of new syntaxes (like &lt;em&gt;let-bindings&lt;/em&gt;) will not be explained so you may have to read code-examples slowly before and after reading the explanation.&lt;/p&gt; &lt;p&gt;We would like to do something like saying &lt;strong&gt;all SEGMENT must form straight lines&lt;/strong&gt;. Which is a straightforward.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;constraint forall(s in SEGMENT)(straight(s)); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;MiniZinc will complain that &lt;code&gt;straight&lt;/code&gt; is not defined yet, but at least the only new “top-level constraint” is written down and we are left with elaborating our predicate. We need to break-down what it means to form a straight line because we can place segments along any of the three dimensions. This predicate thus needs another set other predicates (&lt;code&gt;alongX, alongY, and alongZ&lt;/code&gt;) in a &lt;em&gt;boolean OR disjunction&lt;/em&gt;. Note that in formal methods &lt;code&gt;x = a \/ b&lt;/code&gt; has information flowing in both directions, so if you can determine that &lt;code&gt;x&lt;/code&gt; is true then it tells you that at least &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is true, which seems logical when stated but can look unusual to programmers used to handling ORs with information flowing in a single direction. Let’s write down our disjunction along all three axes:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate straight(SEGMENT: s) = let {CUBE: c0 = segments[s,1]; CUBE: c1 = segments[s,2]} in alongX(c0..c1) \/ alongY(c0..c1) \/ alongZ(c0..c1); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;At this point I am saying that a straight segment can be straight &lt;code&gt;along X OR along Y OR along Z&lt;/code&gt;. Since we have not really specified what these individual predicates mean our &lt;code&gt;SEGENT&lt;/code&gt; could be placed along two dimensions at a same time: in some puzzles being placed along multiple dimensions might mean a form of diagonal, but we’ll not allow it here. With &lt;code&gt;c0..c1&lt;/code&gt; I expand the &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; &lt;code&gt;CUBE&lt;/code&gt; of the segment and turn that into an array of &lt;code&gt;CUBEs&lt;/code&gt; to the individual predicates because we want to start discussing about coordinates of positions of cubes.&lt;/p&gt; &lt;p&gt;In plain English, being ‘along X’ means that the &lt;code&gt;X&lt;/code&gt; coordinates of the positioned cubes vary whereas the &lt;code&gt;Y&lt;/code&gt; and &lt;code&gt;Z&lt;/code&gt; coordinates are fixed (if you go back to my pictures, the three cubes in the L-shape are “along X”, hence &lt;code&gt;Y&lt;/code&gt; and &lt;code&gt;Z&lt;/code&gt; are fixed and &lt;code&gt;X&lt;/code&gt; vary). We can thus encode such a predicate with a &lt;em&gt;boolean AND conjunction&lt;/em&gt; of three clauses:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate alongX(array[int] of CUBE: cubes) = along(cubes, xs) /\ samePos(cubes, ys) /\ samePos(cubes, zs); predicate alongY(array[int] of CUBE: cubes) = samePos(cubes, xs) /\ along(cubes, ys) /\ samePos(cubes, zs); predicate alongZ(array[int] of CUBE: cubes) = samePos(cubes, xs) /\ samePos(cubes, ys) /\ along(cubes, zs); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;That’s a bit of boilerplate as we repeat ourselves for each dimension. To avoid repeating ourselves while elaborating further, we will pass the useful information “in which dimension we are” as arguments to the lower-level predicates: &lt;code&gt;along&lt;/code&gt; and &lt;code&gt;samePos&lt;/code&gt; . Both predicates take a series of cubes and a the coordinates in the dimension of interest as arguments. Let’s formulate &lt;code&gt;along&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate along(array[int] of CUBE: cubes, array[POS] of int: proj) = let { CUBE: c0 = cubes[1]} in forall(c1 in cubes where c1 &amp;gt; c0)(abs(proj[positions[c0]] - proj[positions[c1]]) = c1 - c0); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Some discussion around the design of the parameters:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;taking an array of &lt;code&gt;CUBEs&lt;/code&gt; rather than a single &lt;code&gt;SEGMENT&lt;/code&gt; because I didn’t want to repeat &lt;code&gt;segments[s,1]&lt;/code&gt; many times, and also because I started with another (more complex) model that had no &lt;code&gt;SEGMENT&lt;/code&gt; yet and was lazy to change it for cosmetics &lt;/li&gt; &lt;li&gt;taking an &lt;code&gt;array[POS] of int&lt;/code&gt; named ‘proj’ for “projection along an axis”: the proper definition of the rule is a bit picky but is exactly the same in all the three dimensions, so let’s write it only once and avoid typos &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;What is important is that the first CUBE is taken as a reference, then I force the distance of the positioned cubes (i.e., via the indirection &lt;code&gt;proj[positions[ ]]&lt;/code&gt; and with &lt;code&gt;abs&lt;/code&gt; the absolute value function) of the positions to match the distance on the unfolded Snake &lt;code&gt;c1 - c0&lt;/code&gt;. For instance, for the segment of &lt;code&gt;CUBEs-{5,6,7}&lt;/code&gt; along X. We enforce that, once positioned in folded-cube, the distance between CUBE-5&lt;code&gt;and&lt;/code&gt;CUBE-6&lt;code&gt;is exactly 1 and the distance between&lt;/code&gt;CUBE-5&lt;code&gt;and&lt;/code&gt;CUBE-7` is exactly 2. The absolute value encodes the fact that the segment could be in either direction (left to right or right to left) while along the same axis.&lt;/p&gt; &lt;p&gt;Now we are left specifying the &lt;code&gt;samePos&lt;/code&gt; predicate. This predicate takes the same arguments as &lt;code&gt;along&lt;/code&gt; to avoid typing it for each dimension. However &lt;code&gt;samePos&lt;/code&gt; is simple to write: while &lt;code&gt;along&lt;/code&gt; enforced some distance along an axis, &lt;code&gt;samePos&lt;/code&gt; enforce no changes along an axis. Thus, we do not need complicated arithmetics with absolute values, a simple &lt;em&gt;equality&lt;/em&gt; will do.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate samePos(array[int] of CUBE: cubes, array[POS] of int: proj) = forall(c0, c1 in cubes where c0 &amp;lt; c1)(proj[positions[c0]] = proj[positions[c1]]); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;And we are done! Overall, forcing successive coordinates along X and same coordinates along Y and Z ensure our segment is stiff. Elaborating from a top-level constraint we have written a number of helper-predicates. It may feel superfluous but writing all the constraints by hand would have been especially boring and hard to get right without copy-paste-edit typos. If you fiddle with intermediary MiniZinc files you’ll realize that the extra constraint adds 488 atomic constraints. As a point of comparison the lonely global “all_different” from previous section generate a single atomic constraint.&lt;/p&gt; &lt;h3 id="running-minizinc-at-last"&gt;Running MiniZinc at last&lt;/h3&gt; &lt;p&gt;When we now run MiniZinc, we are greeted with a solution after roughly one second.&lt;/p&gt; &lt;p&gt;&lt;img src="images/snake-cube-mzn-003.png" alt="proper solution but oddly-formatted" /&gt;&lt;/p&gt; &lt;p&gt;I was pretty excited when I got my first solution. I verified it by twisting my fingers. Something pretty interesting happened: &lt;strong&gt;I could not fold the Snake-Cube&lt;/strong&gt; &lt;span class="emoji" data-emoji="dizzy_face"&gt;😵&lt;/span&gt; . What on Earth has gone wrong?&lt;/p&gt; &lt;h1 id="the-mystery-and-the-symmetries"&gt;The mystery and the symmetries&lt;/h1&gt; &lt;p&gt;Alright, me failing to fold a Snake, even with a solution given by MiniZinc has only a few possible explanations:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Hypothesis-A: I made a mistake in the model (likely &lt;span class="emoji" data-emoji="frowning"&gt;😦&lt;/span&gt;) &lt;/li&gt; &lt;li&gt;Hypothesis-B: I failed at following the output (very likely &lt;span class="emoji" data-emoji="nerd_face"&gt;🤓&lt;/span&gt;) &lt;/li&gt; &lt;li&gt;Hypothesis-C: Even if we have a valid positioning, it is not feasible to operate the sequence of moves (the cube is only 3x3x3 so I estimate it unlikely, I might need to start folding from the middle, however &lt;span class="emoji" data-emoji="exploding_head"&gt;🤯&lt;/span&gt;) &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;I audited my model, added some traces and redundant constraints to quickly verify/check some more invariants: nothing seemed off. Then, rather than following the output again I took a rather barbaric approach: rather than starting folding from &lt;code&gt;CUBE-0&lt;/code&gt; in my solution I started from &lt;code&gt;CUBE-27&lt;/code&gt; and it miraculously worked &lt;span class="emoji" data-emoji="relieved"&gt;😌&lt;/span&gt;. &lt;strong&gt;Maybe the solver gave me a different solution the second time&lt;/strong&gt; and Hypothesis-C is correct. After-all I was not doing exhaustive checks and I made the rookie mistake of &lt;em&gt;not&lt;/em&gt; storing my first output.&lt;/p&gt; &lt;p&gt;With a sucessfully folded-cube (as shown in the early pictures), I had strong clue that my MiniZinc model was right because &lt;strong&gt;at least one solution it gave was empirically correct&lt;/strong&gt; . There still is the room for a combination of errors: what if the output was incorrect and at a same time I failed at following the output and also ended up following a valid folding by “luck” - extremely unlikely and against &lt;a href="https://en.wikipedia.org/wiki/Occam%27s_razor"&gt;Occam’s principle &lt;span class="emoji" data-emoji="razor"&gt;🪒&lt;/span&gt;&lt;/a&gt; at this level of debugging.&lt;/p&gt; &lt;p&gt;Hypothesis-C was still piking my interest. I spent some time on YouTube and people recommend to fold the snake starting at the middle. Something I had not really foreseen and could be really frustrating: it would be incredibly hard to model the exact folding sequence as a hobby project. Such a folding requires to introduce a notion of time and verify that along time all rotations are allowed: it’s a much more ambitious model than our the small introduction I hope to give in this blog post.&lt;/p&gt; &lt;p&gt;I preferred to take another approach to rule-out Hypothesis-C: &lt;strong&gt;trying to find all possible folding and if I find only one then there is only one solution&lt;/strong&gt;. In MiniZinc it’s really easy, in the configuration you just ask “print all solutions”. Actually, I did that and not only the program found many solutions (six in ten seconds), it also kept running and searching and searching and searching. Switching the solver to &lt;strong&gt;Chuffed found 48 solutions in two seconds and proved that no-other solutions exist&lt;/strong&gt;. That is still a lot for me to try given how bad I am at following one solution by hand, we need an idea to compare two solutions. The idea was to manipulate the folded-cube &lt;span class="emoji" data-emoji="bulb"&gt;💡&lt;/span&gt; : if I turn the folded-cube around then I have reorganized the coordinates of each &lt;code&gt;POS&lt;/code&gt; (say POS:1 is no longer in &lt;code&gt;{1,1,1}&lt;/code&gt; but in &lt;code&gt;{3,1,1}&lt;/code&gt; by rotating the cube along the &lt;code&gt;Y&lt;/code&gt; vertical axis: it’s a new solution, but not an especially interesting one compared to my first solution. In constraint-programming and in general in physics, the phenomenon we want to control is named &lt;em&gt;symmetry&lt;/em&gt;.&lt;/p&gt; &lt;h2 id="symmetries"&gt;Symmetries&lt;/h2&gt; &lt;p&gt;Say you give me a valid &lt;code&gt;positions&lt;/code&gt; array. I can also build another valid &lt;code&gt;positions&lt;/code&gt; array by changing the numbering (so that X and Y coordinates are ‘swapped’ – the physical equivalent is to rotate around Z). I could tell you “here, a new solution” but you would be really right to feel cheated.&lt;/p&gt; &lt;p&gt;Besides running Chuffed, I have not taken the time to enumerate symmetries in a formal way but I guess there exist at least three things to break (two &lt;em&gt;rotations&lt;/em&gt; along Y and Z times plus &lt;em&gt;flipping&lt;/em&gt; positive directions into negative directions). In constraint-programming (and in general in search problems) you &lt;em&gt;break symmetries&lt;/em&gt; by adding extra constraints that do not come from the initial rules of the problem. These extra constraints will force the search algorithm to look for interestingly-different solutions. This technique also has the benefit to accelerate the resolution as more “branches” are pruned “sooner”. Sometimes, breaking symmetries is mandatory to find any solution when the problem is actually hard.&lt;/p&gt; &lt;p&gt;In the Snake-Cube game, the way I ended up breaking symmetries was to the follow this line of reasoning:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;the first segment defines the &lt;code&gt;X&lt;/code&gt; axis (and &lt;code&gt;CUBE&lt;/code&gt; indices increments along X) &lt;/li&gt; &lt;li&gt;the second segment defines the &lt;code&gt;Y&lt;/code&gt; axis (and &lt;code&gt;CUBE&lt;/code&gt; indices increment along Y) &lt;/li&gt; &lt;li&gt;then the first segment that is not along X nor Y will must be along Z (so you don’t win much) but will define the positive Z values &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;What is important to keep in mind is that what defines the &lt;code&gt;Z&lt;/code&gt; axis is not always “the third segment” because nothing tells you that the third segment will not be along X in the decreasing direction (i.e., the three first segments could form a U-shaped). We really would like to say, “the first segment along &lt;code&gt;Z&lt;/code&gt; defines &lt;code&gt;Z&lt;/code&gt;”, but that would be a circular definition without spending extra work formalizing what it means to define an axis.&lt;/p&gt; &lt;p&gt;A problem with symmetry-breaking constraints is to convince yourself the rules are valid and do not mistakenly prune-out desireable solutions. I found it easier to think in terms of directions in the coordinate system than thinking about what it means for all the “next segments” to take a turn-right at the beginning. Another way to convince ourselves is to count how many coordinate systems we can generate around a fixed folded-snake. Defining the first &lt;code&gt;DIR&lt;/code&gt; has 3 possible choices (any of three-dimensions), we have 2. Then at each definition we can pick positive or negative indices, so we have &lt;code&gt;2*2*2&lt;/code&gt; symmetries here. In total we get &lt;code&gt;3*2*2*2*2 = 48&lt;/code&gt; possible coordinate systems for our Snake. Which is consistent with what Chuffed has found (cf. &lt;a href="/raw/snake-cube-extra-all-solutions-chuffed.txt"&gt;Chuffed raw output&lt;/a&gt;), mystery solved &lt;span class="emoji" data-emoji="muscle"&gt;💪&lt;/span&gt;. We could stop here, but at this point we have done the hard thinking coupled with the brute-force approach, we want to see if from our own eyes. Let’s turn this into hard thinking with an elegant encoding of symmetry-breaking constraints.&lt;/p&gt; &lt;p&gt;The difficulty to formalize these rules in MiniZinc is twofold:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;introducing a notion of ‘direction of segments’ &lt;/li&gt; &lt;li&gt;using this new notion to add constraints to break symmetries &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;So far in our model the &lt;code&gt;SEGMENT&lt;/code&gt; merely were a collection of consecutive CUBEs. We managed to give a &lt;code&gt;POS&lt;/code&gt; to each &lt;code&gt;CUBE&lt;/code&gt;. We however have yet to turn these &lt;code&gt;POS&lt;/code&gt; into a notion of direction. In Snake-Cube, we care about three dimensions, and for each dimension we care about the particular direction (left-to-right or right-to-left). In total it means six directions. We could use &lt;code&gt;set of int: DIR = 1..6&lt;/code&gt; but I instead use a pretty similar construct when you want to give individual names to directions: enums. We somehow now that every &lt;code&gt;SEGMENT&lt;/code&gt; will have a &lt;code&gt;DIR&lt;/code&gt;, so let’s declare that at the same time.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;enum DIR = {XP, XN, YP, YN, ZP, ZN}; array[SEGMENT] of var DIR: directions; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;For instance, &lt;code&gt;directions[3] = XP&lt;/code&gt; stands for ‘segment number 3 has cubes laid out along the X-axis with increasing values’.&lt;/p&gt; &lt;p&gt;The remaining work is to connect &lt;code&gt;DIRs&lt;/code&gt; of &lt;code&gt;SEGMENTs&lt;/code&gt; with the coordinates of positioned &lt;code&gt;CUBEs&lt;/code&gt;. I did that by augmenting the predicate &lt;code&gt;straight&lt;/code&gt; to impose extra conditions with &lt;code&gt;alongX&lt;/code&gt; (and the same for Z and Y).&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate straight(SEGMENT: s) = let {CUBE: c0 = segments[s,1]; CUBE: c1 = segments[s,2]} in (alongX(c0..c1) /\ direction(s, xs, XP, XN)) \/ (alongY(c0..c1) /\ direction(s, ys, YP, YN)) \/ (alongZ(c0..c1) /\ direction(s, zs, ZP, ZN)); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Other designs would have been equally valid. For instance, we could also have modified &lt;code&gt;alongX&lt;/code&gt; directly to pass the &lt;code&gt;SEGMENT&lt;/code&gt; rather than its &lt;code&gt;CUBEs&lt;/code&gt; expansion. What is important is that we now force yet another predicate relating the &lt;code&gt;SEGMENT&lt;/code&gt; and the &lt;code&gt;DIR&lt;/code&gt; together. The &lt;code&gt;direction&lt;/code&gt; predicate is defined as follows:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate direction(SEGMENT: s, array[POS] of int: proj, DIR: dp, DIR: dn) = (proj[positions[segments[s,1]]] &amp;lt; proj[positions[segments[s,2]]] /\ directions[s] = dp) \/ (proj[positions[segments[s,1]]] &amp;gt; proj[positions[segments[s,2]]] /\ directions[s] = dn); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This predicate allows to say that along a given axis, either the segment is positioned ‘left to right’ and the position of the first &lt;code&gt;CUBE&lt;/code&gt; is before the second &lt;code&gt;CUBE&lt;/code&gt;, or the opposite is true.&lt;/p&gt; &lt;p&gt;At this point, we merely have setup extra variables that really do not change the solutions to the solver. However this extra wiring allows us to formulate symmetry-breaking constraints.&lt;/p&gt; &lt;p&gt;One way to say that the first segment defines the X axis, and the first bent segment defines Y is to add.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;constraint directions[1] = XP; constraint directions[2] = YP; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;However, such a scheme would be insufficient for breaking all symmetries. Indeed, it is unclear whether the third &lt;code&gt;SEGMENT&lt;/code&gt; will be positioned along X again or along Z. Further, it could be positioned along XP or XN if the two first &lt;code&gt;SEGMENT&lt;/code&gt; have length 2. In short, it is important to note that we cannot force &lt;code&gt;XN&lt;/code&gt; to be before or after &lt;code&gt;ZP&lt;/code&gt; because that would enforce a constraint stronger than just breaking symmetries (this is merely repeating the lengthy argument when we enumerated the types of symmetries we want to break, but with variable names). Thus, when adding symmetry-breaking symmetries we need to be diligent because there is a risk to mistakenly remove some solutions we would have preferred to keep around. In our snake-folding game, what we can say, however, is that the first time we move in the third dimension, the &lt;code&gt;SEGMENT&lt;/code&gt; has to be aligned with ZP.&lt;/p&gt; &lt;p&gt;Building this &lt;strong&gt;notion of the first time we move in the third dimension&lt;/strong&gt; is doable but is cumbersome and error prone: we need to give a name at the first occurrence of each &lt;code&gt;DIR&lt;/code&gt; in the &lt;code&gt;directions&lt;/code&gt; array and relate the index of these first occurrences with each other. Fortunately for us, MiniZinc has a number of functions listed under the name “symmetry-breaking constraints” to encode that ‘the first occurrence of XP is before the first occurrence of XN and so on and so forth’. I’ve decided to pick &lt;code&gt;value_precede_chain&lt;/code&gt; and &lt;code&gt;value_precede&lt;/code&gt; to encode the fact that &lt;code&gt;XP&lt;/code&gt; is before &lt;code&gt;YP&lt;/code&gt; which in turns is before &lt;code&gt;ZP&lt;/code&gt; and that &lt;code&gt;positive&lt;/code&gt; is before &lt;code&gt;negative&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;include &amp;quot;globals.mzn&amp;quot;; constraint value_precede(XP,XN, directions); constraint value_precede(YP,YN, directions); constraint value_precede(ZP,ZN, directions); constraint value_precede_chain([XP,YP,ZP], directions); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;These constraints fully-characterize our precedence rules. Running in MiniZinc, we still get a solution, and now even Gecode can prove exhaustiveness (the line with &lt;code&gt;====&lt;/code&gt; of a single under four seconds).&lt;/p&gt; &lt;pre&gt;&lt;code&gt;positions = array1d(1..27, [1, 2, 3, 6, 9, 8, 7, 16, 25, 26, 17, 18, 15, 12, 11, 10, 19, 22, 13, 4, 5, 14, 23, 20, 21, 24, 27]); directions = array1d(1..17, [XP, YP, XN, ZP, XP, ZN, XP, YN, XN, ZP, YP, ZN, XP, ZP, YN, XP, YP]); ---------- ========== &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;One reason why I may have failed at following my first solution is that the output is a bit austere. The output of &lt;code&gt;directions&lt;/code&gt; actually is more exploitable as it reads as folding instructions, we immediately see that the first three &lt;code&gt;SEGMENT&lt;/code&gt; form a U-shape. Elided for brevity: it is actually possible to ask MiniZinc customize the output via a rendering function. Also, with some extra fiddling I managed to have Gecode prove exhaustiveness in under 100ms (this is yet another advanced technique I may cover in a separate blog post).&lt;/p&gt; &lt;p&gt;Somehow, finding a single solution, and proving that I am not able to follow instructions, is a nice conclusion to conclude this story &lt;span class="emoji" data-emoji="book"&gt;📖&lt;/span&gt;.&lt;/p&gt; &lt;h1 id="summary-and-discussion"&gt;Summary and Discussion&lt;/h1&gt; &lt;p&gt;We have formalized the problem of the Snake-Cube, solved it, and proved the solution unique. Proving the solution unique means that we pretty much have a complete characterization of the Snake-Cube puzzle. And to recap, our model formalizes the Snake-Cube puzzle as follows:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;CUBE&lt;/code&gt;, &lt;code&gt;SEGMENT&lt;/code&gt;, &lt;code&gt;POS&lt;/code&gt;, &lt;code&gt;DIR&lt;/code&gt; are key entities that need well-defined names &lt;/li&gt; &lt;li&gt;the snake consists of a series of &lt;code&gt;CUBE&lt;/code&gt;, each consecutive line of &lt;code&gt;CUBE&lt;/code&gt; defines a &lt;code&gt;SEGMENT&lt;/code&gt; &lt;/li&gt; &lt;li&gt;&lt;code&gt;POS&lt;/code&gt; provide coordinates to all final positions of &lt;code&gt;CUBE&lt;/code&gt; in each of the x, y, and z dimensions of the 3x3x3 folded-cube &lt;/li&gt; &lt;li&gt;the problem is an &lt;em&gt;attribution problem&lt;/em&gt;, in which each &lt;code&gt;CUBE&lt;/code&gt; is given a &lt;code&gt;POS&lt;/code&gt;, thus we can use the &lt;code&gt;all_different&lt;/code&gt; &lt;em&gt;global&lt;/em&gt; constraint to efficiently capture this property &lt;/li&gt; &lt;li&gt;physical constraints of &lt;code&gt;straight&lt;/code&gt;-lines and &lt;code&gt;corners&lt;/code&gt; impose a relationship between the coordinates of the positioned &lt;code&gt;CUBE&lt;/code&gt; of a same &lt;code&gt;SEGMENT&lt;/code&gt; &lt;/li&gt; &lt;li&gt;we used &lt;em&gt;predicates&lt;/em&gt; to re-use a good chunk of the domain logic when encoding &lt;code&gt;straight&lt;/code&gt; &lt;/li&gt; &lt;li&gt;we took some shortcuts eliding the &lt;code&gt;corners&lt;/code&gt; rule because we recognized that the minimal length for a &lt;code&gt;SEGMENT&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt; and the maximum extent for the folded-cube is &lt;code&gt;3&lt;/code&gt;, thus we do not really need to force consecutive &lt;code&gt;SEGMENTs&lt;/code&gt; to turn around &lt;/li&gt; &lt;li&gt;we broke rotational and mirroring &lt;em&gt;symmetries&lt;/em&gt; with the &lt;code&gt;value_precede&lt;/code&gt; global constraints, allowing to convince oneself only one solution to this Snake-Cube puzzle exists &lt;/li&gt; &lt;li&gt;I am not especially good at following mechanical output instructions &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The article is already a bit long and we could discuss a number of other techniques such as &lt;em&gt;channeling&lt;/em&gt;, observing how different &lt;em&gt;families of solvers&lt;/em&gt; fare in this problem, or modifying the &lt;em&gt;search strategy&lt;/em&gt;. We could also decide to complexify the model for the puzzle on purpose (e.g., support a &lt;code&gt;4x4x4&lt;/code&gt; cube as well). Rather, we’ll cut it short and may leave these advanced topics for another blog post. That said, before concluding I cannot resist to ask you a question for thought: Is &lt;code&gt;POS&lt;/code&gt; really required? it is an interesting question because &lt;code&gt;POS&lt;/code&gt; is merely and indirection that adds more typing work to get from a &lt;code&gt;CUBE&lt;/code&gt; to a set of coordinates.&lt;/p&gt; &lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt; &lt;p&gt;We can solve real-world and business-critical problems in MiniZinc. Although the Snake-Case, is not as complicated as a real-world models where constraint-programming can really shine, this puzzle is a good illustration of how to solve problems using constraint-programming: it is not immediately obvious how to formalize and to formulate the puzzle into a computer program.&lt;/p&gt; &lt;p&gt;Constraint-programming is declarative: we state a problem and let the solver grind through solutions for us. You can thus answer questions more succinctly, sometimes constraint programming allow you to reach further and find solutions to problem that would be unattainable or impractical in your typical programming style. Since the Snake-Cube has a single solution we cannot really add interesting rules to spice the game, but real-world is full of examples where an off-the-shelf algorithm does not work because of some extra constraint (e.g., a shortest-path with road-closures time tables). In short, I believe MiniZinc and Constraint-Programming are extremely-valuable tools. Although it requires a high personal investment to learn MiniZinc, the application of the skill has high value-for-the-cost.&lt;/p&gt; &lt;p&gt;We could have stopped at the first iteration of the solver, before discussing symmetries (and in many contexts stopping at this solution could have been sufficient). However I think it is important to show that we can, and sometimes are forced, to go further deep in the understanding of the problem.&lt;/p&gt; &lt;p&gt;I typically build models iteratively as shown in this blog-post. However, from experience, there is little continuity between having no solutions, a useless solution, being swamped with solutions, and finding the one and only correct solution. There also are vastly more interesting modeling perspectives than you have time for. Thus it is key to know when to stop and you must know how to convince yourself that your overall model and solving strategy are good enough.&lt;/p&gt; &lt;p&gt;I believe these characteristics are shared among all declarative systems (e.g., SQLs, Prologs, and DataLogs, but also devop tools like Terraform) &lt;em&gt;because&lt;/em&gt; we explicitly forfeit control to a black-box in exchange for extra reach. I like to say that these tools are evil genies, they will answer you wishes but you must be careful when articulating your wish. To overcome this downside of declarative style, you need knowledge and practice. In particular, you need a good capacity at abstracting away so that you can recognize familiar problems in some ad-hoc problem that life has thrown at us. And then you need to be able to activate the many knobs in a rich toolbox like MiniZinc.&lt;/p&gt; &lt;p&gt;If you are interested or want to apply these techniques and feel overwhelmed or lost, please reach-out.&lt;/p&gt; &lt;h2 id="links"&gt;Links&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://www.minizinc.org"&gt;MiniZinc&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Snake_cube"&gt;Snake Cube on Wikipedia&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/lucasdicioccio/snakecube"&gt;My solution on GitHub&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/snake-cube.html" rel="alternate"/>
        <summary type="text">
            We solve a simple wooden puzzle with MiniZinc. The Snake-Cube puzzle is a good introductory problem and thus a number of formal modeling techniques are explained. We also touch advanced topic like symmetries and discuss a bit our modeling choices.
        </summary>
    </entry>
</feed>
