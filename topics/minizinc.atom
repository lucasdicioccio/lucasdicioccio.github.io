<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title type="text">
        Lucas DiCioccio's blog
    </title>
    <id>
        https://dicioccio.fr/atom.xml
    </id>
    <updated>
        2022-02-09T21:50:00Z
    </updated>
    <entry>
        <id>
            https://dicioccio.fr/optimal-lab-samples-spreading.html
        </id>
        <title type="text">
            Optimal Lab Samples Spreading
        </title>
        <updated>
            2022-02-09T21:50:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;This article illustrates what the work of modeling a problem for constraint &lt;a href="/hashtags/optimization.html"&gt;&lt;span class="hashtag" data-hashtag="optimization"&gt;#optimization&lt;/span&gt;&lt;/a&gt; entails.&lt;/p&gt; &lt;h1 id="a-problem-with-a-vague-description"&gt;A &lt;a href="/hashtags/problem.html"&gt;&lt;span class="hashtag" data-hashtag="problem"&gt;#problem&lt;/span&gt;&lt;/a&gt; with a vague description&lt;/h1&gt; &lt;p&gt;Unless you‚Äôve been living under a rock, you are aware that the COVID19 pandemic happened and is still ongoing. One thing that has become common at least in rich countries is the frequent tests we need to perform to validate whether a person is infected or not. A variety of test technologies have different characteristics, some tests can be done at home (rapid anti-genic tests). Whereas PCR tests need a specific person to carry the &lt;em&gt;sample&lt;/em&gt; then the samples are sent to a &lt;em&gt;laboratory&lt;/em&gt; that processes the PCR check.&lt;/p&gt; &lt;p&gt;Now let‚Äôs say there is some imbalance between PCR-check laboratories and some tests sites. A question that may arise is: how do we best allocate samples from various sampling &lt;em&gt;locations&lt;/em&gt; (e.g., pharmacies) to laboratories? There is some delay in sending tests to laboratories, and also there is a maximum delay to wait for a sample (otherwise the sample deteriorates and can no longer provide good material for the test). What do we do for a day, over a week?&lt;/p&gt; &lt;h1 id="an-off-the-shelf-model"&gt;An off-the-shelf model&lt;/h1&gt; &lt;p&gt;Before using a modeling approach solver, it‚Äôs always good to verify whether the problem has an easy-to-recognize shape. This instance looks like an &lt;a href="https://en.wikipedia.org/wiki/Maximum_flow_problem"&gt;max-flow problem&lt;/a&gt; where testing locations are sources and laboratories are samples: indeed maximizing the number of samples that go through testing is a way to minize those which are thrown out.&lt;/p&gt; &lt;p&gt;The following example shows a possible max-flow &lt;a href="/hashtags/model.html"&gt;&lt;span class="hashtag" data-hashtag="model"&gt;#model&lt;/span&gt;&lt;/a&gt; to this problem. On the left you have a fictional &lt;code&gt;demand&lt;/code&gt; node and on the right a fictional &lt;code&gt;processed&lt;/code&gt; node. The &lt;code&gt;from&lt;/code&gt; arrows are capacities which corresponds to the demand at each sample-collection location. The symmetric side of processing- capacities are &lt;code&gt;to&lt;/code&gt; arrows. The center arrows with &lt;code&gt;?&lt;/code&gt; are the attribution matrix. We could force some capacities to zero to say a sample-location is too far from a certain site, or leave them infinite to express that any amount of samples can be sent.&lt;/p&gt; &lt;p&gt;&lt;img src="/gen/images/labspread-maxflow.dot.png" alt="max-flow illustration" /&gt;&lt;/p&gt; &lt;p&gt;Running max-flow on this graph would determine how to maximize the number of processed samples. And the actual-values achieved the &lt;code&gt;?&lt;/code&gt; arrows correspond to a best assignment.&lt;/p&gt; &lt;p&gt;This is all good but in real-life we need to consider multiple days and other constraints. The iterated aspects may be annoying to model but somewhat manageable. For instance, we could add staged sources and sinks where some capacity connects a laboratory at two time intervals (this way &lt;em&gt;leftovers&lt;/em&gt; can be post-poned as additional inputs). In the following picture, we add a suffix &lt;code&gt;_0&lt;/code&gt; and &lt;code&gt;_1&lt;/code&gt; to represent the different stages. Thus an arrow &lt;code&gt;lab1_0 -&amp;gt; lab1_1&lt;/code&gt; represents leftovers at &lt;code&gt;lab1&lt;/code&gt; from the first staged processed in the second stage. We could view these arrows across stages as a degenerate form of sending samples between two different places in the time dimension.&lt;/p&gt; &lt;p&gt;&lt;img src="/gen/images/labspread-maxflow-iterated.dot.png" alt="max-flow illustration" /&gt;&lt;/p&gt; &lt;p&gt;Such a model starts to be slightly more cumbersome than the previous one, and also is &lt;em&gt;wrong&lt;/em&gt; because we do not properly model the deadline component. For instance, with many stages we could have a long chain of leftover samples until all samples are processed, irrespective from how old the samples are. Instead of having &lt;code&gt;leftovers&lt;/code&gt; from labs to labs at future time-steps, we rather need the &lt;code&gt;leftover&lt;/code&gt; arrows to go from sampling location to lab at future time-steps. Correcting for this fact we get the following schema:&lt;/p&gt; &lt;p&gt;&lt;img src="/gen/images/labspread-maxflow-iterated2.dot.png" alt="max-flow illustration" /&gt;&lt;/p&gt; &lt;p&gt;This model now seems correct and useful. However, in real-world setups we often refine models as new constraints are discovered or as new decisions are required. For instance, one behavior that would significantly alter the model would be to limit sampling sites to send samples to at most two labs. We may have to scrap our solution because the max-flow algorithm is not ‚Äúcut‚Äù to make choices between alternatives (what we need is a form of knapsack at each sample-collection location). Such situations are common, and they correspond to situations where constraint-programming modeling shines. Constraint programming will let you trade generality for performance (i.e., we expect a slow down by using a more-general approach). Other situations where the adaptability of constraint-programming is useful is to probe what happens when a constraint actually turns-out to be a secondary goal (i.e., we relax a hard constraint into a soft-constraint and pretend we are geniuses).&lt;/p&gt; &lt;p&gt;Enough introduction, let‚Äôs see how we could formulate the problem in a constraint-programming language (using &lt;a href="https://minizinc.org/"&gt;MiniZinc&lt;/a&gt; as usual on this blog).&lt;/p&gt; &lt;h1 id="a-constraint-programming-model"&gt;A constraint-programming model&lt;/h1&gt; &lt;p&gt;Remember that to model a constraint-programming problem we need to formulate what are &lt;em&gt;inputs&lt;/em&gt;, &lt;em&gt;decisions&lt;/em&gt;, and &lt;em&gt;constraints&lt;/em&gt;. We also need some form of &lt;em&gt;objective&lt;/em&gt;.&lt;/p&gt; &lt;h2 id="high-level-model"&gt;high-level model&lt;/h2&gt; &lt;p&gt;We will assume that we have some time-based model of the demand in number of tests. We also assume that we know the labs capacities (this is no different from our introductory model).&lt;/p&gt; &lt;p&gt;In our case, a good starting point would be:&lt;/p&gt; &lt;p&gt;&lt;strong&gt;inputs&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;demand for samples from sample-collection locations &lt;/li&gt; &lt;li&gt;PCR lab capacities &lt;/li&gt; &lt;li&gt;some measure of the time it takes to send samples from one testing-site to a lab &lt;/li&gt; &lt;li&gt;the duration for which a sample is valid &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;decisions&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;some assignment from testing-sites to labs &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;constraints&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;samples must be processed within their lifetime or will be wasted &lt;/li&gt; &lt;li&gt;labs total work cannot overshoot their capacity &lt;/li&gt; &lt;li&gt;some form of &lt;strong&gt;conservation law&lt;/strong&gt; to say that samples are either tested in time or thrown away &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;objective&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;minimize the number of samples thrown away otherwise you can always assign zero from any testing-site to any lab &lt;/li&gt; &lt;/ul&gt; &lt;h2 id="formalized-in-minizinc"&gt;formalized in MiniZinc&lt;/h2&gt; &lt;p&gt;The core of the model would be something as follows:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;int: nLab; int: nZone; int: nTime; int: sample_lifetime; set of int: LAB = 1..nLab; set of int: ZONE = 1..nZone; set of int: TIME = 1..nTime; set of int: DELAY = 0..sample_lifetime; % demand of samples produced by zones array[ZONE,TIME] of int: demand; % capacity of labs to process samples, may vary with time to model things like week-ends array[LAB] of int: capacity; % transit represents a delay from one zone to some lab array[ZONE,LAB] of int: transit; % decisions about routing samples: dispatching and dropping samples int: maxAttr = sum(z in ZONE, t in TIME)(demand[z,t]); array[ZONE,LAB,TIME,DELAY] of var 0..maxAttr: dispatch; array[ZONE,TIME] of var 0..maxAttr: dropped; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Which introduces the inputs and the key decisions. We name &lt;code&gt;ZONE&lt;/code&gt; the set of sampling-locations because we could aggregate locations into zones beforehand, but also because we I found it hard to juggle with &lt;code&gt;LAB&lt;/code&gt; and &lt;code&gt;LOC&lt;/code&gt; all the time in my mind.&lt;/p&gt; &lt;p&gt;More importantly, we refined the decision to explicitly add a &lt;code&gt;DELAY&lt;/code&gt; component to the &lt;code&gt;dispatch&lt;/code&gt;-ed amount from a given ZONE to a given LAB at a given TIME. This delay corresponds to the dashed arrows we introduced in the max-flow model before. This extra breakdown is not especially surprising because we need to model the same ‚Äúallowed physical behavior‚Äù whatever modeling technique we use. That said, in this model we went a bit further and we have broken down the total delay into two components: transit times (which are imposed by the &lt;code&gt;transit&lt;/code&gt; matrix) and queuing time (i.e., if a lab is busy one day but as spare capacity the next day we can backlog). The framing is very similar but are being a bit more explicit which chunk of the delay is forced upon us versus what chunk of the delay is a proper decision: this break down is important if you were to iterate on the model, or decide to increase capacity.&lt;/p&gt; &lt;p&gt;We also have a separate explicit &lt;code&gt;dropped&lt;/code&gt; decision, for all the samples that we cannot process. This decision is new compared to the max-flow model because in the max-flow model dropped quantities are implicit: dropped quantities correspond to amount of demand flow under the attributed capacity. In constraint-programming it is somewhat required to be explicit otherwise the solver will typically find an ‚Äúuninteresting‚Äù solution (e.g., deciding that we drop everything implicitly because we have no way to express the conservation law).&lt;/p&gt; &lt;p&gt;Visually I represented this model as follows, in case it helps (demand at different times for a given zone are on the left, load for a given lab is the right). &lt;img src="/images/labspread-study.png" alt="sketch of model" /&gt;&lt;/p&gt; &lt;p&gt;We still need to link everything with constraints and write the objective function.&lt;/p&gt; &lt;h3 id="conservation-law"&gt;conservation law&lt;/h3&gt; &lt;p&gt;The conservation-law is not too complicated: at any given TIME, the demand is partitioned in two sets: dropped quantities and dispatched quantities.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;% must dispatch all demand constraint forall(z in ZONE, t in TIME) (demand[z,t] - dropped[z,t] = sum(l in LAB, d in DELAY)( dispatch[z,l,t,d] )); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Such conservation laws are often ‚Äúhidden‚Äù behind inequalities. In this case I initially had a inequality saying that the dispatched amount had to be below the demand, it took me some time to realize that what is leftover deserves a concept in its own. Then, the conservation law appeared and it became easier to reason and debug with this extra ‚Äòdropped‚Äô variable.&lt;/p&gt; &lt;h3 id="samples-must-reach-a-lab-and-be-processed-within-their-lifetime"&gt;samples must reach a lab and be processed within their lifetime&lt;/h3&gt; &lt;p&gt;Here we are using some &lt;em&gt;implication&lt;/em&gt; connective that says that if the transit time and the considered queuing delay exceeds the sample lifetime, then the dispatched amount for this zone, lab, and delay has to be zero.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;% cannot delay (including transit time) past sample_lifetime constraint forall(z in ZONE, l in LAB, t in TIME, d in DELAY) ((transit[z,l] + d &amp;gt; sample_lifetime) -&amp;gt; dispatch[z,l,t,d] = 0); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This formal statement is worth reading at a slow pace because the formalism is not really a natural way of thinking. What makes such statements hard to parse is that we initially said that we want samples to be processed within their lifetime (i.e., we want a desired outcome to happen) whereas the statement speaks about preventing dispatching (i.e., we prevent the inverse of the desired outcome). I do not claim that it is impossible to reverse the logic, but I found no trivial ways to do so without introducing new variables.&lt;/p&gt; &lt;p&gt;Combined with the conservation law, this constraint will force undispatcheable quantities to move to the dropped quantity.&lt;/p&gt; &lt;h3 id="load-versus-capacity-at-lab"&gt;load versus capacity at LAB&lt;/h3&gt; &lt;p&gt;We need some way to prevent LABs overload. For this we need a definition of load of a LAB at a given time. This load consists of the dispatched amounts (including transit costs and backlog-delays).&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;% helper: workload processed by a lab at a given time (includes delayed dispatches) array[LAB,TIME] of var int: load; constraint forall(l in LAB, t_load in TIME) ( load[l,t_load] = sum(t_route in t_load-sample_lifetime..t_load where t_route &amp;gt; 0, z in ZONE) (dispatch[z,l,t_route,t_load-t_route]) ); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;It takes some work to sum all the right terms, but once we have the load at a given time, the constraint becomes trivial.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;% cannot overload labs constraint forall(l in LAB, t in TIME) (capacity[l] &amp;gt;= load[l,t]); &lt;/code&gt;&lt;/pre&gt; &lt;h3 id="objective-no-waste"&gt;objective: no waste&lt;/h3&gt; &lt;p&gt;This probably is the easiest part of the work. We sum the total dropped amounts and minimize this.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;var int: total_drop = sum(array1d(dropped)); solve minimize total_drop; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Overall, this objective combined with the conservation law gives some intuition about what a performing heuristic could look like: starting by dispatching zero we try to attribute fill labs with from closest zones in total delay. Fortunately, we do not need to write a heuristic and can just run our MiniZinc model.&lt;/p&gt; &lt;h2 id="running-the-model"&gt;Running the model&lt;/h2&gt; &lt;p&gt;You will find my model, some example data and even some synthetic-data generator written with a simple Ruby script at &lt;a href="https://github.com/lucasdicioccio/labspread"&gt;one of my GitHub repos&lt;/a&gt; .&lt;/p&gt; &lt;p&gt;The final model has one modification (see below) but also a slightly different output format than you get by default with MiniZinc (hopefully it‚Äôs more readable).&lt;/p&gt; &lt;p&gt;An example simple input that allows to understand what happens is a data file like the following:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;nLab = 3; nZone = 2; nTime = 5; sample_lifetime = 0; capacity = [|1,1,1,1,1 |1,1,1,1,1 |1,1,1,1,1 |]; transit = [|0,0,0 |0,0,0 |]; demand = [|1,1,2,0,10 |1,0,0,2,0 |]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In this data input, we see that there is uniform capacity of &lt;code&gt;1&lt;/code&gt; for tree labs. There is no transit delay, however the lifetime of samples is zero (i.e., we cannot backlog samples). The demand fluctuates at two sample-collection zones and overloads the total capacity at the end (we reach &lt;code&gt;10&lt;/code&gt;, otherwise we only use &lt;code&gt;2&lt;/code&gt;). Here it‚Äôs pretty clear that we expect to be able to serve the demand except for &lt;code&gt;7&lt;/code&gt; samples at the last time slot.&lt;/p&gt; &lt;p&gt;If we run the model from GitHub we get some textual output:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;(...truncated by me...) t=4 demand=2 capacity=3 drop=0 sent=(1-&amp;gt;1,0) (1-&amp;gt;2,0) (1-&amp;gt;3,0) (2-&amp;gt;1,1) (2-&amp;gt;2,1) (2-&amp;gt;3,0) load=(1,1)(2,1)(3,0) t=5 demand=10 capacity=3 drop=7 sent=(1-&amp;gt;1,1) (1-&amp;gt;2,1) (1-&amp;gt;3,1) (2-&amp;gt;1,0) (2-&amp;gt;2,0) (2-&amp;gt;3,0) load=(1,1)(2,1)(3,1) total_drop = 7 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We see that the we indeed drop &lt;code&gt;7&lt;/code&gt; in the last time slot but we never lost samples before. All is good. One can then play around starting from the data file and have fun changing parameters. For instance, allowing some extra lifetime, adding transit, and increasing the total demand. We can arrive at situations where backlogging is required.&lt;/p&gt; &lt;p&gt;With this input for instance,&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;nLab = 3; nZone = 2; nTime = 5; sample_lifetime = 2; capacity = [|1,1,1,1,1 |1,1,1,1,1 |1,1,1,1,1 |]; transit = [|0,1,2 |2,1,0 |]; demand = [|4,3,2,0,10 |3,0,10,2,0 |]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The capacity is still &lt;code&gt;3&lt;/code&gt; per day but the demand regularly overshoots (but not always). The full ‚Äúbest‚Äù solution for this problem becomes:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;t=1 demand=7 capacity=3 drop=1 sent=(1-&amp;gt;1,2) (1-&amp;gt;2,1) (1-&amp;gt;3,0) (2-&amp;gt;1,0) (2-&amp;gt;2,1) (2-&amp;gt;3,2) load=(1,1)(2,1)(3,1) t=2 demand=3 capacity=3 drop=1 sent=(1-&amp;gt;1,1) (1-&amp;gt;2,0) (1-&amp;gt;3,1) (2-&amp;gt;1,0) (2-&amp;gt;2,0) (2-&amp;gt;3,0) load=(1,1)(2,1)(3,1) t=3 demand=12 capacity=3 drop=6 sent=(1-&amp;gt;1,2) (1-&amp;gt;2,0) (1-&amp;gt;3,0) (2-&amp;gt;1,0) (2-&amp;gt;2,2) (2-&amp;gt;3,2) load=(1,1)(2,1)(3,1) t=4 demand=2 capacity=3 drop=0 sent=(1-&amp;gt;1,0) (1-&amp;gt;2,0) (1-&amp;gt;3,0) (2-&amp;gt;1,0) (2-&amp;gt;2,1) (2-&amp;gt;3,1) load=(1,1)(2,1)(3,1) t=5 demand=10 capacity=3 drop=0 sent=(1-&amp;gt;1,10) (1-&amp;gt;2,0) (1-&amp;gt;3,0) (2-&amp;gt;1,0) (2-&amp;gt;2,0) (2-&amp;gt;3,0) load=(1,1)(2,1)(3,1) total_drop = 8 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;sent&lt;/code&gt; lines correspond to the &lt;code&gt;dispatch&lt;/code&gt; matrix, with the following syntax &lt;code&gt;($zone-&amp;gt;$lab, $quantity)&lt;/code&gt;. We notice some underwhelming fact: when the demand overloads the capacity, labs are working at full-capacity. This realization is pretty important because in general there is not a large amount of wiggle-room to fix a capacity issue with scheduling &lt;strong&gt;to fix the capacity issue, increase capacity or drop the demand&lt;/strong&gt;; this rule of thumb is even more true when lifetimes are short compared to how fast you can increase capacities. This model allows to play with parameters and ‚Äúsee‚Äù how this teaching is true. For the story: I wanted to convey this information to the person working for the NHS who asked me about what we could do to help face the crisis; you are facing an fast-growing phenomenon and soon your capacity will be maxed-out. Thus, there will be no gain in being smart, better provide tools to get good visibility and efficient handling, which can play a role in increasing capacity.&lt;/p&gt; &lt;h2 id="avenues-for-modifications"&gt;Avenues for modifications&lt;/h2&gt; &lt;p&gt;It‚Äôs always important to step back and see how we could change the model. I do not want to use the word &lt;em&gt;improve&lt;/em&gt; the model because we actually build different models. Indeed: a simple model also requires less input data (which may not be easy to collect), and less testing/debugging work.&lt;/p&gt; &lt;p&gt;We provide a series of modifications that one may want to apply and discuss how we could adapt (or not) the model. The easy-changes have snippets of code to see how the constraint-programming approach is beneficial.&lt;/p&gt; &lt;h3 id="more-time-varying-variables"&gt;More time-varying variables&lt;/h3&gt; &lt;p&gt;Lab capacities are given as a fixed value. However we could easily modify the lab capacities to be known time-varying values. Such a change could allow to model the effect of opening/closing some labs for WE breaks. The change here is pretty limited, we would introduce a &lt;code&gt;TIME&lt;/code&gt; component to the capacity and use it in the adequate constraint:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;array[LAB,TIME] of int: capacity; % cannot overload labs constraint forall(l in LAB, t in TIME) (capacity[l,t] &amp;gt;= load[l,t]); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Such a model is the one I actually implemented first. The time-varying aspect of the capacity is not key in the structure of the problem (i.e., we do not change the number nor the shape of constraints, we merely change the bounds the load can take). Hence, it did not cost me much more to add.&lt;/p&gt; &lt;h3 id="more-physically-correct-model-of-test-performance"&gt;More physically-correct model of test-performance&lt;/h3&gt; &lt;p&gt;The quality of tests may deteriorate with the delay: in current model the ‚Äòvalue‚Äô of a test is implicitly binary: we get either 1 valid sample before the deadline or 0 past the deadline. We could imagine a different function with a smoother decrease in performance. Such a behavior could also help in providing different qualities or different deadlines depending on the sample-collection sites or the laboratories (e.g., because they use different sampling techniques or material).&lt;/p&gt; &lt;p&gt;For instance, if we attribute some dispatch value that decreases with the DELAY, we could use such an objective (turned into a maximization here).&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;var int: w = sum(z in ZONE, l in LAB, t in TIME, d in DELAY)(dispatch[z,l,t,d] * (sample_lifetime-d)); solve maximize w; &lt;/code&gt;&lt;/pre&gt; &lt;h3 id="varying-processing-costs-at-laboratories"&gt;Varying processing costs at laboratories&lt;/h3&gt; &lt;p&gt;We can imagine that the network of laboratories may process various samples at different costs. The cost function could take into account a different price depending on the LAB. The cost function could even be non-linear with some base-rate and an overshoot cost (it‚Äôs a way to relax moderately the capacity constraint). Such extra cost-modeling would lead the optimization to fill in cheapest LABs first in a ‚Äúwater-filling‚Äù approach (starting from the cheapest LAB reachable from a given ZONE until the LAB is no longer the cheapest alternative etc.).&lt;/p&gt; &lt;p&gt;We could do something like this:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;var int: w = sum(l in LAB, t in TIME)(processing_cost(l, load[l,t])); solve minimize w + drop_cost * total_drop; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Given a &lt;code&gt;processing_cost&lt;/code&gt; function mapping LABs and loads to a numerical cost we can incorporate the processing cost into the objective. Care as to be taken to still take into account the &lt;code&gt;total_drop&lt;/code&gt; amount and weight it accordingly to the processing_cost (otherwise the solver will cynically figure out that dropping every samples incurs no cost).&lt;/p&gt; &lt;h3 id="more-faithful-representation-of-probabilities"&gt;More faithful representation of probabilities&lt;/h3&gt; &lt;p&gt;Actual demand in test is pretty unknown: using stochastic programming could help having more acceptable results (a typical implementation is to discretize the probability distribution, another one is to produce a large amount of simulated scenarios). The change requires to provide a discretized weighed probability of input demand values instead of one demand value per time step and average over scenarios. I find hard to stay within the constraint-programming model framework for this problem because a constraint-programming model decides once what are the action taken at every future time step. In such a situation, where you believe you need to go all the way to model stochastic behaviors you may as well spend the efforts to model how successive choices can take advantage of the facts that become known as the time passes. Here you may want to reach for bigger guns like &lt;a href="https://www.mit.edu/~dimitrib/Dynamic_Prog_Videos.html"&gt;optimal-control and reinforcement learning&lt;/a&gt; theory (here, a single-stage CP could be a rollout-heuristic ‚Äì but we are eyeing on state-of-the-art topics rather than on a humble blog post).&lt;/p&gt; &lt;h3 id="more-business-constraints"&gt;More business constraints&lt;/h3&gt; &lt;p&gt;As provided in the introduction. A reason to avoid spending too much time in using an off-the-shelf algorithm can be a simple business-rule such as ‚Äúa testing site can ship at most twice per day‚Äù, which would mean our optimization no-longer looks like a well-studied &lt;em&gt;max-flow&lt;/em&gt; problem. Rather, this real-world problem becomes flavored with a bit of bin-packing because we cannot pick all the variables of the output attribution matrix independently from each other.&lt;/p&gt; &lt;p&gt;Building such a constraint is non-trivial because you need an array of auxiliary variables telling how many LABs a ZONE serves at a given TIME (irrespective of the DELAY). Say you get a &lt;code&gt;sent&lt;/code&gt; array. Then force the cardinality of zeros with a &lt;a href="https://www.minizinc.org/doc-2.5.5/en/lib-globals.html#counting-constraints"&gt;global counting constraint&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;That said, the overall constraint is not that complicated to write.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;% helper: work sent from zone to a lab at a given time (whichever delay is dispatched) array[ZONE,LAB,TIME] of var 0..maxAttr: sent; constraint forall(l in LAB, z in ZONE, t in TIME) (sent[z,l,t] = sum(d in DELAY)(dispatch[z,l,t,d])); % max two sent int: maxShipment = 2; include &amp;quot;globals.mzn&amp;quot;; constraint forall(t in TIME, z in ZONE)( count([sent[z,l,t]|l in LAB],0) &amp;gt;= nLab-maxShipment ); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In that case, switching the solver type may significantly alter performance. It would be useful to force ourselves to model this problem as a mixed-integer-linear-programming problem, but that would become rather complicated if you combine these alterations to the initial problem.&lt;/p&gt; &lt;/section&gt;&lt;section class="main-section"&gt;&lt;h1 id="closing-remarks"&gt;Closing remarks&lt;/h1&gt; &lt;p&gt;Before starting modeling the problem with a constraint-programming language, let‚Äôs keep in mind that we should always do the work of trying to apply an off-the-shelf but under-constrained algorithm: sometimes it works (i.e., you are lucky that the solution actually fits the extra constraints), sometimes you get a perspective that is useful for the problem (e.g., here we re-used the idea of &lt;em&gt;leftovers&lt;/em&gt;), and at worst you can also use an ‚Äúunder-constrained‚Äù solution to get a approximation or an higher-bound to accept/reject some alternative (e.g., you have two alternatives situations you could reject one alternative because we cannot expect an optimal solution to beat the average of the other alternative).&lt;/p&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/optimal-lab-samples-spreading.html" rel="alternate"/>
        <summary type="text">
            An illustration of how to model a constraint-problem to optimally distribute testing samples to laboratories.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/snake-cube.html
        </id>
        <title type="text">
            Solving the Snake Cube puzzle
        </title>
        <updated>
            2022-01-01T12:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;In 2021, Santa brought me this puzzle: &lt;img src="images/snake-cube-unfolded.jpeg" alt="an unfolded Snake-Cube" /&gt; This is sometimes named the ‚ÄúSnake-Cube‚Äù because the device looks like a snake &lt;span class="emoji" data-emoji="snake"&gt;üêç&lt;/span&gt; when unfolded. The goal of this game is to fold it into a cube &lt;span class="emoji" data-emoji="package"&gt;üì¶&lt;/span&gt; like this. &lt;img src="images/snake-cube-folded.jpeg" alt="a folded snake cube" /&gt; The device is built with cubes that are drilled across some faces so that a strap runs trough cubes like beads. Cubes thus have some degree of freedom to rotate around the strap. Overall, two cubes are terminal and the other ones then either are straight or corners depending on the shape of hole. Whether you can visualize how ‚Äúit works‚Äù or not, you should definitely check this link can give you an appreciation of the &lt;a href="https://woodgears.ca/puzzles/snake_cube.html"&gt;craft behind a wooden Snake Cube&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;After solving the Snake-Cube by hand, the puzzle started pinching my interest. I could imagine a procedure to invent ‚Äúnew‚Äù Snake-Cube puzzles (by drawing a path that fills the cube in 3D, a common graph-theory problem) but I wanted to convince myself: is there only one solution? Can I make a program to solve the Snake-Cube automatically and somewhat efficiently? I decided to give it a try with &lt;a href="https://www.minizinc.org/"&gt;MiniZinc&lt;/a&gt;, a &lt;em&gt;constraint programming&lt;/em&gt; toolbox. This article is an introduction to MiniZinc and illustrates how one can solve real-world problem with MiniZinc. We explain basic formal modeling techniques and touch on some advanced topics as well. No prior knowledge of MiniZinc is required although we will not run you through the menus of the IDE before showing screenshots.&lt;/p&gt; &lt;h1 id="a-minizinc-model"&gt;A MiniZinc model&lt;/h1&gt; &lt;p&gt;MiniZinc is a language for finite-search discrete programming. These complicated words mean that you get to declaratively specify, in a restricted formal language, what the characteristics of your problem are. A key restriction is that all variables are known and have a finite number of possible states. This restriction is not really a limitation in our case. A computer program then ingests the formal specification and automatically find solutions to the problem, or proves there are none.&lt;/p&gt; &lt;h2 id="basic-formalism-for-the-snake-cube"&gt;Basic formalism for the Snake-Cube&lt;/h2&gt; &lt;p&gt;To solve the Snake-Cube we need to capture interesting properties of the puzzle with &lt;em&gt;variables&lt;/em&gt;. Introducing variables is like &lt;strong&gt;having words to discuss concepts&lt;/strong&gt;. Variables must have a name and a &lt;em&gt;domain&lt;/em&gt; (i.e., a range of allowed values).&lt;/p&gt; &lt;p&gt;For instance, the snake is made of small &lt;em&gt;cubes&lt;/em&gt;. There are 27 (3x3x3) cubes in total. Thus we can give a name to each individual cube in the snake. Since solvers work with numbers, the easiest way is to use numerical names (i.e., indexing of values).&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: CUBE = 1..27; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This MiniZinc statement says that we number each individual cube starting from &lt;code&gt;1 up to 27&lt;/code&gt;. We could have used &lt;code&gt;0..26&lt;/code&gt; or another &lt;em&gt;indexing scheme&lt;/em&gt;. The choice is a matter of preference but sometimes in MiniZinc it is convenient to leave &lt;code&gt;0&lt;/code&gt; as a special index to represent ‚Äòabsence of cube‚Äô.&lt;/p&gt; &lt;p&gt;Another way to imagine the Snake-Cube, rather than focusing on the snake &lt;span class="emoji" data-emoji="snake"&gt;üêç&lt;/span&gt;, let‚Äôs focus on the cube &lt;span class="emoji" data-emoji="package"&gt;üì¶&lt;/span&gt; . Let‚Äôs introduce the concept of &lt;em&gt;folded-cube&lt;/em&gt;, which represents the cube as a collection of 27 slots or &lt;em&gt;positions&lt;/em&gt;. This concept of position allows-us to explain the rules of Snake-Cube. Thus, let‚Äôs give a numerical index to each final position.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: POS = 1..27; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Astute readers may wonder why both &lt;code&gt;CUBE&lt;/code&gt; and &lt;code&gt;POS&lt;/code&gt; are numbered &lt;code&gt;1..27&lt;/code&gt;. The enumeration of values 1 to 27 is merely the representation of integers backing the individual and separate concepts. Another way to put it, is to say that &lt;code&gt;POS&lt;/code&gt; and &lt;code&gt;CUBE&lt;/code&gt; represent two different sets, and hence have different types. Which means that whenever we use a &lt;code&gt;CUBE&lt;/code&gt; in a function or as an array index, we get a MiniZinc compiler warning.&lt;/p&gt; &lt;p&gt;At this point, we have not achieved much yet, but we set up the basics of the problem. We can start recognizing and formulating the puzzle in a more formal way. Goal of the Snake-Cube: we need to &lt;strong&gt;attribute exactly one of the 27 positions to each one of the 27 cubes&lt;/strong&gt;. The new concept here is the &lt;em&gt;assignment&lt;/em&gt;, and we will need to introduce new variables in MiniZinc to be able to speak about the assignment. Further, the &lt;code&gt;POS&lt;/code&gt; and &lt;code&gt;CUBE&lt;/code&gt; concepts are immanent in our problem, there is not much work for MiniZinc, whereas this new concept of assignment is like a guess or a blank that MiniZinc will have to fill-in. We refer to these variables as &lt;em&gt;decision variables&lt;/em&gt; which are annotated with the &lt;code&gt;var&lt;/code&gt; keyword. Since we need to guess one position for each cube, we need as many decision variables as there are cubes. Rather than writing 27 times &lt;code&gt;var POS&lt;/code&gt; , we can bundle these variables in a &lt;em&gt;dimensional arrays&lt;/em&gt;. Like variables, dimension variables must have some initial domain. For instance machine integers, 1..100, or some set introduced beforehand. In our case, for each &lt;code&gt;CUBE&lt;/code&gt; we want a &lt;code&gt;var POS&lt;/code&gt;. So let‚Äôs introduce one array, indexed by &lt;code&gt;CUBE&lt;/code&gt; and containing &lt;code&gt;var POS&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;array[CUBE] of var POS: positions; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Repeating for clarity: this statement says that &lt;code&gt;positions&lt;/code&gt; is an array, which is indexed by &lt;code&gt;CUBE&lt;/code&gt; (i.e., it has one item for each of the 27 cubes) and of which items are positions to be decided.&lt;/p&gt; &lt;p&gt;If we run the solver like this, MiniZinc will happily find a solution (that is, it will be able to determine a concrete &lt;code&gt;POS&lt;/code&gt; for each &lt;code&gt;var POS&lt;/code&gt; in the &lt;code&gt;positions&lt;/code&gt; array &lt;img src="images/snake-cube-mzn-001.png" alt="solution showing all-ones" /&gt;&lt;/p&gt; &lt;p&gt;This screenshot shows an output of MiniZinc in the bottom pane (with our trivial problem model in the top pane). The message roughly said that MiniZinc found a correct assignment so far: every cube is put in the same position. This solution is unsatisfactory for the puzzle, but the reason is obvious: we have not given any ‚Äúrules‚Äù of the Snake-Cube yet.&lt;/p&gt; &lt;h2 id="modeling-the-rules-of-snake-cube"&gt;Modeling the rules of Snake-Cube&lt;/h2&gt; &lt;p&gt;I claim there are two broad set of rules in the Snake-Cube.&lt;/p&gt; &lt;p&gt;On the first hand, some rules &lt;strong&gt;are enforced by physics&lt;/strong&gt;. For instance, cubes cannot overlap in space, corners force a change of direction, the rubber band filing through the cube forces a sort of continuity. On the other hand, other rules are &lt;strong&gt;enforced by our curiosity&lt;/strong&gt;, in the Snake-Cube the fact that the final shape actually is a cube, rather than, say, a L-shape is quite important. Otherwise, Snake-Cube would not be a puzzle but a mere toy to hammer things and make noise.&lt;/p&gt; &lt;p&gt;Encoding such rules into a model requires some process to &lt;strong&gt;express a vague intention&lt;/strong&gt; of a high-level statement ‚Äì like the rules I stated above ‚Äì &lt;strong&gt;into some given formalism&lt;/strong&gt;. Such a translation takes some practice, but you do not have to be intimidated. I would say that the formulating a constraint-programming problem has some similarities with formulating complicated SQL queries given an imprecise business requirement: you need to take care of NULLs, whether a RIGHT or LEFT join and all these sorts of things that can ruin the validity or the performance of the query.&lt;/p&gt; &lt;p&gt;The MiniZinc formalism, is built around a set of &lt;em&gt;constraints&lt;/em&gt; statements with a small set of basic logic introduction rules rules (equality, negation, inequalities, connectives: roughly what you get in &lt;a href="https://en.wikipedia.org/wiki/First-order_logic"&gt;predicate logic&lt;/a&gt;). Constraints add some coupling between variables, and allow the solver to perform some reasoning to shrink the domain of decision variables via a series of deductions. For instance, if you must guess a number between 1 to 10 but you learn that doubling this number is at least 16, then you can reduce the choice to 8, 9, or 10. In a proper business setup 16 could represent a target number of sales and the guess could represent the amount to spend on advertisement. In this example you would try to find the least amount to spend that still hit the target. In more involved examples, the target 16 could instead also be a decision variable in relationship with other commitments (i.e., there are more indirect coupling between two sets of decisions but the solver can still reason about these). Summarizing, a model requires to formalize how variables are linked to each other with a web constraints. These constraints have limited expressively so that a solver can propagate information between variables and along the connections that constraints impose.&lt;/p&gt; &lt;p&gt;Coming back to the Snake-Cube, let‚Äôs take for instance a physical rule that cubes cannot overlap. Let‚Äôs iteratively reformulate this statement in the MiniZinc language. Without doing to much maths ceremony, we could say that &lt;strong&gt;cubes cannot overlap&lt;/strong&gt; means that &lt;strong&gt;there can be at most one CUBE per POS&lt;/strong&gt;. Alas &lt;code&gt;at most one&lt;/code&gt; is a pretty complicated term, we so far only have &lt;code&gt;CUBE&lt;/code&gt;, &lt;code&gt;POS&lt;/code&gt;, and &lt;code&gt;positions&lt;/code&gt; as objects to manipulate. Thus, if we want to count how many &lt;code&gt;CUBE&lt;/code&gt; exists in each &lt;code&gt;POS&lt;/code&gt; we would have to introduce variables for counting occurrences of POS. All theses variables seem like a lot of extra work and we can try to find simpler expressions of the same rule. If we try to rephrase further, we could find a ‚Äúsimpler‚Äù way to encode our rule. We don‚Äôt need to count every occurrence but rather we should prevent co-occurrences. That is, to say, in a formal tone &lt;strong&gt;no two distinct CUBEs can be attributed to the same POS in the position array&lt;/strong&gt;. Even if this formulation hurts the ears, this formulation is good because we already have everything at our disposal. In MiniZinc, this statement would be written like this&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;constraint forall(c1, c2 in CUBE c1 != c2) (position[c1] != position[c2])`; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;constraint&lt;/code&gt; keyword introduces a new constraint. The &lt;code&gt;forall&lt;/code&gt; keyword has two sets of braces: an iteration binds variable names, in that case over all pairs of distinct &lt;code&gt;CUBE&lt;/code&gt;. The second set of braces contains another constraint, which in this case is merely looking up the positions of &lt;code&gt;CUBEs&lt;/code&gt; and requesting that their &lt;code&gt;POS&lt;/code&gt; are different, since &lt;code&gt;position&lt;/code&gt; is an array indexed by &lt;code&gt;CUBE&lt;/code&gt; we just need to perform a lookup. This indexing illustrates how natural it becomes to have arrays indexes by variables defined. You do not have to translate back to numerical indices starting at zero (or one depending on your typical programming language), MiniZinc translates indices for you.&lt;/p&gt; &lt;p&gt;Such a constraint of uniqueness of decision variables often arises while formalizing problems. Even if terse, it would be cumbersome to rewrite such a constraint every single time. Fortunately MiniZinc has a number of features to help with repetitive work: &lt;em&gt;functions&lt;/em&gt; and &lt;em&gt;predicates&lt;/em&gt; functions are like your typical programming function with arguments and an output. However they behave morally more like macros (i.e., MiniZinc will expand their content). Whereas predicates are functions that return constraints. As a modeler you would use predicates and functions to create increasingly-high level constraints from atomic constraints. You will find a library predicate in MiniZinc named &lt;code&gt;all_different&lt;/code&gt;. Thus we can rewrite our statement above with&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;include &amp;quot;all_different.mzn&amp;quot;; constraint all_different(positions); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This formulation is better than the &lt;code&gt;forall&lt;/code&gt; because it is more declarative: you cannot really mix it up. This formulation also has an incredible advantage: solvers can recognize these predicates and implement special routines to solve them faster. In constraint programming, such predicates are named &lt;em&gt;globals&lt;/em&gt; because &lt;strong&gt;globals can efficiently propagate information to all variables at once&lt;/strong&gt;, rather than the more point-to-point propagation which occurs with the ‚Äúpedestrian‚Äù implementation. If a specific solver doesn‚Äôt know how global, MiniZinc defaults to a semantically-equivalent implementation (in short: the compatibility matrix is built-in). If we run MiniZinc we now get something better.&lt;/p&gt; &lt;p&gt;&lt;img src="images/snake-cube-mzn-002.png" alt="solution showing all-differents but not a real folded-cube" /&gt;&lt;/p&gt; &lt;p&gt;The assignment we get now looks &lt;em&gt;more correct&lt;/em&gt; (whatever that means). In a sense we can convince ourselves that we already have forced every &lt;code&gt;CUBE&lt;/code&gt; to fit in a box, and that no two cubes will ever be in the same position. Remember that we have 27 &lt;code&gt;CUBEs&lt;/code&gt;. All stars align, &lt;strong&gt;we have enforced the folded-cube rule without thinking too much&lt;/strong&gt; about it! Did we? actually it is not &lt;em&gt;that&lt;/em&gt; simple. Constraint programming is a bit like an evil genie: it will answer your wishes but did you clearly state your wish? Let‚Äôs recap what we have done.&lt;/p&gt; &lt;p&gt;So far we have discussed MiniZinc and brushed some vague explanation about how a constraint-solver works. We have seen the basics of what formalizing a game with variables and constraints. We managed to define variables to name every &lt;code&gt;CUBE&lt;/code&gt; in the snake and every &lt;code&gt;POS&lt;/code&gt; in the folded-cube. We recognized that we need to find one &lt;code&gt;POS&lt;/code&gt; for every &lt;code&gt;CUBE&lt;/code&gt; and thus built an array to store a decision &lt;code&gt;POS&lt;/code&gt; for every &lt;code&gt;CUBE&lt;/code&gt;. We also used the global predicate &lt;code&gt;all_different&lt;/code&gt; to force every &lt;code&gt;CUBE&lt;/code&gt; to be in a different POS, hence encoding some rules. All of this setup was mostly introductory.&lt;/p&gt; &lt;p&gt;Now what‚Äôs left: well, the folding problem is left! At this point, there are no connections between individual cubes. It‚Äôs like if we torn apart the Snake and stacked all the cubes and re-ordered them. We have not spoken about geometry at all. We don‚Äôt even know if the &lt;code&gt;POS&lt;/code&gt; numbering represents a 3x3x3 object because we have not inserted that into our model at all. To go further we‚Äôll need to introduce some notion of coordinates.&lt;/p&gt; &lt;h2 id="a-coordinates-system"&gt;A coordinates system&lt;/h2&gt; &lt;p&gt;Coordinates will be useful for two things: first, ensure that our &lt;code&gt;POS&lt;/code&gt; numbering represents a 3x3x3 cube (remind that if you somehow forget this, the evil genie will mis-interpret your wish). And the coordinates will also be able to enforce the rules of what are valid folds that do not tear the snake apart.&lt;/p&gt; &lt;h3 id="3d-coordinates-of-positions"&gt;3d-coordinates of positions&lt;/h3&gt; &lt;p&gt;Let‚Äôs take a direct approach and define one type per dimension. Each &lt;code&gt;POS&lt;/code&gt; will have one coordinate value in every dimension. We can model this characteristics with three array indexed by &lt;code&gt;POS&lt;/code&gt; and that contains one dimensional value.&lt;/p&gt; &lt;p&gt;In object-oriented programming you would model that with a list of Position object, each containing three coordinates named x, y, and z. In MiniZinc you have three lists in parallel, each one encoding a single coordinate. Such a modeling with ‚Äúone column per field‚Äù is typical in ‚Äòcolumnar databases‚Äô or in ‚ÄòECS frameworks‚Äô, or even good old ‚ÄòCSV files‚Äô.&lt;/p&gt; &lt;p&gt;In MiniZinc you write:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: X = 0..2; set of int: Y = 0..2; set of int: Z = 0..2; array[POS] of X: xs = [ (p - 1) mod 3 | p in POS ]; array[POS] of Y: ys = [ ((p - 1) div 3) mod 3 | p in POS ]; array[POS] of Z: zs = [ ((p - 1) div 9) mod 3 | p in POS ]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;An important note here is that we restrict upfront the interesting coordinates to be 0, 1, or, 2. Indeed, the folded-cube is only 3x3x3 and hence we do not really need to discuss what happens outside the folded-cube. On the opposite, if we limit ourself to a narrow world with 3 values per dimension, we can make sure our folded-cube does not ‚Äúleak‚Äù because each &lt;code&gt;CUBE&lt;/code&gt; has a &lt;code&gt;POS&lt;/code&gt; via the &lt;code&gt;position&lt;/code&gt; array, and hence each &lt;code&gt;CUBE&lt;/code&gt; transitively has a X, a Y, and a Z in the 0..2 range, which means that every &lt;code&gt;CUBE&lt;/code&gt; is born to live ‚Äòconstrained‚Äô in our 3x3x3 world, without explicitly adding constraints like &lt;code&gt;constraint forall(c in CUBE)( position[CUBE] &amp;lt;= 2 ) &lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt; merely is arithmetic to give 3d coordinates for a ‚Äònatural‚Äô numbering of cube as shown in the following poor diagram I made&lt;/p&gt; &lt;p&gt;&lt;img src="images/snake-cube-coords.png" alt="diagram of 3d 3x3x3 cube" /&gt;&lt;/p&gt; &lt;p&gt;On this picture, the numbers correspond to &lt;code&gt;POS&lt;/code&gt; objects; not shown the values along X, Y, and Z start at &lt;code&gt;0&lt;/code&gt; at the ‚Äòorigin‚Äô (and thus, &lt;code&gt;POS-1&lt;/code&gt; is at coordinates &lt;code&gt;{0,0,0}&lt;/code&gt;).&lt;/p&gt; &lt;p&gt;Also, since this computation is entirely determined from the input data, nothing is variable (i.e., MiniZinc runs the arithmetic before asking the solver to run guesses).&lt;/p&gt; &lt;h3 id="segmenting-the-snake"&gt;Segmenting the Snake&lt;/h3&gt; &lt;p&gt;Now that it‚Äôs clear that the folded-cube is 3x3x3, let‚Äôs talk about the snake. I decided to model the snake as a series of &lt;code&gt;SEGMENTs&lt;/code&gt; which are characterized by a starting and an ending &lt;code&gt;CUBE&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;For instance the following snake as initial segments &lt;code&gt;[1,3] [3,5] [5,7] [7,9]...&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code&gt; 1 2 3 9 o-o-o o-.... | | 4 o o 8 | | o-o-o 5 6 7 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This is the part of the puzzle where I had to verify five times I did the right counting because I‚Äôm not very good at counting above ten.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: SEGMENT = 1..17; array[SEGMENT,1..2] of CUBE: segments = [|1,3|3,5|5,7|7,9|9,10|10,11|11,12|12,14|14,16|16,17|17,18|18,20|20,21|21,23|23,24|24,25|25,27|]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This compact syntax allows to declare a &lt;em&gt;two-dimensional array&lt;/em&gt; and its content. The array is declared as having two indexing keys and contains &lt;code&gt;CUBEs&lt;/code&gt;. The index &lt;code&gt;1..2&lt;/code&gt; represents the start or the end of the segment. Thus &lt;code&gt;segments[5,1] = 9&lt;/code&gt; is the &lt;code&gt;CUBE&lt;/code&gt; that starts the fifth &lt;code&gt;SEGMENT&lt;/code&gt; of the snake, whereas &lt;code&gt;segments[5,2] = 10&lt;/code&gt; is the &lt;code&gt;CUBE&lt;/code&gt; that ends the fifth &lt;code&gt;SEGMENT&lt;/code&gt; of the snake. Alternatively we could have two separate arrays for starting end ending &lt;code&gt;CUBEs&lt;/code&gt; of &lt;code&gt;SEGMENTS&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Now what‚Äôs interesting in the physical version of the puzzle is that handling this snake is a bit overwhelming. Each segment is stiff, however between two segments the snake can rotate (or pivot around). That is, &lt;em&gt;along&lt;/em&gt; a segment, the &lt;code&gt;CUBEs&lt;/code&gt; of a &lt;code&gt;SEGMENT&lt;/code&gt; cannot move. However at &lt;code&gt;junctions between two segments&lt;/code&gt;, segments are free to rotate.&lt;/p&gt; &lt;h3 id="enforcing-the-physics-of-the-game"&gt;Enforcing the physics of the game&lt;/h3&gt; &lt;p&gt;We just need to encode these two rules (which will refer to as &lt;em&gt;pivot&lt;/em&gt; or &lt;em&gt;straight&lt;/em&gt;) and we will be done. There are no major difficulty for this but it is not entirely straightforward given how many indirections exist in our model. To recap, our main input is a list of &lt;code&gt;SEGMENTs&lt;/code&gt;, which inform us about how &lt;code&gt;CUBEs&lt;/code&gt; can be laid out relative to each other. Each &lt;code&gt;CUBE&lt;/code&gt; must be given a &lt;code&gt;POS&lt;/code&gt; and each &lt;code&gt;POS&lt;/code&gt; has three coordinates. We now need to link every &lt;code&gt;CUBE&lt;/code&gt; in a &lt;code&gt;SEGMENT&lt;/code&gt; with some &lt;code&gt;straight&lt;/code&gt; rule to force coordinates to form a line. And we need to link the coordinates of the &lt;code&gt;POS&lt;/code&gt; of connecting &lt;code&gt;CUBEs&lt;/code&gt; in consecutive &lt;code&gt;SEGMENTs&lt;/code&gt; to form a &lt;code&gt;corner&lt;/code&gt; . Yes it‚Äôs a lot of words but when you handle the puzzle it becomes very intuitive.&lt;/p&gt; &lt;p&gt;&lt;img src="images/snake-cube-l-shape.png" alt="diagram of L-shape cubes illustrating straight and corner rules" /&gt;&lt;/p&gt; &lt;p&gt;The above picture summarizes the two rules with two &lt;code&gt;SEGMENT&lt;/code&gt; forming an L-shape. Along the arrow, &lt;code&gt;CUBEs:{1,2,3}&lt;/code&gt; must follow each other and form a &lt;code&gt;straight&lt;/code&gt;, whereas at &lt;code&gt;CUBE:3&lt;/code&gt; a junction forces &lt;code&gt;CUBES:{2,3,4}&lt;/code&gt; to form a &lt;code&gt;corner&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;I said two rules? sorry I was too fast. Actually the rule &lt;code&gt;straight&lt;/code&gt; is sufficient &lt;span class="emoji" data-emoji="thinking"&gt;ü§î&lt;/span&gt; Why? the argument needs to connect three clues together:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;each &lt;code&gt;SEGMENT&lt;/code&gt; of the Snake will have at least two &lt;code&gt;CUBEs&lt;/code&gt; &lt;/li&gt; &lt;li&gt;with the ‚Äòstraight‚Äô rule, each &lt;code&gt;SEGMENT&lt;/code&gt; will span at least 2 in any dimension &lt;/li&gt; &lt;li&gt;we forced coordinates to be in the 0..2 range, and at the time I stressed how useful that was Thus you cannot align two &lt;code&gt;SEGMENT&lt;/code&gt; without leaking outside the &lt;code&gt;CUBE&lt;/code&gt; &lt;span class="emoji" data-emoji="exploding_head"&gt;ü§Ø&lt;/span&gt; . &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;In typed-programming languages like Haskell and OCaml, we speak about making impossible states representables, this reasoning is roughly similar. Such shortcuts, however, in constraint-programming are a point of attention. You need to be careful when iterating on your models. The model does not represent the reality, where I can unfold the Snake along one dimension, but I only care about arrangements where the Snake is folded. That is, my model explicitly departs from the physics of the game. Such a shortcut is convenient because there is likely less typing, the solver will likely be faster because it will not be spending time evaluating solutions doomed to fail. However I cannot just extend my model to the 4x4x4 case without some extra work first because our elaborate argument for the lazy modeler would fall apart.&lt;/p&gt; &lt;h3 id="minizinc-formalization-of-the-physics"&gt;MiniZinc formalization of the physics&lt;/h3&gt; &lt;p&gt;Let‚Äôs now formulate the &lt;code&gt;straight&lt;/code&gt; rule. Remember that MiniZinc speaks of constraints, and a way to build re-usable constraints is a &lt;code&gt;predicate&lt;/code&gt;. I‚Äôm deliberately developing and elaborating bits by bits what &lt;code&gt;straight&lt;/code&gt; formally means in &lt;strong&gt;top-to-bottom fashion&lt;/strong&gt; so that the motivation for introducing a ‚Äúsub-predicate‚Äù is to break-down the higher-level predicate we wrote before. A number of new syntaxes (like &lt;em&gt;let-bindings&lt;/em&gt;) will not be explained so you may have to read code-examples slowly before and after reading the explanation.&lt;/p&gt; &lt;p&gt;We would like to do something like saying &lt;strong&gt;all SEGMENT must form straight lines&lt;/strong&gt;. Which is a straightforward.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;constraint forall(s in SEGMENT)(straight(s)); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;MiniZinc will complain that &lt;code&gt;straight&lt;/code&gt; is not defined yet, but at least the only new ‚Äútop-level constraint‚Äù is written down and we are left with elaborating our predicate. We need to break-down what it means to form a straight line because we can place segments along any of the three dimensions. This predicate thus needs another set other predicates (&lt;code&gt;alongX, alongY, and alongZ&lt;/code&gt;) in a &lt;em&gt;boolean OR disjunction&lt;/em&gt;. Note that in formal methods &lt;code&gt;x = a \/ b&lt;/code&gt; has information flowing in both directions, so if you can determine that &lt;code&gt;x&lt;/code&gt; is true then it tells you that at least &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is true, which seems logical when stated but can look unusual to programmers used to handling ORs with information flowing in a single direction. Let‚Äôs write down our disjunction along all three axes:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate straight(SEGMENT: s) = let {CUBE: c0 = segments[s,1]; CUBE: c1 = segments[s,2]} in alongX(c0..c1) \/ alongY(c0..c1) \/ alongZ(c0..c1); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;At this point I am saying that a straight segment can be straight &lt;code&gt;along X OR along Y OR along Z&lt;/code&gt;. Since we have not really specified what these individual predicates mean our &lt;code&gt;SEGENT&lt;/code&gt; could be placed along two dimensions at a same time: in some puzzles being placed along multiple dimensions might mean a form of diagonal, but we‚Äôll not allow it here. With &lt;code&gt;c0..c1&lt;/code&gt; I expand the &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; &lt;code&gt;CUBE&lt;/code&gt; of the segment and turn that into an array of &lt;code&gt;CUBEs&lt;/code&gt; to the individual predicates because we want to start discussing about coordinates of positions of cubes.&lt;/p&gt; &lt;p&gt;In plain English, being ‚Äòalong X‚Äô means that the &lt;code&gt;X&lt;/code&gt; coordinates of the positioned cubes vary whereas the &lt;code&gt;Y&lt;/code&gt; and &lt;code&gt;Z&lt;/code&gt; coordinates are fixed (if you go back to my pictures, the three cubes in the L-shape are ‚Äúalong X‚Äù, hence &lt;code&gt;Y&lt;/code&gt; and &lt;code&gt;Z&lt;/code&gt; are fixed and &lt;code&gt;X&lt;/code&gt; vary). We can thus encode such a predicate with a &lt;em&gt;boolean AND conjunction&lt;/em&gt; of three clauses:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate alongX(array[int] of CUBE: cubes) = along(cubes, xs) /\ samePos(cubes, ys) /\ samePos(cubes, zs); predicate alongY(array[int] of CUBE: cubes) = samePos(cubes, xs) /\ along(cubes, ys) /\ samePos(cubes, zs); predicate alongZ(array[int] of CUBE: cubes) = samePos(cubes, xs) /\ samePos(cubes, ys) /\ along(cubes, zs); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;That‚Äôs a bit of boilerplate as we repeat ourselves for each dimension. To avoid repeating ourselves while elaborating further, we will pass the useful information ‚Äúin which dimension we are‚Äù as arguments to the lower-level predicates: &lt;code&gt;along&lt;/code&gt; and &lt;code&gt;samePos&lt;/code&gt; . Both predicates take a series of cubes and a the coordinates in the dimension of interest as arguments. Let‚Äôs formulate &lt;code&gt;along&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate along(array[int] of CUBE: cubes, array[POS] of int: proj) = let { CUBE: c0 = cubes[1]} in forall(c1 in cubes where c1 &amp;gt; c0)(abs(proj[positions[c0]] - proj[positions[c1]]) = c1 - c0); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Some discussion around the design of the parameters:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;taking an array of &lt;code&gt;CUBEs&lt;/code&gt; rather than a single &lt;code&gt;SEGMENT&lt;/code&gt; because I didn‚Äôt want to repeat &lt;code&gt;segments[s,1]&lt;/code&gt; many times, and also because I started with another (more complex) model that had no &lt;code&gt;SEGMENT&lt;/code&gt; yet and was lazy to change it for cosmetics &lt;/li&gt; &lt;li&gt;taking an &lt;code&gt;array[POS] of int&lt;/code&gt; named ‚Äòproj‚Äô for ‚Äúprojection along an axis‚Äù: the proper definition of the rule is a bit picky but is exactly the same in all the three dimensions, so let‚Äôs write it only once and avoid typos &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;What is important is that the first CUBE is taken as a reference, then I force the distance of the positioned cubes (i.e., via the indirection &lt;code&gt;proj[positions[ ]]&lt;/code&gt; and with &lt;code&gt;abs&lt;/code&gt; the absolute value function) of the positions to match the distance on the unfolded Snake &lt;code&gt;c1 - c0&lt;/code&gt;. For instance, for the segment of &lt;code&gt;CUBEs-{5,6,7}&lt;/code&gt; along X. We enforce that, once positioned in folded-cube, the distance between CUBE-5&lt;code&gt;and&lt;/code&gt;CUBE-6&lt;code&gt;is exactly 1 and the distance between&lt;/code&gt;CUBE-5&lt;code&gt;and&lt;/code&gt;CUBE-7` is exactly 2. The absolute value encodes the fact that the segment could be in either direction (left to right or right to left) while along the same axis.&lt;/p&gt; &lt;p&gt;Now we are left specifying the &lt;code&gt;samePos&lt;/code&gt; predicate. This predicate takes the same arguments as &lt;code&gt;along&lt;/code&gt; to avoid typing it for each dimension. However &lt;code&gt;samePos&lt;/code&gt; is simple to write: while &lt;code&gt;along&lt;/code&gt; enforced some distance along an axis, &lt;code&gt;samePos&lt;/code&gt; enforce no changes along an axis. Thus, we do not need complicated arithmetics with absolute values, a simple &lt;em&gt;equality&lt;/em&gt; will do.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate samePos(array[int] of CUBE: cubes, array[POS] of int: proj) = forall(c0, c1 in cubes where c0 &amp;lt; c1)(proj[positions[c0]] = proj[positions[c1]]); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;And we are done! Overall, forcing successive coordinates along X and same coordinates along Y and Z ensure our segment is stiff. Elaborating from a top-level constraint we have written a number of helper-predicates. It may feel superfluous but writing all the constraints by hand would have been especially boring and hard to get right without copy-paste-edit typos. If you fiddle with intermediary MiniZinc files you‚Äôll realize that the extra constraint adds 488 atomic constraints. As a point of comparison the lonely global ‚Äúall_different‚Äù from previous section generate a single atomic constraint.&lt;/p&gt; &lt;h3 id="running-minizinc-at-last"&gt;Running MiniZinc at last&lt;/h3&gt; &lt;p&gt;When we now run MiniZinc, we are greeted with a solution after roughly one second.&lt;/p&gt; &lt;p&gt;&lt;img src="images/snake-cube-mzn-003.png" alt="proper solution but oddly-formatted" /&gt;&lt;/p&gt; &lt;p&gt;I was pretty excited when I got my first solution. I verified it by twisting my fingers. Something pretty interesting happened: &lt;strong&gt;I could not fold the Snake-Cube&lt;/strong&gt; &lt;span class="emoji" data-emoji="dizzy_face"&gt;üòµ&lt;/span&gt; . What on Earth has gone wrong?&lt;/p&gt; &lt;h1 id="the-mystery-and-the-symmetries"&gt;The mystery and the symmetries&lt;/h1&gt; &lt;p&gt;Alright, me failing to fold a Snake, even with a solution given by MiniZinc has only a few possible explanations:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Hypothesis-A: I made a mistake in the model (likely &lt;span class="emoji" data-emoji="frowning"&gt;üò¶&lt;/span&gt;) &lt;/li&gt; &lt;li&gt;Hypothesis-B: I failed at following the output (very likely &lt;span class="emoji" data-emoji="nerd_face"&gt;ü§ì&lt;/span&gt;) &lt;/li&gt; &lt;li&gt;Hypothesis-C: Even if we have a valid positioning, it is not feasible to operate the sequence of moves (the cube is only 3x3x3 so I estimate it unlikely, I might need to start folding from the middle, however &lt;span class="emoji" data-emoji="exploding_head"&gt;ü§Ø&lt;/span&gt;) &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;I audited my model, added some traces and redundant constraints to quickly verify/check some more invariants: nothing seemed off. Then, rather than following the output again I took a rather barbaric approach: rather than starting folding from &lt;code&gt;CUBE-0&lt;/code&gt; in my solution I started from &lt;code&gt;CUBE-27&lt;/code&gt; and it miraculously worked &lt;span class="emoji" data-emoji="relieved"&gt;üòå&lt;/span&gt;. &lt;strong&gt;Maybe the solver gave me a different solution the second time&lt;/strong&gt; and Hypothesis-C is correct. After-all I was not doing exhaustive checks and I made the rookie mistake of &lt;em&gt;not&lt;/em&gt; storing my first output.&lt;/p&gt; &lt;p&gt;With a sucessfully folded-cube (as shown in the early pictures), I had strong clue that my MiniZinc model was right because &lt;strong&gt;at least one solution it gave was empirically correct&lt;/strong&gt; . There still is the room for a combination of errors: what if the output was incorrect and at a same time I failed at following the output and also ended up following a valid folding by ‚Äúluck‚Äù - extremely unlikely and against &lt;a href="https://en.wikipedia.org/wiki/Occam%27s_razor"&gt;Occam‚Äôs principle &lt;span class="emoji" data-emoji="razor"&gt;ü™í&lt;/span&gt;&lt;/a&gt; at this level of debugging.&lt;/p&gt; &lt;p&gt;Hypothesis-C was still piking my interest. I spent some time on YouTube and people recommend to fold the snake starting at the middle. Something I had not really foreseen and could be really frustrating: it would be incredibly hard to model the exact folding sequence as a hobby project. Such a folding requires to introduce a notion of time and verify that along time all rotations are allowed: it‚Äôs a much more ambitious model than our the small introduction I hope to give in this blog post.&lt;/p&gt; &lt;p&gt;I preferred to take another approach to rule-out Hypothesis-C: &lt;strong&gt;trying to find all possible folding and if I find only one then there is only one solution&lt;/strong&gt;. In MiniZinc it‚Äôs really easy, in the configuration you just ask ‚Äúprint all solutions‚Äù. Actually, I did that and not only the program found many solutions (six in ten seconds), it also kept running and searching and searching and searching. Switching the solver to &lt;strong&gt;Chuffed found 48 solutions in two seconds and proved that no-other solutions exist&lt;/strong&gt;. That is still a lot for me to try given how bad I am at following one solution by hand, we need an idea to compare two solutions. The idea was to manipulate the folded-cube &lt;span class="emoji" data-emoji="bulb"&gt;üí°&lt;/span&gt; : if I turn the folded-cube around then I have reorganized the coordinates of each &lt;code&gt;POS&lt;/code&gt; (say POS:1 is no longer in &lt;code&gt;{1,1,1}&lt;/code&gt; but in &lt;code&gt;{3,1,1}&lt;/code&gt; by rotating the cube along the &lt;code&gt;Y&lt;/code&gt; vertical axis: it‚Äôs a new solution, but not an especially interesting one compared to my first solution. In constraint-programming and in general in physics, the phenomenon we want to control is named &lt;em&gt;symmetry&lt;/em&gt;.&lt;/p&gt; &lt;h2 id="symmetries"&gt;Symmetries&lt;/h2&gt; &lt;p&gt;Say you give me a valid &lt;code&gt;positions&lt;/code&gt; array. I can also build another valid &lt;code&gt;positions&lt;/code&gt; array by changing the numbering (so that X and Y coordinates are ‚Äòswapped‚Äô ‚Äì the physical equivalent is to rotate around Z). I could tell you ‚Äúhere, a new solution‚Äù but you would be really right to feel cheated.&lt;/p&gt; &lt;p&gt;Besides running Chuffed, I have not taken the time to enumerate symmetries in a formal way but I guess there exist at least three things to break (two &lt;em&gt;rotations&lt;/em&gt; along Y and Z times plus &lt;em&gt;flipping&lt;/em&gt; positive directions into negative directions). In constraint-programming (and in general in search problems) you &lt;em&gt;break symmetries&lt;/em&gt; by adding extra constraints that do not come from the initial rules of the problem. These extra constraints will force the search algorithm to look for interestingly-different solutions. This technique also has the benefit to accelerate the resolution as more ‚Äúbranches‚Äù are pruned ‚Äúsooner‚Äù. Sometimes, breaking symmetries is mandatory to find any solution when the problem is actually hard.&lt;/p&gt; &lt;p&gt;In the Snake-Cube game, the way I ended up breaking symmetries was to the follow this line of reasoning:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;the first segment defines the &lt;code&gt;X&lt;/code&gt; axis (and &lt;code&gt;CUBE&lt;/code&gt; indices increments along X) &lt;/li&gt; &lt;li&gt;the second segment defines the &lt;code&gt;Y&lt;/code&gt; axis (and &lt;code&gt;CUBE&lt;/code&gt; indices increment along Y) &lt;/li&gt; &lt;li&gt;then the first segment that is not along X nor Y will must be along Z (so you don‚Äôt win much) but will define the positive Z values &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;What is important to keep in mind is that what defines the &lt;code&gt;Z&lt;/code&gt; axis is not always ‚Äúthe third segment‚Äù because nothing tells you that the third segment will not be along X in the decreasing direction (i.e., the three first segments could form a U-shaped). We really would like to say, ‚Äúthe first segment along &lt;code&gt;Z&lt;/code&gt; defines &lt;code&gt;Z&lt;/code&gt;‚Äù, but that would be a circular definition without spending extra work formalizing what it means to define an axis.&lt;/p&gt; &lt;p&gt;A problem with symmetry-breaking constraints is to convince yourself the rules are valid and do not mistakenly prune-out desireable solutions. I found it easier to think in terms of directions in the coordinate system than thinking about what it means for all the ‚Äúnext segments‚Äù to take a turn-right at the beginning. Another way to convince ourselves is to count how many coordinate systems we can generate around a fixed folded-snake. Defining the first &lt;code&gt;DIR&lt;/code&gt; has 3 possible choices (any of three-dimensions), we have 2. Then at each definition we can pick positive or negative indices, so we have &lt;code&gt;2*2*2&lt;/code&gt; symmetries here. In total we get &lt;code&gt;3*2*2*2*2 = 48&lt;/code&gt; possible coordinate systems for our Snake. Which is consistent with what Chuffed has found (cf. &lt;a href="/raw/snake-cube-extra-all-solutions-chuffed.txt"&gt;Chuffed raw output&lt;/a&gt;), mystery solved &lt;span class="emoji" data-emoji="muscle"&gt;üí™&lt;/span&gt;. We could stop here, but at this point we have done the hard thinking coupled with the brute-force approach, we want to see if from our own eyes. Let‚Äôs turn this into hard thinking with an elegant encoding of symmetry-breaking constraints.&lt;/p&gt; &lt;p&gt;The difficulty to formalize these rules in MiniZinc is twofold:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;introducing a notion of ‚Äòdirection of segments‚Äô &lt;/li&gt; &lt;li&gt;using this new notion to add constraints to break symmetries &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;So far in our model the &lt;code&gt;SEGMENT&lt;/code&gt; merely were a collection of consecutive CUBEs. We managed to give a &lt;code&gt;POS&lt;/code&gt; to each &lt;code&gt;CUBE&lt;/code&gt;. We however have yet to turn these &lt;code&gt;POS&lt;/code&gt; into a notion of direction. In Snake-Cube, we care about three dimensions, and for each dimension we care about the particular direction (left-to-right or right-to-left). In total it means six directions. We could use &lt;code&gt;set of int: DIR = 1..6&lt;/code&gt; but I instead use a pretty similar construct when you want to give individual names to directions: enums. We somehow now that every &lt;code&gt;SEGMENT&lt;/code&gt; will have a &lt;code&gt;DIR&lt;/code&gt;, so let‚Äôs declare that at the same time.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;enum DIR = {XP, XN, YP, YN, ZP, ZN}; array[SEGMENT] of var DIR: directions; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;For instance, &lt;code&gt;directions[3] = XP&lt;/code&gt; stands for ‚Äòsegment number 3 has cubes laid out along the X-axis with increasing values‚Äô.&lt;/p&gt; &lt;p&gt;The remaining work is to connect &lt;code&gt;DIRs&lt;/code&gt; of &lt;code&gt;SEGMENTs&lt;/code&gt; with the coordinates of positioned &lt;code&gt;CUBEs&lt;/code&gt;. I did that by augmenting the predicate &lt;code&gt;straight&lt;/code&gt; to impose extra conditions with &lt;code&gt;alongX&lt;/code&gt; (and the same for Z and Y).&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate straight(SEGMENT: s) = let {CUBE: c0 = segments[s,1]; CUBE: c1 = segments[s,2]} in (alongX(c0..c1) /\ direction(s, xs, XP, XN)) \/ (alongY(c0..c1) /\ direction(s, ys, YP, YN)) \/ (alongZ(c0..c1) /\ direction(s, zs, ZP, ZN)); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Other designs would have been equally valid. For instance, we could also have modified &lt;code&gt;alongX&lt;/code&gt; directly to pass the &lt;code&gt;SEGMENT&lt;/code&gt; rather than its &lt;code&gt;CUBEs&lt;/code&gt; expansion. What is important is that we now force yet another predicate relating the &lt;code&gt;SEGMENT&lt;/code&gt; and the &lt;code&gt;DIR&lt;/code&gt; together. The &lt;code&gt;direction&lt;/code&gt; predicate is defined as follows:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;predicate direction(SEGMENT: s, array[POS] of int: proj, DIR: dp, DIR: dn) = (proj[positions[segments[s,1]]] &amp;lt; proj[positions[segments[s,2]]] /\ directions[s] = dp) \/ (proj[positions[segments[s,1]]] &amp;gt; proj[positions[segments[s,2]]] /\ directions[s] = dn); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This predicate allows to say that along a given axis, either the segment is positioned ‚Äòleft to right‚Äô and the position of the first &lt;code&gt;CUBE&lt;/code&gt; is before the second &lt;code&gt;CUBE&lt;/code&gt;, or the opposite is true.&lt;/p&gt; &lt;p&gt;At this point, we merely have setup extra variables that really do not change the solutions to the solver. However this extra wiring allows us to formulate symmetry-breaking constraints.&lt;/p&gt; &lt;p&gt;One way to say that the first segment defines the X axis, and the first bent segment defines Y is to add.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;constraint directions[1] = XP; constraint directions[2] = YP; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;However, such a scheme would be insufficient for breaking all symmetries. Indeed, it is unclear whether the third &lt;code&gt;SEGMENT&lt;/code&gt; will be positioned along X again or along Z. Further, it could be positioned along XP or XN if the two first &lt;code&gt;SEGMENT&lt;/code&gt; have length 2. In short, it is important to note that we cannot force &lt;code&gt;XN&lt;/code&gt; to be before or after &lt;code&gt;ZP&lt;/code&gt; because that would enforce a constraint stronger than just breaking symmetries (this is merely repeating the lengthy argument when we enumerated the types of symmetries we want to break, but with variable names). Thus, when adding symmetry-breaking symmetries we need to be diligent because there is a risk to mistakenly remove some solutions we would have preferred to keep around. In our snake-folding game, what we can say, however, is that the first time we move in the third dimension, the &lt;code&gt;SEGMENT&lt;/code&gt; has to be aligned with ZP.&lt;/p&gt; &lt;p&gt;Building this &lt;strong&gt;notion of the first time we move in the third dimension&lt;/strong&gt; is doable but is cumbersome and error prone: we need to give a name at the first occurrence of each &lt;code&gt;DIR&lt;/code&gt; in the &lt;code&gt;directions&lt;/code&gt; array and relate the index of these first occurrences with each other. Fortunately for us, MiniZinc has a number of functions listed under the name ‚Äúsymmetry-breaking constraints‚Äù to encode that ‚Äòthe first occurrence of XP is before the first occurrence of XN and so on and so forth‚Äô. I‚Äôve decided to pick &lt;code&gt;value_precede_chain&lt;/code&gt; and &lt;code&gt;value_precede&lt;/code&gt; to encode the fact that &lt;code&gt;XP&lt;/code&gt; is before &lt;code&gt;YP&lt;/code&gt; which in turns is before &lt;code&gt;ZP&lt;/code&gt; and that &lt;code&gt;positive&lt;/code&gt; is before &lt;code&gt;negative&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;include &amp;quot;globals.mzn&amp;quot;; constraint value_precede(XP,XN, directions); constraint value_precede(YP,YN, directions); constraint value_precede(ZP,ZN, directions); constraint value_precede_chain([XP,YP,ZP], directions); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;These constraints fully-characterize our precedence rules. Running in MiniZinc, we still get a solution, and now even Gecode can prove exhaustiveness (the line with &lt;code&gt;====&lt;/code&gt; of a single under four seconds).&lt;/p&gt; &lt;pre&gt;&lt;code&gt;positions = array1d(1..27, [1, 2, 3, 6, 9, 8, 7, 16, 25, 26, 17, 18, 15, 12, 11, 10, 19, 22, 13, 4, 5, 14, 23, 20, 21, 24, 27]); directions = array1d(1..17, [XP, YP, XN, ZP, XP, ZN, XP, YN, XN, ZP, YP, ZN, XP, ZP, YN, XP, YP]); ---------- ========== &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;One reason why I may have failed at following my first solution is that the output is a bit austere. The output of &lt;code&gt;directions&lt;/code&gt; actually is more exploitable as it reads as folding instructions, we immediately see that the first three &lt;code&gt;SEGMENT&lt;/code&gt; form a U-shape. Elided for brevity: it is actually possible to ask MiniZinc customize the output via a rendering function. Also, with some extra fiddling I managed to have Gecode prove exhaustiveness in under 100ms (this is yet another advanced technique I may cover in a separate blog post).&lt;/p&gt; &lt;p&gt;Somehow, finding a single solution, and proving that I am not able to follow instructions, is a nice conclusion to conclude this story &lt;span class="emoji" data-emoji="book"&gt;üìñ&lt;/span&gt;.&lt;/p&gt; &lt;h1 id="summary-and-discussion"&gt;Summary and Discussion&lt;/h1&gt; &lt;p&gt;We have formalized the problem of the Snake-Cube, solved it, and proved the solution unique. Proving the solution unique means that we pretty much have a complete characterization of the Snake-Cube puzzle. And to recap, our model formalizes the Snake-Cube puzzle as follows:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;CUBE&lt;/code&gt;, &lt;code&gt;SEGMENT&lt;/code&gt;, &lt;code&gt;POS&lt;/code&gt;, &lt;code&gt;DIR&lt;/code&gt; are key entities that need well-defined names &lt;/li&gt; &lt;li&gt;the snake consists of a series of &lt;code&gt;CUBE&lt;/code&gt;, each consecutive line of &lt;code&gt;CUBE&lt;/code&gt; defines a &lt;code&gt;SEGMENT&lt;/code&gt; &lt;/li&gt; &lt;li&gt;&lt;code&gt;POS&lt;/code&gt; provide coordinates to all final positions of &lt;code&gt;CUBE&lt;/code&gt; in each of the x, y, and z dimensions of the 3x3x3 folded-cube &lt;/li&gt; &lt;li&gt;the problem is an &lt;em&gt;attribution problem&lt;/em&gt;, in which each &lt;code&gt;CUBE&lt;/code&gt; is given a &lt;code&gt;POS&lt;/code&gt;, thus we can use the &lt;code&gt;all_different&lt;/code&gt; &lt;em&gt;global&lt;/em&gt; constraint to efficiently capture this property &lt;/li&gt; &lt;li&gt;physical constraints of &lt;code&gt;straight&lt;/code&gt;-lines and &lt;code&gt;corners&lt;/code&gt; impose a relationship between the coordinates of the positioned &lt;code&gt;CUBE&lt;/code&gt; of a same &lt;code&gt;SEGMENT&lt;/code&gt; &lt;/li&gt; &lt;li&gt;we used &lt;em&gt;predicates&lt;/em&gt; to re-use a good chunk of the domain logic when encoding &lt;code&gt;straight&lt;/code&gt; &lt;/li&gt; &lt;li&gt;we took some shortcuts eliding the &lt;code&gt;corners&lt;/code&gt; rule because we recognized that the minimal length for a &lt;code&gt;SEGMENT&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt; and the maximum extent for the folded-cube is &lt;code&gt;3&lt;/code&gt;, thus we do not really need to force consecutive &lt;code&gt;SEGMENTs&lt;/code&gt; to turn around &lt;/li&gt; &lt;li&gt;we broke rotational and mirroring &lt;em&gt;symmetries&lt;/em&gt; with the &lt;code&gt;value_precede&lt;/code&gt; global constraints, allowing to convince oneself only one solution to this Snake-Cube puzzle exists &lt;/li&gt; &lt;li&gt;I am not especially good at following mechanical output instructions &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The article is already a bit long and we could discuss a number of other techniques such as &lt;em&gt;channeling&lt;/em&gt;, observing how different &lt;em&gt;families of solvers&lt;/em&gt; fare in this problem, or modifying the &lt;em&gt;search strategy&lt;/em&gt;. We could also decide to complexify the model for the puzzle on purpose (e.g., support a &lt;code&gt;4x4x4&lt;/code&gt; cube as well). Rather, we‚Äôll cut it short and may leave these advanced topics for another blog post. That said, before concluding I cannot resist to ask you a question for thought: Is &lt;code&gt;POS&lt;/code&gt; really required? it is an interesting question because &lt;code&gt;POS&lt;/code&gt; is merely and indirection that adds more typing work to get from a &lt;code&gt;CUBE&lt;/code&gt; to a set of coordinates.&lt;/p&gt; &lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt; &lt;p&gt;We can solve real-world and business-critical problems in MiniZinc. Although the Snake-Case, is not as complicated as a real-world models where constraint-programming can really shine, this puzzle is a good illustration of how to solve problems using constraint-programming: it is not immediately obvious how to formalize and to formulate the puzzle into a computer program.&lt;/p&gt; &lt;p&gt;Constraint-programming is declarative: we state a problem and let the solver grind through solutions for us. You can thus answer questions more succinctly, sometimes constraint programming allow you to reach further and find solutions to problem that would be unattainable or impractical in your typical programming style. Since the Snake-Cube has a single solution we cannot really add interesting rules to spice the game, but real-world is full of examples where an off-the-shelf algorithm does not work because of some extra constraint (e.g., a shortest-path with road-closures time tables). In short, I believe MiniZinc and Constraint-Programming are extremely-valuable tools. Although it requires a high personal investment to learn MiniZinc, the application of the skill has high value-for-the-cost.&lt;/p&gt; &lt;p&gt;We could have stopped at the first iteration of the solver, before discussing symmetries (and in many contexts stopping at this solution could have been sufficient). However I think it is important to show that we can, and sometimes are forced, to go further deep in the understanding of the problem.&lt;/p&gt; &lt;p&gt;I typically build models iteratively as shown in this blog-post. However, from experience, there is little continuity between having no solutions, a useless solution, being swamped with solutions, and finding the one and only correct solution. There also are vastly more interesting modeling perspectives than you have time for. Thus it is key to know when to stop and you must know how to convince yourself that your overall model and solving strategy are good enough.&lt;/p&gt; &lt;p&gt;I believe these characteristics are shared among all declarative systems (e.g., SQLs, Prologs, and DataLogs, but also devop tools like Terraform) &lt;em&gt;because&lt;/em&gt; we explicitly forfeit control to a black-box in exchange for extra reach. I like to say that these tools are evil genies, they will answer you wishes but you must be careful when articulating your wish. To overcome this downside of declarative style, you need knowledge and practice. In particular, you need a good capacity at abstracting away so that you can recognize familiar problems in some ad-hoc problem that life has thrown at us. And then you need to be able to activate the many knobs in a rich toolbox like MiniZinc.&lt;/p&gt; &lt;p&gt;If you are interested or want to apply these techniques and feel overwhelmed or lost, please reach-out.&lt;/p&gt; &lt;h2 id="links"&gt;Links&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://www.minizinc.org"&gt;MiniZinc&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Snake_cube"&gt;Snake Cube on Wikipedia&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/lucasdicioccio/snakecube"&gt;My solution on GitHub&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/snake-cube.html" rel="alternate"/>
        <summary type="text">
            We solve a simple wooden puzzle with MiniZinc. The Snake-Cube puzzle is a good introductory problem and thus a number of formal modeling techniques are explained. We also touch advanced topic like symmetries and discuss a bit our modeling choices.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/santa-wrap.html
        </id>
        <title type="text">
            Advent of Haskell 2020: Santa Wrap
        </title>
        <updated>
            2020-12-24T12:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;This article is part of &lt;a href="https://adventofhaskell.com/"&gt;Advent of Haskell&lt;/a&gt; 2020 &lt;span class="emoji" data-emoji="christmas_tree"&gt;üéÑ&lt;/span&gt;. Make sure to check the other articles too! You will find the code for this blog-post at &lt;a href="https://github.com/lucasdicioccio/santa-wrap/"&gt;the original GitHub publication&lt;/a&gt;.&lt;/p&gt; &lt;h2 id="our-christmas-project"&gt;Our Christmas project&lt;/h2&gt; &lt;p&gt;Year 2020 is terrible. Santa‚Äôs Workshop had to take stay-at-home restrictions. However, Elves want to do the utmost to keep Christmas‚Äô spirit alive. This year, Elves will work from home rather than work in the streamlined workshop &lt;span class="emoji" data-emoji="factory"&gt;üè≠&lt;/span&gt; . They will get back to a more traditional way of preparing presents, like Elderly Elves who live more than 500 years, remember. In short, every Elf works in their own garage &lt;span class="emoji" data-emoji="house"&gt;üè†&lt;/span&gt;. They receive the Christmas wishlists of neighboring families: crafting toys &lt;span class="emoji" data-emoji="space_invader"&gt;üëæ&lt;/span&gt;, sewing clothes &lt;span class="emoji" data-emoji="shirt"&gt;üëï&lt;/span&gt;, or cooking delicious cookies &lt;span class="emoji" data-emoji="cookie"&gt;üç™&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;One particularly annoying task for work-from-home Elves, however, is to wrap presents &lt;span class="emoji" data-emoji="gift"&gt;üéÅ&lt;/span&gt;. They had avoided this task in the recent years thanks to automation. Elves all have different pieces of wrapping-paper at home, in particular wrapping-paper rolls vary in ratio and vary in size from one Elf to another one. Elves want some software to help them cut wrapping-paper for the presents they prepare &lt;span class="emoji" data-emoji="scissors"&gt;‚úÇÔ∏è&lt;/span&gt;. Some Elves have tools to cut paper (think of a cookie-cutter, but for large sheets of paper), whereas others only have cissors. Wrapping may become scarce if used inefficiently, and anyway ordering takes time. Thus, they would like to have a rough idea of how to efficiently cut the paper rolls given their own specific constraints. It does not have to be perfect, but it cannot be completely naive either. Thus, Elves need some creative idea to save Christmas‚Äô spirit. For the better or for the worst Elves resorted to use software &lt;span class="emoji" data-emoji="computer"&gt;üíª&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Fortunately, an Elf has learnt Haskell, a language especially good for building small command line tools and with libraries to generate images. He also has learnt MiniZinc, a language especially good for solving this family of problems. Put together, these languages can help building a small tool that Elves can run at home with their own input. This computer-savvy Elf suggests the following &lt;a href="/hashtags/trade-off.html"&gt;&lt;span class="hashtag" data-hashtag="trade-off"&gt;#trade-off&lt;/span&gt;&lt;/a&gt;:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Elves will input the quantity and shape of the wrapping for the presents (or the shape of their cookie-cutter tools that fit for the present) &lt;/li&gt; &lt;li&gt;the shape of the wrapping is blocky, that is, made of various rectangle blocks, rather than arbitrarily shaped (it simplifies cutting and folding paper with rulers and guides anyway) &lt;/li&gt; &lt;li&gt;Elves will also input the size of their own paper sheets &lt;/li&gt; &lt;li&gt;the output is a footprint image of how to cut the paper to fit all present (when possible) Some Elves expected more specialized tools, some cared especially about saving wrapping paper. However, time is running out, our software Elf-ineer only has a day to build this software or it will be too late to save Christmas. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;I am not sure I should reveal this, but, I work in Santa Incorporated oh oh oh. Do not tell your kids! in exchange I‚Äôll explain you how I built &lt;code&gt;santa-wrap&lt;/code&gt; in a rush to help the Elf. Thus, the main goal for this article is to relate how to iterate quickly on a practical one short day project. Secondary goals are to pike your interest about MiniZinc and introduce you a library named &lt;code&gt;minizinc-process&lt;/code&gt;.&lt;/p&gt; &lt;h2 id="approach"&gt;Approach&lt;/h2&gt; &lt;p&gt;The type of problem for cutting wrapping paper is known as a Packing problem. These problems are generally difficult to solve efficiently. However, for small sizes or particular form of constraints, some solutions could be efficiently found (or the litterature may have some heuristics that work well empirically). Generally, the difficulty comes from integrality of constraints, that is you either can wrap a present or not wrap the present, you cannot wrap a fraction of a present. Such problems come up a lot in industrial settings where some resource is scarce. In this particular case, we cheated a bit as we came with an idea to write a blog post. However, with a bit of practice you will recognize packing problems everywhere.&lt;/p&gt; &lt;p&gt;We want to show off how to combine MiniZinc (a mathematical &lt;a href="/hashtags/optimization.html"&gt;&lt;span class="hashtag" data-hashtag="optimization"&gt;#optimization&lt;/span&gt;&lt;/a&gt; language and toolchain) with Haskell (which readers of this Advent of Haskell submission are familiar with). We will show the progression of a tool, with building a value-adding prototype in a day or two of work for some Elf familiar with Haskell and Minizinc.&lt;/p&gt; &lt;h2 id="motivating-our-iterations"&gt;Motivating our Iterations&lt;/h2&gt; &lt;p&gt;The author built this tool in four broad iterations: implement a demo solver in MiniZinc, generate simple pictures for each wrapping, introduce the concept of layout, and, bridge the solver. We motivate each iteration before jumping into lengthier explanations.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Implemeting a solver in MiniZinc&lt;/em&gt;: I wanted to leverage powerful global constraints with their own heuristics/optimized solutions that exist in MiniZinc. Such a model helps us formalize the problem in better terms and understand what are inputs and what are outputs. In a business settings, such prototypes allow to raise the important questions. In that case, the whole problem is solved with a single &lt;a href="https://www.minizinc.org/doc-2.3.0/en/lib-globals.html#packing-constraints"&gt;global contraint&lt;/a&gt; named &lt;code&gt;geost_bb&lt;/code&gt;. Knowing which constraints help modeling a problem is a type of expertise that takes time to acquire but that can change drastically the viability of such a tool.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Generate simple pictures&lt;/em&gt;: our tool needs to generate pictures of the wrapping, and I find a blog-post with picture more appealing than without. Visualizations illustrate the problem. I am not familiar with low-level graphics libraries. I typically use high-level tools for my charts like &lt;a href="https://ggplot2.tidyverse.org/"&gt;ggplot in R&lt;/a&gt; ‚Äì they typically get in the way if what you want is pixel-perfect position of image width/height. For this exercise, I found &lt;a href="https://hackage.haskell.org/package/JuicyPixels"&gt;JuicyPixels&lt;/a&gt; and I need to validate quickly that JuicyPixels will fit the needs. This library is appealing because I could generate PNGs with little dependencies. I had some experience with &lt;a href="https://hackage.haskell.org/package/gloss"&gt;Gloss&lt;/a&gt;. However, I discarded this choice for I only need static images and not animations (and Gloss has way more dependencies than JuicyPixels).&lt;/p&gt; &lt;p&gt;&lt;em&gt;Introduce the concept of layout&lt;/em&gt;: pictures become more interesting when we start to have multiple boxes. Once I know how to print a layout I am done with the graphical aspects of the problem. Minor improvements can still come later but it is mind-relaxing to call something done. Further, at this point it is easy to show some naive layouts.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Bridge the solver&lt;/em&gt;: this is the boiler-plate part of the work. &lt;code&gt;minizinc-process&lt;/code&gt; actually have a TemplateHaskell helper to generate an input and output representations but this approach is limited: it cannot work with sets in its current version and does not preclude writing boilerplate to transform between ‚Äúbusiness-domain‚Äù representations and solver input/output representations. Plus, the goal of the article is to illustrate the pro/cons. This part of boiler-plate is the one requiring the most care, hence my usage of newtypes to differentiate indices.&lt;/p&gt; &lt;p&gt;Graphically, the following dependency graph shows the various steps I had in mind. &lt;img src="images/deps.png" alt="img" /&gt; In red are the two chunks of work which I assessed has being the most uncertain (i.e., requiring the most discovery) or most meticulous (i.e., spending time building accurate types to reduce the risk of bugs).&lt;/p&gt; &lt;p&gt;Let‚Äôs discuss how this four iterations looked like.&lt;/p&gt; &lt;h2 id="the-four-iterations"&gt;The four iterations&lt;/h2&gt; &lt;p&gt;We now dive in more details into each iteration. Recall that I time-boxed this project to the equivalent of a short-day-of-work. Readers should be able to read these independently.&lt;/p&gt; &lt;h3 id="a-solver-in-minizinc"&gt;A solver in MiniZinc&lt;/h3&gt; &lt;p&gt;We basically call the &lt;em&gt;global contstraint&lt;/em&gt; &lt;code&gt;geost_bb&lt;/code&gt;. Let‚Äôs unpack how it works, starting from a small MiniZinc overview and a mini tutorial on &lt;code&gt;geost_bb&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;In &lt;a href="https://www.minizinc.org/"&gt;MiniZinc&lt;/a&gt; you separate the structure of a problem (which we call a model) and its particular instance (determined by input parameters). Thus a model can run for various input parameters. Further, the model separate two families of variables: the &lt;em&gt;par&lt;/em&gt; variables (parameters that are given or can be deterministically computed from other parameters) and &lt;em&gt;var&lt;/em&gt; variables (decisions that the solver will make). Constraints are statement that link variables together. The solver, then works out solutions (that is assignments of variables) that are consistent with all constraints. It is typically easy to verify that a given assignment matches all constraints. For instance, in our Santa-Wrap tool can visually inspect whether or not cutting guides for different present intersect. Whereas, it is typically hard to find a given assignment for all possible &lt;em&gt;par&lt;/em&gt; inputs (or an optimal one when a criteria of goodness exists).&lt;/p&gt; &lt;p&gt;In Haskell parlance: &lt;code&gt;solver :: Model -&amp;gt; Parameters -&amp;gt; Maybe Decisions&lt;/code&gt;, which, partially-applied for some &lt;code&gt;Model&lt;/code&gt; would give &lt;code&gt;solveProblem :: Parameters -&amp;gt; Maybe Decisions&lt;/code&gt;. To encode this faithfully in Haskell we would need to ensure that the &lt;code&gt;Parameters&lt;/code&gt; and &lt;code&gt;Decisions&lt;/code&gt; types actually depends on the &lt;code&gt;Model&lt;/code&gt;; somehow, discussing these type-level programming techniques is out of scope for this article.&lt;/p&gt; &lt;p&gt;Typically, writing MiniZinc is a bit like SQL queries: you describe what you want and let the engine fetch it for you. The ability to summon a magic tool to solve our wishes comes with some limitations: expressivity is limited, and you need to be careful what you wish for. For instance, when writing MiniZinc you need to discuss about finite inputs/outputs (e.g, no unbounded recursion). Further, small changes on the structure of the problem can drastically change performance (like switching from a index scan to a table scan in SQL query plan).&lt;/p&gt; &lt;p&gt;The comparison with SQL does not stops at the declarative aspect. Typical domain models in Haskell have collections such as &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List.html"&gt;Lists&lt;/a&gt; or &lt;a href="https://hackage.haskell.org/package/containers-0.6.4.1/docs/Data-Map.html"&gt;Maps&lt;/a&gt; or custom &lt;a href="http://www.cse.chalmers.se/edu/year/2018/course/TDA452/lectures/RecursiveDataTypes.html"&gt;recursively-shaped objects&lt;/a&gt; etc. Once mapped into tabular form in SQL, special conversion care is required. For instance, in Haskell, a type &lt;code&gt;User { age :: Int , height :: Int }&lt;/code&gt; would map to a set of integers (one user-id per user) and two arrays indexed by user-id. So that Haskell domain objects like these.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;users ::&lt;/span&gt; [ &lt;span class="dt"&gt;User&lt;/span&gt; ]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;users &lt;span class="ot"&gt;=&lt;/span&gt; [ &lt;span class="dt"&gt;User&lt;/span&gt; &lt;span class="dv"&gt;23&lt;/span&gt; &lt;span class="dv"&gt;172&lt;/span&gt;, &lt;span class="dt"&gt;User&lt;/span&gt; &lt;span class="dv"&gt;45&lt;/span&gt; &lt;span class="dv"&gt;180&lt;/span&gt;, &lt;span class="dt"&gt;User&lt;/span&gt; &lt;span class="dv"&gt;36&lt;/span&gt; &lt;span class="dv"&gt;165&lt;/span&gt; ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Would translate to the following MiniZinc.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: USER = 1..3; array[USER] of int: age = [ 23, 45, 36 ]; array[USER] of int: height = [ 172, 180, 165 ]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Readers familiar with Relational Algebra, DataParallel Haskell, Columnar Storage, or Entity Component System will find comonalities. We will work this out for our problem in more detail in the last iteration. So now let‚Äôs look at &lt;code&gt;geost_bb&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Here is a snapshot of &lt;code&gt;geost_bb&lt;/code&gt; &lt;a href="https://www.minizinc.org/doc-2.5.0/en/lib-globals.html"&gt;documentation&lt;/a&gt; &lt;img src="images/geost-doc.png" alt="img" /&gt;. Which sorts of packs blocky-structure on a multi-dimensional space. This constraint does not try to shrink gaps between objects, it ‚Äúmerely‚Äù (I don‚Äôt want to downplay how great this is) force assignments of variables such that no overlap exists between the packed objects.&lt;/p&gt; &lt;p&gt;We annotate the parameters below to explain why using this function make sense in Santa-Wrap. Besides the opaque name, it does exactly what we want to help the Elves and even a bit more.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;em&gt;k&lt;/em&gt;: here we live in two dimensions, that an easy parameter, we‚Äôll hardcode it &lt;/li&gt; &lt;li&gt;&lt;em&gt;rect_size&lt;/em&gt;: size of each rectangles along each dimension &lt;/li&gt; &lt;li&gt;&lt;em&gt;rect_offset&lt;/em&gt;: offset of rectangles long each dimension &lt;/li&gt; &lt;li&gt;&lt;em&gt;shape&lt;/em&gt;: wrapping shapes are built from a set of a rectangles, for instance presents we can wrap in a simple rectangle would have a single rectangle. More elaborated wrapping shapes may require two or more adjacent rectangles. For instance the sword here is built with two overlapping rectangles: &lt;img src="images/sword.png" alt="img" /&gt; a rectangle is horizontal (largest &lt;em&gt;rect_size&lt;/em&gt; is the 1st dimension) and another rectangle is vertical (largest &lt;em&gt;rect_size&lt;/em&gt; is the 2nd dimension) and both rectangles are translated along an axis (i.e., one non-zero &lt;em&gt;rect_offset&lt;/em&gt;). Multiple shapes could re-use the same rectangles if they happen to match (hence, saving a bit on the complexity ‚Äì but we won‚Äôt go into this level of sophistication). &lt;/li&gt; &lt;li&gt;&lt;em&gt;l&lt;/em&gt; and &lt;em&gt;u&lt;/em&gt;: upper and lower bounds for each wrapping, in our case all objects can equally be positioned on the wrapping, hence the lower bound is 0 and the upper bound the size of the roll (minus one if you care about millimeters and took no margins of error at all in your measurements) &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Then &lt;code&gt;geost_bb&lt;/code&gt; then contributes constraints to tell the solver to make a number of decisions:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;x&lt;/code&gt;: the coordinates of the &lt;em&gt;wrapping shapes&lt;/em&gt; (which are themselves built of rectangular blocks). For our sword example, we need to add the &lt;code&gt;rect_offset&lt;/code&gt; to the &lt;code&gt;x&lt;/code&gt; coordinate of the shape to position a rectangle. &lt;/li&gt; &lt;li&gt;&lt;code&gt;kind&lt;/code&gt;: the shape used by each object. This mechanism allows &lt;code&gt;geost_bb&lt;/code&gt; to chose any shape for the different objects. External constraints actually prevent &lt;code&gt;geost_bb&lt;/code&gt; does not know how many times it must be using the wrapping-shape for a sword, and unconstrained the solver would rather prefer the simpler wrapping-shape for a book. This mechanism actually is a feature: the freedom to pick among shapes allows to model rotation of shapes, we will not use this for now. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;In our case, for a first version of the tool we do not need to make that many decisions: only &lt;code&gt;x&lt;/code&gt; above is required. Declaring all inputs to give to &lt;code&gt;geost_bb&lt;/code&gt; is required, however. We still need to actually declare our &lt;code&gt;par&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; variables.&lt;/p&gt; &lt;p&gt;We will have to discuss about a number of entities:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;two dimensions: &lt;code&gt;int: nDims = 2; set of int: DIM = 1..nDims&lt;/code&gt; &lt;/li&gt; &lt;li&gt;wrapping shapes: &lt;code&gt;int: nShapes; set of int: SHAPE = 1..nShapes&lt;/code&gt; &lt;/li&gt; &lt;li&gt;rectangular blocks: &lt;code&gt;int: nBlocks; set of int: BLOCK = 1..nBlocks&lt;/code&gt; &lt;/li&gt; &lt;li&gt;each object we need to wrap: &lt;code&gt;int: nObjs; set of int: OBJ = 1..nObjs&lt;/code&gt; &lt;/li&gt; &lt;li&gt;the roll: it is implicit that we cut one roll, so we do not need to declare anything &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Then, some characteristics of entities:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;the size of the roll: &lt;code&gt;int: x_max; int: y_max&lt;/code&gt; &lt;/li&gt; &lt;li&gt;the size of individual rectangular blocks and their offsets in each dimension: &lt;code&gt;array[BLOCK,DIM] of int: rect_sizes; array[BLOCK,DIM] of int: rect_offs&lt;/code&gt; &lt;/li&gt; &lt;li&gt;the coordinates of where to position cuts for our solution: &lt;code&gt;array[OBJ,DIM] of var int: coordinates&lt;/code&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Finally there is relational information linking various entities.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;to each object we associate a given shape (present1 is a Guitar, present2 is a book etc.): &lt;code&gt;array[OBJ] of SHAPE: object_shapes;&lt;/code&gt; &lt;/li&gt; &lt;li&gt;each shape is the collage of a set of rectangle, we could use various external representation to model the set of rectangles (e.g., an &lt;code&gt;array[SHAPE,RECTANGLE] of bool&lt;/code&gt; is isomorphic to an &lt;code&gt;array[SHAPE] of set of RECTANGLE&lt;/code&gt;) but we will stick to the &lt;code&gt;set&lt;/code&gt; representation that &lt;code&gt;geost_bb&lt;/code&gt; requires (using another input would require extra constraints to link input and &lt;code&gt;geost_bb&lt;/code&gt; representations) &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;All in all, the model is in &lt;code&gt;models/santa-wrap.mzn&lt;/code&gt; and an example input for it is &lt;code&gt;models/santa-wrap001.dzn&lt;/code&gt;. You can run it with &lt;code&gt;minizinc models/santa-wrap.mzn models/santa-wrap001.dzn&lt;/code&gt;. And the output I got was:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;coordinates = array2d(1..10, 1..2, [8, 0, 0, 6, 7, 0, 0, 5, 6, 0, 0, 4, 4, 0, 0, 2, 2, 0, 0, 0]); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Which you can read as ‚Äúfirst object‚Äù is a (8,0), the ‚Äúsecond object‚Äù is at (0,6) etc. Elves could work with such an output, however a visual display is better. Plus they want to prepare their cutting boards, build guides, or simply pass an eye-check that things are in the right place.&lt;/p&gt; &lt;h3 id="generate-simple-pictures"&gt;Generate simple pictures&lt;/h3&gt; &lt;p&gt;I have had little interest in graphics in the past. Thus I vaguely know some Haskell libraries exist like &lt;a href="https://hackage.haskell.org/package/diagrams"&gt;diagrams&lt;/a&gt;, &lt;code&gt;gloss&lt;/code&gt;, &lt;code&gt;JuicyPixels&lt;/code&gt;, or &lt;a href="https://hackage.haskell.org/package/reanimate"&gt;reanimate&lt;/a&gt;. For this project, I had to dive a bit more and actually pick some library. My choice settled on &lt;code&gt;JuicyPixel&lt;/code&gt; for two main reasons: on the first hand, this library has only a small amount of dependencies (especially system dependencies ‚Äì &lt;code&gt;gloss&lt;/code&gt; requires some OpenGL). On the other hand, the documentation was welcoming: I looked for &lt;code&gt;IO ()&lt;/code&gt; because I looked for some ‚Äúmain‚Äù or ‚Äúprint‚Äù equivalent. The first hit on the top module is &lt;code&gt;generateImage&lt;/code&gt;. No kidding, here is the screenshot to prove it: first hit &lt;img src="images/haddock-jp.png" alt="img" /&gt;.&lt;/p&gt; &lt;p&gt;The type information tells me the library actually scans every pixel one by one. It is very likely super inefficient. That said, the cost of optimizing the packing is the major bottleneck in this problem. Elves can wait a minute to save hours. A warming case that does not corroborate the claim that Haskell libraries are poorly documente. My first action was to verify that the example actually works.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-shell"&gt;cabal repl &amp;gt; import Code.Picture &amp;gt; let path = &amp;quot;images/background.png&amp;quot; &amp;gt; let pixelRenderer x y = PixelRGB8 (fromIntegral x) (fromIntegral y) &amp;gt; writePng path $ generateImage pixelRenderer 250 300 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;And voila! &lt;img src="images/background.png" alt="img" /&gt; thank you so much &lt;code&gt;JuicyPixels&lt;/code&gt;. It‚Äôs not ‚Äútoo good to be true‚Äù: the example works.&lt;/p&gt; &lt;p&gt;Having secured that I can generate PNG, what is left? we need to define some Haskell data types to map loosely with what I‚Äôve learnt is required in the MiniZinc optimization. However we‚Äôll be using Haskell records rather than columnar values. The idea here is to use these data types as main Haskell types for parsing a format that Elves are likely to know such as JSON. Further we want to allow Elves to pass extra information like quantities of each present they will wrap, colors and names for pictures before crafting the guides etc.&lt;/p&gt; &lt;p&gt;Some excerpt:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; {&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; name ::&lt;/span&gt; &lt;span class="dt"&gt;Name&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; colorNum ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; quantity ::&lt;/span&gt; &lt;span class="dt"&gt;Quantity&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rectangles ::&lt;/span&gt; [ &lt;span class="dt"&gt;Rectangle&lt;/span&gt; ]&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt;&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt; {&lt;/span&gt; &lt;span id="10"&gt;&lt;a href="#10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; rectX ::&lt;/span&gt; &lt;span class="dt"&gt;Length&lt;/span&gt;&lt;/span&gt; &lt;span id="11"&gt;&lt;a href="#11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rectY ::&lt;/span&gt; &lt;span class="dt"&gt;Length&lt;/span&gt;&lt;/span&gt; &lt;span id="12"&gt;&lt;a href="#12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; offX ::&lt;/span&gt; &lt;span class="dt"&gt;X&lt;/span&gt;&lt;/span&gt; &lt;span id="13"&gt;&lt;a href="#13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; offY ::&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt;&lt;/span&gt; &lt;span id="14"&gt;&lt;a href="#14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="15"&gt;&lt;a href="#15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Wrappings are built of Rectangles. Each Rectangle as length/width (lengths in both dimensions &lt;code&gt;rectX&lt;/code&gt;, &lt;code&gt;rectY&lt;/code&gt;) as well as some offset in both dimension. In addition, each Wrapping has a name, a quantity and some color to visualize more easily a layout. But before speaking about Layouts, what we can do is to generate pictures for each Wrapping. This way, Elves can calibrate the units and verify individual length.&lt;/p&gt; &lt;p&gt;I need to adapt the &lt;code&gt;JuicyPixels&lt;/code&gt; example I copy pasted to build a function &lt;code&gt;printWrapping :: Wrapping -&amp;gt; IO()&lt;/code&gt;. In short, it has a &lt;code&gt;Wrapping&lt;/code&gt; and its associated &lt;code&gt;Rectangles&lt;/code&gt; in scope and we need to implement &lt;code&gt;pixelRenderer&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;So I‚Äôll build utility functions &lt;code&gt;findRectangle x y&lt;/code&gt; which finds a rectangle with the right sizes and offset to contain the pixel &lt;code&gt;(x,y)&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;A single pixel and rectangle test is&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rectangleContainsPixel x y rect &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;let&lt;/span&gt; x0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offX rect&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; x1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offX rect &lt;span class="op"&gt;+&lt;/span&gt; rectX rect&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offY rect&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offY rect &lt;span class="op"&gt;+&lt;/span&gt; rectY rect&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;in&lt;/span&gt; x0 &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; x &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; x &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; x1 &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; y0 &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; y &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; y &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; y1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Which checks for intervals in both X and Y. The &lt;code&gt;scale&lt;/code&gt; function just multiplies tenfold every magnitude (i.e., a dimension of 1 Length is shown with 10 pixel). With that utility function we can now test every rectangles: if some is found, we color the Pixel with some value, otherwise we use default background value.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;pixelRenderer x y &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;case&lt;/span&gt; findRectangle x y &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;PixelRGB8&lt;/span&gt; (&lt;span class="fu"&gt;fromIntegral&lt;/span&gt; x &lt;span class="ot"&gt;`mod`&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;) (&lt;span class="fu"&gt;fromIntegral&lt;/span&gt; y &lt;span class="ot"&gt;`mod`&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;) &lt;span class="dv"&gt;128&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Just&lt;/span&gt; idx &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; pixelColor idx&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;findRectangle x y &lt;span class="ot"&gt;=&lt;/span&gt; List.findIndex (rectangleContainsPixel x y) (rectangles wrapping)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;I use &lt;code&gt;List.findIndex&lt;/code&gt; so that on a hit i can also attribute some color (see &lt;code&gt;pixelColor :: Int -&amp;gt; PixelRGB8&lt;/code&gt; which defines a palette) and paint the rectangle in a different color.&lt;/p&gt; &lt;p&gt;Another utility function is needed to give &lt;code&gt;JuicyPixel&lt;/code&gt; the size of the picture to create. This size corresponds to the farthest point in the set of off-set rectangles &lt;code&gt;maxX = maximum (0 : [ rectX r + offX r | r &amp;lt;- rectangles wrapping ])&lt;/code&gt;, I named this value the &lt;code&gt;extentX&lt;/code&gt; of a &lt;code&gt;Wrapping&lt;/code&gt; in later commits. I use comprehension list notation. I add a 0 so that &lt;code&gt;maximum&lt;/code&gt; does not crash on an empty list.&lt;/p&gt; &lt;p&gt;Our &lt;code&gt;main&lt;/code&gt; function basically parses &lt;code&gt;stdin&lt;/code&gt; into some &lt;code&gt;[Wrapping]&lt;/code&gt; and &lt;code&gt;traverse&lt;/code&gt; this list with our PNG generator.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;mainParts &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; wrappings &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; eitherDecode&amp;#39; &lt;span class="op"&gt;@&lt;/span&gt;[&lt;span class="dt"&gt;Wrapping&lt;/span&gt;] &lt;span class="op"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="fu"&gt;getContents&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;case&lt;/span&gt; wrappings &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Left&lt;/span&gt; err &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;print&lt;/span&gt; err&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Right&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; traverse_ printWrapping xs&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="fu"&gt;putStrLn&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;done!&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The parsing leverages the automatically-generated &lt;code&gt;instance FromJSON&lt;/code&gt; from &lt;code&gt;aeson&lt;/code&gt; (extension &lt;code&gt;DeriveGeneric&lt;/code&gt;). Note that we use &lt;code&gt;TypeApplications&lt;/code&gt; for the syntax &lt;code&gt;@[Wrapping]&lt;/code&gt; which explicitates what we are decoding from the content in &lt;code&gt;stdin&lt;/code&gt;, which also helps GHC provide less general error message when I change and break things.&lt;/p&gt; &lt;p&gt;This way, our main binary can generate individual images.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-console"&gt;$ santa-wrap parts &amp;lt; input/wrapping001.json $ done! &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The parts are individual &lt;code&gt;.png&lt;/code&gt; files as this listing shows: &lt;img src="images/parts.png" alt="img" /&gt;. Elves can use these parts to prepare some guides to later cut wrapping paper rapidly.&lt;/p&gt; &lt;p&gt;Now let‚Äôs finally introduce the concept of layout.&lt;/p&gt; &lt;h3 id="introduce-the-notion-of-layout"&gt;Introduce the notion of layout&lt;/h3&gt; &lt;p&gt;The layout is a collection of positioned wrappings. There‚Äôs an obvious Functor instance for Positioned. I could refactor Rectangle into a Positioned Rect. This way, a Layout is a &lt;code&gt;[ Positioned [ Positioned Rect ] ]&lt;/code&gt; and it is probably collapsable into a single list by translating the inner Positioned objects. Something like &lt;code&gt;flatten :: [ Positioned [ Positioned a ] ] -&amp;gt; [ Positioned a ]&lt;/code&gt; I feel tempted to actually dig in this direction. However, I‚Äôm far from done and the clock ticks. In short, I will save this for later and perform a good amount of copy-pasting.&lt;/p&gt; &lt;p&gt;The Haskell code is simply:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; {&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; posX ::&lt;/span&gt; &lt;span class="dt"&gt;X&lt;/span&gt; &lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; posY ::&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt; &lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; item ::&lt;/span&gt; a &lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Functor&lt;/span&gt;)&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt; {&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; positionedWrappings ::&lt;/span&gt; [ &lt;span class="dt"&gt;Positioned&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; ]&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;And now my &lt;code&gt;printLayout&lt;/code&gt; function has a very similar &lt;code&gt;pixelRenderer&lt;/code&gt;. Two distinctions though:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;to color a pixel you need to determines if a &lt;code&gt;Wrapping&lt;/code&gt; has a &lt;code&gt;Rectangle&lt;/code&gt; and the &lt;code&gt;Rectangles&lt;/code&gt; are translated by &lt;code&gt;posX&lt;/code&gt; and &lt;code&gt;posY&lt;/code&gt;. &lt;/li&gt; &lt;li&gt;we want to add a few pixels of &lt;code&gt;margin&lt;/code&gt; so that a series of adjacent squares do not appear like a long rectangle, this small margin will ease verifying layouts at a glance. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Hence, our &lt;code&gt;rectangleContainsPixel&lt;/code&gt; test takes all these things into account:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;rectangleContainsPixel ::&lt;/span&gt; &lt;span class="dt"&gt;X&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rectangleContainsPixel posx posy x y rect &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;let&lt;/span&gt; x0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posx &lt;span class="op"&gt;+&lt;/span&gt; offX rect&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; x1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posx &lt;span class="op"&gt;+&lt;/span&gt; offX rect &lt;span class="op"&gt;+&lt;/span&gt; rectX rect&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posy &lt;span class="op"&gt;+&lt;/span&gt; offY rect&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posy &lt;span class="op"&gt;+&lt;/span&gt; offY rect &lt;span class="op"&gt;+&lt;/span&gt; rectY rect&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;in&lt;/span&gt; (x0 &lt;span class="op"&gt;+&lt;/span&gt; margin) &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; x &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; x &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; (x1 &lt;span class="op"&gt;-&lt;/span&gt; margin) &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; (y0 &lt;span class="op"&gt;+&lt;/span&gt; margin) &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; y &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; y &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; (y1 &lt;span class="op"&gt;-&lt;/span&gt; margin)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;How do you verify that the margin is pretty enough? Simply generate a naive Layout function. We just lay out shapes left-to-right.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;linearLayout ::&lt;/span&gt; [ &lt;span class="dt"&gt;Wrapping&lt;/span&gt; ] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;linearLayout wrappings &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; List.zipWith (\w (x,y) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; x y w) wrappings xys&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; xys ::&lt;/span&gt; [(&lt;span class="dt"&gt;X&lt;/span&gt;,&lt;span class="dt"&gt;Y&lt;/span&gt;)]&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; xys &lt;span class="ot"&gt;=&lt;/span&gt; List.scanl placeToTheLeft (&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;) wrappings &lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; placeToTheLeft ::&lt;/span&gt; (&lt;span class="dt"&gt;X&lt;/span&gt;, &lt;span class="dt"&gt;Y&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="dt"&gt;X&lt;/span&gt;, &lt;span class="dt"&gt;Y&lt;/span&gt;)&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; placeToTheLeft (x,y) w &lt;span class="ot"&gt;=&lt;/span&gt; (x &lt;span class="op"&gt;+&lt;/span&gt; extentX w, &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The interesting aspect is the use of &lt;code&gt;List.scanl&lt;/code&gt; to perform a fold an accumulate intermediary values. The accumulator is the position for the next &lt;code&gt;Wrapping&lt;/code&gt; (hence, we start at &lt;code&gt;(0,0)&lt;/code&gt; and then we move right by an amount large enough to ensure there will be no overlap: what we named the &lt;em&gt;extent&lt;/em&gt; of the wrapping shape.&lt;/p&gt; &lt;p&gt;This function does not even take care of the bounds of the roll. This function is merely useful to have some comparison point and to exercise the &lt;code&gt;printLayout&lt;/code&gt; function.&lt;/p&gt; &lt;p&gt;Running the following command will give the image below.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-console"&gt;$ santa-wrap linear-layout ./layout.png &amp;lt; input/wrapping003.json done! &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;img src="images/linear-layout.png" alt="img" /&gt;&lt;/p&gt; &lt;p&gt;Now we see the margins, the coloring. We also have a MiniZinc model for non-naive layouts. Let‚Äôs bring the two things together.&lt;/p&gt; &lt;h3 id="actually-bridge-the-haskell-and-minizinc-code"&gt;Actually bridge the Haskell and MiniZinc code&lt;/h3&gt; &lt;p&gt;Showcasing my &lt;code&gt;minizinc-process&lt;/code&gt; library is, a main motivator (second to saving Christmas‚Äô spirit, though).&lt;/p&gt; &lt;p&gt;Remember that, we want to approach ergonomics for the solver so that in Haskell-land it feels like we have a function &lt;code&gt;solver :: Model -&amp;gt; Parameters -&amp;gt; Maybe Decisions&lt;/code&gt;. Here enters &lt;code&gt;minizinc-process&lt;/code&gt;, an helper library that actually uses MiniZinc support for JSON input/outputs. This is feasible with &lt;code&gt;runLastMinizincJSON&lt;/code&gt;, which has type:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;runLastMinizincJSON ::&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; (&lt;span class="dt"&gt;ToJSON&lt;/span&gt; input, &lt;span class="dt"&gt;FromJSON&lt;/span&gt; answer) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;MiniZinc&lt;/span&gt; input answer &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; input &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;Maybe&lt;/span&gt; answer)&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;runLastMinizincJSON &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The typeclass constraints on &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; allow to serialize back and forth using JSON. The &lt;code&gt;Minizinc input answer&lt;/code&gt; actually contains the model (e.g., a filepath to the &lt;code&gt;models/santa-wrap.mzn&lt;/code&gt; file) and parameters for driving MiniZinc (i.e., which solver to use, whether there is a timeout or to search forever, but also, how to create intermediary &lt;code&gt;.json&lt;/code&gt; input files that play the role of the &lt;code&gt;models/santa-wrap001.dzn&lt;/code&gt; for each different possible input). For this project, we use the &lt;code&gt;simpleMiniZinc&lt;/code&gt; constructor to get a &lt;code&gt;Minizinc&lt;/code&gt;that also adds some &lt;code&gt;Hashable&lt;/code&gt; constraint on the input type so that we can generate filenames. Fortunately, &lt;code&gt;Hashable&lt;/code&gt; is generically-derivable as well so little boilerplate is incured.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;runLastMinizincJSON&lt;/code&gt; functions runs for up to the timeout provided in the MiniZinc option and return the latest decisions (if there is any). A more general function &lt;code&gt;runMinizincJSON&lt;/code&gt; exists. This function takes a state-machine named &lt;code&gt;ResultHandler&lt;/code&gt; to handle individual results. Indeed, we can ask MiniZinc to return multiple solutions, prove that there are no more solutions, and handling this variety of cases asks for more complicated types.&lt;/p&gt; &lt;p&gt;The underlying type are:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;SearchState&lt;/span&gt; a&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Exhausted&lt;/span&gt; a&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Incomplete&lt;/span&gt; a&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Unsatisfiable&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;InternalError&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;ResultHandler&lt;/span&gt; obj b&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ResultHandler&lt;/span&gt;&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; {&lt;span class="ot"&gt; handleNext ::&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;SearchState&lt;/span&gt; obj &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (b, &lt;span class="dt"&gt;Maybe&lt;/span&gt; (&lt;span class="dt"&gt;ResultHandler&lt;/span&gt; obj b))&lt;/span&gt; &lt;span id="10"&gt;&lt;a href="#10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The result handler is parametrized by &lt;code&gt;obj&lt;/code&gt; which are the decisions that the solver makes, and the handler is also parametrized by &lt;code&gt;b&lt;/code&gt; ‚Äì an accumulator state like in a fold. A handler is called each time the search changes SearchState. The handler is free to do what it wants but must return an updated state and an updated handler (or an absence of handler to tell the library that we can stop the search). Later versions of the library will likely generalize IO in the handler to some parametric class.&lt;/p&gt; &lt;p&gt;There is not much more to &lt;code&gt;minizinc-process&lt;/code&gt;. Let‚Äôs use it in practice.&lt;/p&gt; &lt;p&gt;We need to translate two worldviews for the same information, back and forth. MiniZinc expects data in array shapes and other parameters giving the length of these arrays whereas our Haskell data is meant to help interactions with users. Hence, the Haskell datatypes closely follow Elf-semantics. Typically, translation code between two worldviews benefits from careful newtypes to distinguish array indices. Indeed, every entity becomes identified by an index and it is all too common to make an error. Multi-dimensional arrays have some support for types in MiniZinc but the data serialized in JSON do not.&lt;/p&gt; &lt;p&gt;The risk we want to reduce is to mix-up array indices and mix-up the terminology. This is where newtypes shine in Haskell. Two extensions, &lt;code&gt;DerivingStrategies&lt;/code&gt; and &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; come handy to save on boilerplate.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; stock &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; stock &lt;span class="dt"&gt;Eq&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Hashable&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; stock &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Hashable&lt;/span&gt;&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;We can now write an Haskell data type for the input. This data type has fields mapping closely the names of &lt;code&gt;par&lt;/code&gt; variables in MiniZinc (which you find declared in the &lt;code&gt;./models/santa-wrap001.dzn&lt;/code&gt;). Arrays map to lists, two dimensional arrays become nested lists. Sets required me to define an indirection named &lt;code&gt;MinizincSet&lt;/code&gt; (will be merged upstream) to match MiniZinc expectations for its JSON inputs. Thus, my Input and Output types become.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt; {&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; nBlocks ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rect_sizes ::&lt;/span&gt; [[&lt;span class="dt"&gt;Int&lt;/span&gt;]]&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rect_offs ::&lt;/span&gt; [[&lt;span class="dt"&gt;Int&lt;/span&gt;]]&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; nShapes ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; shapes ::&lt;/span&gt; [ &lt;span class="dt"&gt;MinizincSet&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; ]&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; nObjs ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; object_shapes ::&lt;/span&gt; [ &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; ]&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; x_max ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="10"&gt;&lt;a href="#10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; y_max ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="11"&gt;&lt;a href="#11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="12"&gt;&lt;a href="#12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Hashable&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt;&lt;/span&gt; &lt;span id="13"&gt;&lt;a href="#13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt;&lt;/span&gt; &lt;span id="14"&gt;&lt;a href="#14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="15"&gt;&lt;a href="#15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt; {&lt;/span&gt; &lt;span id="16"&gt;&lt;a href="#16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; coordinates ::&lt;/span&gt; [ (&lt;span class="dt"&gt;X&lt;/span&gt;, &lt;span class="dt"&gt;Y&lt;/span&gt;) ]&lt;/span&gt; &lt;span id="17"&gt;&lt;a href="#17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; }&lt;/span&gt; &lt;span id="18"&gt;&lt;a href="#18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="19"&gt;&lt;a href="#19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The rest of the work now requires to build a &lt;code&gt;convertInput&lt;/code&gt; function that takes Haskell domain values, map that into an Input. This mapping will require to give integral IDs to entities. For instance, each individual &lt;code&gt;Wrapping&lt;/code&gt; in the input requires as many &lt;code&gt;OBJECT&lt;/code&gt; as the &lt;code&gt;quantity&lt;/code&gt; requires. I typically use list-comprehensions and zipping with &lt;code&gt;[1..]&lt;/code&gt; to achieve this indexing.&lt;/p&gt; &lt;p&gt;For instance, each &lt;code&gt;Wrapping&lt;/code&gt; has one &lt;code&gt;SHAPE&lt;/code&gt; in our problem. Thus, we provide an indexed list of shapes and its ‚Äúoriginating‚Äù &lt;code&gt;Wrapping&lt;/code&gt; as follows.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;indexedWrappings ::&lt;/span&gt; [(&lt;span class="dt"&gt;ShapeIdx&lt;/span&gt;, &lt;span class="dt"&gt;Wrapping&lt;/span&gt;)]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;indexedWrappings &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;zip&lt;/span&gt; (&lt;span class="fu"&gt;fmap&lt;/span&gt; &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;]) wrappings&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;BLOCK&lt;/code&gt; and their &lt;code&gt;rect_sizes, rect_offs&lt;/code&gt; are a bit more complicated. To build everything we want, we need a ‚Äútable‚Äù with, for each SHAPE, what BLOCK it is made of, and the ‚Äúoriginating‚Äù &lt;code&gt;Rectangle&lt;/code&gt; to get carry the sizes and offsets.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;indexedRects ::&lt;/span&gt; [(&lt;span class="dt"&gt;ShapeIdx&lt;/span&gt;, &lt;span class="dt"&gt;BlockIdx&lt;/span&gt;, &lt;span class="dt"&gt;Rectangle&lt;/span&gt;)]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;indexedRects &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;zipWith&lt;/span&gt; (\blockIdx (shapeIdx, r) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (shapeIdx, blockIdx, r))&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; (&lt;span class="fu"&gt;fmap&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; [ &lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt; ])&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; [ (shapeIdx, r) &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx,w) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedWrappings, r &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; rectangles w ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;We can then compute the number of &lt;code&gt;BLOCK&lt;/code&gt;, which is &lt;code&gt;nBlocks = length indexedRects&lt;/code&gt;. An optimization could have been to share equal blocks when shared across &lt;code&gt;SHAPEs&lt;/code&gt; (i.e., when a same &lt;code&gt;Rectangle&lt;/code&gt; appears in two &lt;code&gt;Wrappings&lt;/code&gt;). Let‚Äôs not suffer from early optimization.&lt;/p&gt; &lt;p&gt;We can now build the &lt;code&gt;rect_sizes&lt;/code&gt; and &lt;code&gt;rect_offs&lt;/code&gt; of each &lt;code&gt;BLOCK&lt;/code&gt; by directly looking at the values associated in the ‚Äúoriginating‚Äù &lt;code&gt;Rectangle&lt;/code&gt;.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rect_sizes &lt;span class="ot"&gt;=&lt;/span&gt; [ [rectX r, rectY r] &lt;span class="op"&gt;|&lt;/span&gt; (_,_,r) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedRects ]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rect_offs &lt;span class="ot"&gt;=&lt;/span&gt; [ [offX r, offY r] &lt;span class="op"&gt;|&lt;/span&gt; (_,_,r) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedRects ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;and the relational information ‚Äúwhich SHAPE contains which BLOCK‚Äù is a reading of the ‚Äòjoin‚Äô of the &lt;code&gt;indexedRects&lt;/code&gt; and the &lt;code&gt;indexedWrappings&lt;/code&gt; tables. Again, we use comprehension-lists to the cardinal product of the two tables (and collecting that in &lt;code&gt;MinzincSet&lt;/code&gt;).&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;shapes &lt;span class="ot"&gt;=&lt;/span&gt; [ &lt;span class="dt"&gt;MinizincSet&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; [ blockIdx &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx2,blockIdx,_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedRects&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; , shapeIdx1 &lt;span class="op"&gt;==&lt;/span&gt; shapeIdx2&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ]&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx1,_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedWrappings&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Performance could become a concern for large amount of &lt;code&gt;Wrapping&lt;/code&gt; and large amount of &lt;code&gt;Rectangle&lt;/code&gt;. However, again, we are not chasing seconds in serialization/translation code as we are ready to spend minutes of solver-time to saves hours to our Elves. If data proves this piece of code is the bottleneck in practice, we can then try to optimize further this type of code. Since the code is pure, it is really amenable to property testing under QuickCheck or HedgeHog: for any data, both the (slow)-reference and (putatively-optimized)-candidate functions are returning equal outputs.&lt;/p&gt; &lt;p&gt;Finally, our MiniZinc model wants &lt;code&gt;OBJECT&lt;/code&gt;, one per present rather than one per Wrapping objects (the Haskell data model holds a quantity). I mistakenly did two things at a time: expanding quantities and associating a Shape to each Wrapping. &lt;code&gt;flattenedWrappings&lt;/code&gt; in the heat to release something early for our Elves.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;flattenedWrappings ::&lt;/span&gt; [(&lt;span class="dt"&gt;ShapeIdx&lt;/span&gt;, &lt;span class="dt"&gt;Wrapping&lt;/span&gt;)]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;flattenedWrappings &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;mconcat&lt;/span&gt; [ &lt;span class="fu"&gt;replicate&lt;/span&gt; (quantity w) (shapeIdx, w) &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx, w) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedWrappings ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;This code means that if we have &lt;code&gt;Wrapping { name = abc , quantity = 2 }&lt;/code&gt; and &lt;code&gt;Wrapping {name = def, quantity = 5}&lt;/code&gt; then we have to lay out seven &lt;code&gt;OBJECT&lt;/code&gt;, two of &lt;code&gt;SHAPE&lt;/code&gt; associated to &lt;code&gt;abc&lt;/code&gt; and five of &lt;code&gt;SHAPE&lt;/code&gt; associated to &lt;code&gt;def&lt;/code&gt;. The corresponding boilerplate is:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;nObjs &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;length&lt;/span&gt; flattenedWrappings&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;object_shapes &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;fmap&lt;/span&gt; &lt;span class="fu"&gt;fst&lt;/span&gt; flattenedWrappings&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;I think this covers most of the boiler-plate. Extra function arguments are the size of the roll&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;x_max &lt;span class="ot"&gt;=&lt;/span&gt; sizeX&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;y_max &lt;span class="ot"&gt;=&lt;/span&gt; sizeY&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;It is tempting to just write the ‚Äúforward translation code‚Äù and call it a day. In reality, if you were a consumer of such a library, you would like to minimize this horrendous boiler plate, and you still need some ‚Äúreverse translation code‚Äù. Be kind to your users. You have done a lot of work to create ‚Äúindexed‚Äù arrays once, you‚Äôd rather not duplicate this code. Even if you do not duplicate the code, having colocated everything within the constraints of a pure function will guarantee you that no non-determinism creeps in. Hence, you should make a ‚Äúreverse translation function‚Äù at the same time as you translate forward. Bonus: you can guarantee that calls of unsafe functions (like array indexing) actually are safe because you are writing the providing and consuming dynamically-shaped data at the same place.&lt;/p&gt; &lt;p&gt;Indeed, because we have access to &lt;code&gt;flattenedWrappings&lt;/code&gt; our ‚Äúreverse translation code‚Äù is a single line.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;layoutOutput ::&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;layoutOutput (&lt;span class="dt"&gt;Output&lt;/span&gt; coords) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;zipWith&lt;/span&gt; (\w (x,y) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; x y w) [w &lt;span class="op"&gt;|&lt;/span&gt; (_,w) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; flattenedWrappings] coords&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Writing all this boilerplate takes time (hence why I circled it red at the beginning in my dependency graph for the tasks in this project). Such translation code would be hard to generate in the general case. Hence I do not have very good solutions but to be careful and use &lt;code&gt;newtype&lt;/code&gt; for each index. The good news, however, is that it is pretty easy to debug: generate simple cases with one then two &lt;code&gt;Wrapping&lt;/code&gt;, observe the generated &lt;code&gt;.json&lt;/code&gt; file.&lt;/p&gt; &lt;p&gt;At last we can be gratified. A simple &lt;code&gt;main&lt;/code&gt; that ressembles the one for &lt;code&gt;linearLayout&lt;/code&gt; allows us to generate layouts for given roll sizes.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-console"&gt;$ santa-wrap minizinc-layout ./layout-190x150.png 190 150 &amp;lt; input/wrapping003.json done! $ santa-wrap minizinc-layout ./layout-170x160.png 170 160 &amp;lt; input/wrapping003.json done! $ santa-wrap minizinc-layout ./layout-170x159.png 170 159 &amp;lt; input/wrapping003.json no layout found! &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The first command greets us with the following picture &lt;img src="./images/layout-190x150.png" alt="img" /&gt;. We can try shrinking the Y-coordinates, 160 is still good, but 159 is too hard (note: it is actually infeasible but the &lt;code&gt;runLastMinizincJSON&lt;/code&gt; function makes no distinctions between timeout and unfeasible). Visual inspection of the Y=160 case seems to show that the two cross-shaped and the big rectangle are the main reasons to limit the roll size &lt;img src="./images/layout-190x150.png" alt="img" /&gt;.&lt;/p&gt; &lt;p&gt;Convince yourself with this picture (done by modifying the input JSON to delete everything but the &lt;em&gt;shoes&lt;/em&gt; and the &lt;em&gt;sword&lt;/em&gt; entries: &lt;img src="./images/layout-restricted.png" alt="img" /&gt;.&lt;/p&gt; &lt;p&gt;OK, with this &lt;code&gt;santa-wrap&lt;/code&gt; tool, Elves are in good shape to save Christmas‚Äô spirit. Thank you MiniZinc and Haskell!&lt;/p&gt; &lt;p&gt;For the fun try packing that yourselves (input is &lt;code&gt;input/wrapping005.json&lt;/code&gt;) &lt;img src="images/layout-robot-200x240.png" alt="img" /&gt;&lt;/p&gt; &lt;h2 id="discussion"&gt;Discussion&lt;/h2&gt; &lt;p&gt;Given more times, a number of possible improvements could happen. For a work project more discussions with the Elves would help adding more constraints to the Model. We next discuss some possible ‚Äúimprovements‚Äù.&lt;/p&gt; &lt;h3 id="possible-improvements"&gt;Possible improvements&lt;/h3&gt; &lt;p&gt;Elves have deadlines too, although they would love to keep improving their tools, they have other important (albeit slightly more mundane) tasks at their day jobs. Besides the discussion about Positioned being an interesting abstraction, I want to discuss improvements to the solver/problem itself and illustrate how business ideas are generated/pruned with such discussions.&lt;/p&gt; &lt;p&gt;A user may suggest improvements to the tool, but not all improvements are equally easy to introduce. Here are a few options:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;easy: reduce some cost (material spent) ; you would need to change the satisfyability into some optimiziation trying to minimize the area bounded by maximum X-Y coordinates &lt;/li&gt; &lt;li&gt;medium: pick an orientation (left-right vs. up-down) ; you would need to change Input, Output, and the model to tell which shapes an object can take, but &lt;code&gt;geost&lt;/code&gt; already takes care of that &lt;/li&gt; &lt;li&gt;hard: attribute multiple rolls at once ; you would need to change Input, Output, and the model to pass a number rolls (maybe to each one their size) and modify the MiniZinc model to decide a roll for each object; you‚Äôd generate two pictures per problem &lt;/li&gt; &lt;li&gt;crazy-hard: time taken to cut with cissors ; you would need to significantly alter the model to express the notion of ‚Äúgaps‚Äù or ‚Äúexternal‚Äù. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;In a typical setup I would propose to deliver the easy and medium improvements before calling the tool done. I would suggest to propose the hard improvement as more data is generated to understand if Elves actually would benefit from such changes. I would root against the crazy hard, and even propose to equip Elves with cutting-tools and drop cissors would probably use total surface as a good enough proxy, simulators can help assess how bad.&lt;/p&gt; &lt;p&gt;Elves would love to hear about your improvement suggestions or merge requests! Feel free to contact me or to open some Issues to discuss them together.&lt;/p&gt; &lt;h3 id="epilogue"&gt;Epilogue&lt;/h3&gt; &lt;p&gt;Alright, this blog post was longer than I expected. I wanted to show how Haskell can be used to solve a very practical problem and also put onto words some ‚Äútactical thinking‚Äù to avoid losing time on the less-important aspects (the one I have not circled red in my dependency diagram). My main challenge was to time-box my work to one day of code: on top of my Elvish missions I have a day job and all-in-all this is a good constraint to simulate a real-world situation. The information I had before starting: I knew &lt;code&gt;JuicyPixels&lt;/code&gt; existed but had never used it before, I sort of framed the Santa-Wrap problem to illustrate a non-trivial MiniZinc global (&lt;code&gt;geost_bb&lt;/code&gt; arguably is pretty advanced). I built the &lt;code&gt;minizinc-process&lt;/code&gt; library and wanted a pretext to show-case it. I could have taken a shortcut as &lt;code&gt;minizinc-process&lt;/code&gt; offers some TemplateHaskell to generate &lt;code&gt;Input&lt;/code&gt; and &lt;code&gt;Output&lt;/code&gt; datatypes (with no newtypes and no support for sets, the pedagogy would have suffered).&lt;/p&gt; &lt;p&gt;An advantage of the Haskell + MiniZinc combination is to be able to use each tool for what they are best at. Haskell allows me to write solid backend services and command line tools whereas MiniZinc allows me to model using MiniZinc IDE (e.g., with a nice syntax for multi-dimensional arrays). In this setup the key difficulty is the boilerplate code required to translate inputs and outputs.&lt;/p&gt; &lt;p&gt;I hope this article piqued your interest. Feel free to contact me if you are curious whether these types of techniques are a good fit for you. I gave a presentation of MiniZinc at an online event this year, and you will find much more on the website and on the Coursera lessons (time consuming).&lt;/p&gt; &lt;p&gt;Thanks to Advent of Haskell organizers and all the other articles authors.&lt;/p&gt; &lt;p&gt;I wish you all the best for the end of 2020 and cheers to a better 2021!&lt;/p&gt; &lt;p&gt;Oh oh oh!&lt;/p&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/santa-wrap.html" rel="alternate"/>
        <summary type="text">
            We help Santa Elves optimize cutting wrapping paper to accomodate various shapes. The difficult optimization requires a dedicated solver in MiniZinc. Haskell allows to integrate with MiniZinc, reads JSON and outputs a PNG image with the footprint of the positionned shapes to cut. This article shows that a one-day-of-work project can reach pretty far.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/talks.html
        </id>
        <title type="text">
            Talks and Docs
        </title>
        <updated>
            1970-01-01T00:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;I am a bit more quiet now that I have a daughter and now that the pandemic started devastating the world but I‚Äôve done quite a few presentations in the past. I will probably blog more in the future. In addition I‚Äôve added a link of document templates that you may find useful.&lt;/p&gt; &lt;p&gt;If you feel interested in some &lt;a href="/hashtags/talks.html"&gt;&lt;span class="hashtag" data-hashtag="talks"&gt;#talks&lt;/span&gt;&lt;/a&gt; becoming articles (or, on the opposite and article becoming a talk), please enquire.&lt;/p&gt; &lt;/section&gt;&lt;section class="main-section"&gt;&lt;h2 id="haskell-and-functional-programming"&gt;Haskell and Functional Programming&lt;/h2&gt; &lt;p&gt;Most of my talks spree was while actively learning and applying Haskell to real-world problems (in a sense I still do but not in a professional context).&lt;/p&gt; &lt;h3 id="the-haskell-pyramid"&gt;The Haskell Pyramid&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A recurring talk I gave (and other people did as well) to explain why Haskell seems so mystic to bystanders. It sort of diffused and has inspired a few people to detail what further better than I would.&lt;/p&gt; &lt;p&gt;&lt;em&gt;gist&lt;/em&gt; You can be productive in Haskell with ‚Äòsimple haskell‚Äô, but no-one is discussing ‚Äòsimple haskell‚Äô on the social networks.&lt;/p&gt; &lt;p&gt;&lt;em&gt;related&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;em&gt;not affiliated&lt;/em&gt; &lt;a href="https://www.reddit.com/r/haskell/comments/gwkn79/question_regarding_the_haskell_pyramid/"&gt;A reddit post asking what is the base of the pyramid&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;em&gt;not affiliated&lt;/em&gt; a proposition of a &lt;a href="https://nicksanford.io/posts/haskell-pyramid/"&gt;Haskell pyramid&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;em&gt;not affiliated&lt;/em&gt; a proposition for &lt;a href="https://gilmi.me/blog/post/2021/03/16/bottom-haskell-pyramid"&gt;the bottom of the Haskell pyramid&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1bSANLVcGnfVIFjicj81Uo_MYQhsF0FZi_EF-NEKFecE/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="functional-is-a-direction"&gt;Functional is a direction&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;gist:&lt;/em&gt; If you plot the programming languages on an X/Y graph with &lt;code&gt;X&lt;/code&gt; as the quality of the local reasoning and &lt;code&gt;Y&lt;/code&gt; the level of formalism you use. You‚Äôll notice that languages tend to appear and move to the upper-right direction &lt;span class="emoji" data-emoji="arrow_upper_right"&gt;‚ÜóÔ∏è&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1VkRkSgI6PTRli8j8SR0cASJEOLz8zUhMaV3Z9ItsMYE/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="haskell-teachings-applied-to-architecture"&gt;Haskell teachings applied to architecture&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; I am a software architect and I‚Äôve designed pretty big systems. Haskell‚Äôs closeness to mathematical abstractions are useful to think. For instance, the duality between &lt;code&gt;sum-types&lt;/code&gt; and &lt;code&gt;product-types&lt;/code&gt; is a &lt;strong&gt;duality&lt;/strong&gt; you will find between &lt;code&gt;producers&lt;/code&gt; and &lt;code&gt;consumers&lt;/code&gt; services in large companies.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1HinBAMjkL5qNSRku8XntAhkniRbelLHQcwLyUyPr2X8/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="prodapi"&gt;ProdAPI&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; Slides showing how ProdAPI modularizes a service application like in web-service architectures.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1xpvw8bFWhA4mw4JJVc6ywYimU7O50oQ-exApyHyzmrw/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/lucasdicioccio/prodapi"&gt;github&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="grpc-native"&gt;gRPC native&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A talk I gave to introduce my gRPC library during Zurihac2020.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1MS7TxkpnSsorzbgg25boSZzOZr9iwPpXVh2Bcygb5JU/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/haskell-grpc-native"&gt;github&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="http2-client"&gt;http2-client&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A talk I gave to introduce my http2-client library at a Haskell-Paris Meetup.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1qD9Q2zrSMf0MsP4siWlbr7n7V78vZUggmZMtdv7Qu1U/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/lucasdicioccio/http2-client"&gt;github&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="composing-web-apis-with-servant"&gt;Composing Web APIs with Servant&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A talk I gave to introduce the amazing Servant library to write web-API and clients at a While42-London. It‚Äôs a bit lengthy as it tries to share my concept of ‚Äòcomposition‚Äô. That said, the visualizations/animations of how to match ‚Äòtypes together‚Äô in a Servant API can be helpful. I guess most of the content is still up to date (early 2022) because the Servant concept are rock solid.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/110Xl7ZVKWEipc6jRbkIFye2Htp1VEJ-DAjRFK_s6Frg/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="an-introduction-to-functional-programming"&gt;An introduction to functional programming&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A talk I gave at Veepee to explain FP basics. I got plenty of appraisal from colleagues at the time, so I guess it is a decently-good starting material to get a feeling of things like &lt;strong&gt;immutability&lt;/strong&gt; , &lt;strong&gt;map&lt;/strong&gt; and &lt;strong&gt;fold&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1R5ODUBOtCxIbLBD_0xUG3prHQ6-OLyAEMwWVCIp5YxE/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="les-monades-en-comptant-sur-ses-doigts"&gt;Les monades en comptant sur ses doigts&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A monad-tutorial I gave at at Haskell-Paris meetup. Only the title of this talk is in French.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1qAcG-zfxQKH0EmYzl5MVj0Z_BAWbuRrbMsQI6L67jPc/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h2 id="minizinc-and-constraint-programming"&gt;MiniZinc and Constraint-Programming&lt;/h2&gt; &lt;p&gt;I have fallen in love with modeling and optimizing engineering (but not only) problems. You will likely see Alloy-content pop up at some point as well. &lt;a href="/hashtags/optimization.html"&gt;&lt;span class="hashtag" data-hashtag="optimization"&gt;#optimization&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id="constraint-programming-with-minizinc"&gt;Constraint-Programming with MiniZinc&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A constraint-programming introduction I gave for VPTech. We also solve the cabbage-goat-wolf problem in MiniZinc.&lt;/p&gt; &lt;p&gt;&lt;em&gt;related&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;em&gt;not affiliated&lt;/em&gt; &lt;a href="https://www.sasnauskas.eu/solving-river-crossing-puzzles-with-minizinc/"&gt;solving river crossing puzzles&lt;/a&gt; , my talk inspired Raimondas Sasnauskas to write down the solution to the cabbage-goat-wolf problem I used towards the later parts of the talk. His article is a good tutorial. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1Ze7jR6VbFNxLcvVYz9xmDfWKfXbgjUXpsH98doDB0lE/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=kiX1FOw1GUU"&gt;youtube recording&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h2 id="architecture-and-site-reliability-engineering"&gt;Architecture and Site-Reliability Engineering&lt;/h2&gt; &lt;p&gt;I was an &lt;a href="/hashtags/SRE.html"&gt;&lt;span class="hashtag" data-hashtag="SRE"&gt;#SRE&lt;/span&gt;&lt;/a&gt; in one of the most hectic team at Google. Add this my especially-bad luck and one could say I‚Äôve handled quite a lot of incidents. Then I‚Äôve been an Architect in a pretty large company with a lot of complex business processes, a good amount of old and poorly-understood code where challenges abund.&lt;/p&gt; &lt;h3 id="aborder-la-production-comme-un-sre-fr"&gt;Aborder la production comme un SRE &lt;span class="emoji" data-emoji="fr"&gt;üá´üá∑&lt;/span&gt;&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; Trying to convey what the SRE approach is. When I gave this talk, few people were interested in the term SRE. In France we alas mostly renamed Devops but here in this &lt;strong&gt;recording in French&lt;/strong&gt; I explain what the SRE approach and mindset is in the place I‚Äôve experienced it.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1sG5635YGkczUxwqNm1d7CsOPIzBaMQdjgpuVlS6kMG0/edit#slide=id.g1e386fa4fb_0_0"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=lSqyeckTLl8"&gt;youtube recording&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="post-mortem-template"&gt;Post-Mortem Template&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;A good post-mortem takes time to write but it‚Äôs a goldmine of information. I‚Äôve written this template after a request from a friend who had trouble going past the ‚Äòincident report‚Äô that was only scratching the surface. So I wrote a template of Post-Mortem with some text of a pseudo story of things that went wrong.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/document/d/1c48bRufHkWmSTUZv6RJuDQJOFXLRuV_TRZTX28XLCh4/edit?usp=sharing"&gt;google doc&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="design-doc-template"&gt;Design-Doc Template&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;A template of Design-Doc. A number of sections may be superfluous depending on how fast. But what is key (besides motivating the problem you are trying to solve) is to properly define the axes of analysis from the proper solution-analysis.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/document/d/1roAP7yafVq_ZwO7F66Q5T_gS_ZElWf3aYBPHooJkmU0/edit#"&gt;google doc&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="vacat-page-template"&gt;Vacat Page Template&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;A Vacat Page is a page intentionally left blank. Good vacat pages are hard to find. I‚Äôve taken the freedom to plagiarize a vacat page from a book I paid 90euros.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="/page-intentionally-left-blank.html"&gt;vacat page template&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt;&lt;section class="main-section"&gt;&lt;script type="text/javascript"&gt; (function(){ const xs = [... document.getElementsByTagName("h3")]; xs.forEach((x) =&gt; { const title = x.innerHTML ?? 'about your blog'; const subject = `About your blog: ${title}`; const elt = document.createElement("a"); elt.innerHTML = " üìß"; elt.setAttribute("class", "enquire-link") elt.setAttribute("href", `mailto:lucas@dicioccio.fr?subject=${subject}`); x.appendChild(elt); }); })() &lt;/script&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/talks.html" rel="alternate"/>
        <summary type="text">
            A list of slides (with recording links when available) for presentations I gave. Also some template documents for architecture/devops.
        </summary>
    </entry>
</feed>
