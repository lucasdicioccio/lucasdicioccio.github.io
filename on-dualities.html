<!DOCTYPE HTML><html><head><meta charset="utf-8"><meta name="viewport" content="with=device-width, initial-scale=1.0"><title>Lucas DiCioccio&#39;s blog - On Dualities</title><meta name="author" content="Lucas DiCioccio"><meta name="keywords" content="architecture, haskell, functional programming, programming, software architecture"><meta name="description" content="Dualitiy is technical jargon for &quot;complementary&quot;. Programmers often overlook the role dualities in programming and hence fail to recognize them, even if they are hiding in plain sight. In this article we focus on two important pairs of dual concepts: producers and consumers, sum types and product types."><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Lucas DiCioccio&#39;s blog - On Dualities"><meta name="twitter:site" content="@lucasdicioccio"><meta name="twitter:creator" content="lucasdicioccio"><meta property="twitter:description" content="Dualitiy is technical jargon for &quot;complementary&quot;. Programmers often overlook the role dualities in programming and hence fail to recognize them, even if they are hiding in plain sight. In this article we focus on two important pairs of dual concepts: producers and consumers, sum types and product types."><meta name="type" property="og:type" content="article"><meta name="title" property="og:title" content="Lucas DiCioccio&#39;s blog - On Dualities"><meta name="url" property="og:url" content="https://lucasdicioccio.github.io/on-dualities.html"><meta property="og:description" content="Dualitiy is technical jargon for &quot;complementary&quot;. Programmers often overlook the role dualities in programming and hence fail to recognize them, even if they are hiding in plain sight. In this article we focus on two important pairs of dual concepts: producers and consumers, sum types and product types."><meta name="article:published_time" content="2022-03-01"><meta name="article:tag" content="architecture"><meta name="article:tag" content="haskell"><meta name="article:tag" content="functional programming"><meta name="article:tag" content="programming"><meta name="article:tag" content="software architecture"><style>@import "/css/main.css";.cols {  display: flex;  flex-flow: row;  justify-content: space-around;}</style></head><body><aside class="nav"><a href="/">home</a></aside><div class="main"><article><header class="heading"><h1>On Dualities</h1><p>On <span>Tue, 01 Mar 2022</span>, by <a href="https://twitter.com/lucasdicioccio">@lucasdicioccio</a>, 2301 words, 2 links, 2images.</p><div class="taglist"><div class="tag"><a class="tag-link" href="/topics/architecture.html"><span class="tag-name">architecture</span><span class="tag-count">1</span></a></div><div class="tag"><a class="tag-link" href="/topics/haskell.html"><span class="tag-name">haskell</span><span class="tag-count">5</span></a></div><div class="tag"><a class="tag-link" href="/topics/functional-programming.html"><span class="tag-name">functional programming</span><span class="tag-count">1</span></a></div></div></header><div class="upcoming-notice"><p>This article is still considered unfinished and content may change significantly.</p></div><div class="main-article"><section class="main-section"><p>Functional programming has taught me to <em>simplify</em> superfluous concepts:
identify what are primitive concepts and what are constructions on top these
primitives. The constructions themselves need not be multiplied out of
proportion: it is better to stick to few ways of combining entities and
concepts. Overall, I think I found some internal peace with programming
languages when I could recognize enough of such primitives and how to make use
of them in various programming styles. Among the techniques that I use to
recognize when two concepts complement each other is to emphasize when two
things are in a <em>duality</em>.</p>
<p>A situation of duality is when two concepts cohabit well while appearing in
opposition.  In a sense, two dual concepts connect and perform some
symmetrical dance. I would say that finding that two things are dual is like
realizing that it’s not the Earth that rotates around the Moon, nor the Moon
rotates around Earth, but in facth both celestial bodies dance and rotate
around a same point <a href="https://en.wikipedia.org/wiki/Barycenter#/media/File:Orbit3.gif">(the barycenter)</a>.
Discovering such rules brings clarity and simplicity to our understanding of a
problem. Since a key part of our job in software engineering is to tame
complexity, recognizing such simplifications are useful.</p>
<p>The existence of the barycenter of the Earth-Moon system is a consequence of
the mathematical formulas we use to model the physical world. It is worth
training our sense starting from simple (even simplistic) equations.  For
instance, let’s take the simplest form of duality: the equality of two values.
The two sides of an equality <code>a = b</code> are in a dual relationship: what happens
to <code>a</code> requires a commensurate compensation on <code>b</code>.  In the real world you
rarely encounter some simple rule saying <code>a = b</code>, more often terms like <code>a</code> and
<code>b</code> actually are contraptions. For instance <code>b</code> is the result of something
involving <code>c</code> and <code>d</code> and other values. Whatever the particular instance you
find, what happens to <code>a</code> likely has implications on these <code>c</code> and <code>d</code> and
other values. As systems grow in complexity, such equalities may blossom
unsuspectedly, and if the formula for the equality is too obscured to be
spelled-out, unfathomable dynamics will happen.</p>
<p>Although software is not cosmology, and even if no Great Watchmaker seems
needed to enforce laws of equalities (we trust CPU founders to do so),
dualities exist in software. Software can be modeled with mathematical concepts
from <em>discrete logic</em> rather than calculus and differential equations. If I had
to choose, I would say that the root of all dualities in software are <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan’s laws</a> (in particular, see the section about extensions to predicate and modal logic).
Let’s say that a “negated” value is a <em>consumer</em> whereas a “positive” value is a <em>producer</em>. Also, let’s say that a <code>OR</code> encodes alternatives whereas a <code>AND</code> encodes co-occurrences. Applying De Morgan’s law <code>NOT (x OR y) = (NOT x) AND (NOT y)</code> could be read as <strong>to consume either X or Y we need the co-occurence of a consumer of X and a consumer of Y</strong>.
We will leave such a bureaucratic formalism out of this article but there is
not much more to it: a simple logical rule. Instead, I’ll spend time elaborating at a higher-level. In particular I would like to stress how important the producer/consumer duality is in software and how this duality is interlocked with yet another important duality: the alternative/co-ocurrence duality.</p>
<h2 id="the-producerconsumer-duality">The producer/consumer duality</h2>
<p>We do not write code in a vacuum. Even if we write code for no purpose, the
programming language has logical rules, running a program happens on a physical
machine subject to physical and logical rules of the CPU or those of the
virtual machine.  Even if we only imagine some code without writing it (e.g.,
while sketching out an API in our mind), our imaginary simulation of the
running code will entail some logical rules. In any case some dualities are
likely to arise. In particular, a useful program either consumes some data
(e.g., a configuration file), or produces some data (e.g., a PNG image). More
often, a programs both consume and produce some data but <strong>the
data-consumption-side and data-production-side of a program operate on distinct
sets</strong>.</p>
<p>I specifically want to avoid conflating inputs and outputs with produced and
consumed data. Although I believe that input and output are in a
consumer/producer duality, I also want to encompass side-effects in this
duality. A trick in functional programming is to pretend that the external
world is a hidden input and hidden output of a pure function. The problem I
find with this external-world object is that the external world is both
consumed and produced, apparently giving a symmetrical role to the
external-world object (for the better or the worst, our programming practice
focuses almost only on the program and takes the executing environment as an
unprogrammable thing with its own will). I prefer to conceptualize side-effects
as entities merely produced by programs. Side-effects then are consumed by
their executing environment. In this viewpoint, the program and the executing
environment are the two partners performing a tango dance (or the two opponents
in a tennis-game if you prefer sport over artistic metaphors).  This viewpoint
brings the question: what is the dual to a side-effect? It is something that an
executing environment provides and that a program consumes (and hence it may
destroy it), and I claim that would be pre-conditions.  Summarizing, in this
viewpoint <strong>a program consumes pre-conditions and produces side-effects</strong>.</p>
<p>I spoke about “programs” without precisely describing the kind of program I
wanted to describe. Indeed, I believe that such a duality exists at different
scales of programming. When zooming in at the individual module, object, or
function, we can easily outline pieces of code that produce and consume objects
or data-structures. I believe the same rule exists when zooming out a the
service level. We just lack proper nouns to disambiguate whether a service
mainly produces or consumes other services (indeed, much like the
external-world object trick in FP: we conflate the co-occurrence of two
distinct phenomenon because when focusing on a sole viewpoint both ends meet).
I do not have excellent suggestions to make, but if I were to pick some words
today I would say that, a service is being a <strong>producer of functionalities that
are consumed as capabilities</strong> by external-services.</p>
<p>What are the consequences of the dual roles of producers and consumers? Well,
there is a point that when you need to modify a producer you need consumers to
adapt in a dual way. It’s common to speak about API <em>contracts</em> to provide a
way to match consumers with producers. However I find that speaking at length
about the value of contracts falls short. Contracts are shallow, they merely
are the tips of the consumers and producers code. We actually can derive much
more information than “ok the consumers and producers must agree on a
contract”. In particular, we need to be precise about the consequences of
changing a producer linked to a consumer.  To answer such questions, we need to
take a close look at how the producers/consumers duality interacts with the
alternative/co-occurrences duality.</p>
<h2 id="the-alternativeco-occurrences-duality">The alternative/co-occurrences duality</h2>
<p>Alternatives and co-occurrences are well captured with what are called
<em>sum-types</em> and <em>product-types</em> in typed-programming languages. Product-types
are pervasive in programming, they correspond to your day-to-day data structure
that is made of a set of fields. For instance, a user could be represented in
some informal pseudo-code <code>type User = { Name x Email x FavoriteColor }</code>.  This
notation means that a when you are presented a <code>User</code> object, you also have the
co-occurrence of three separate entities: <code>Name</code>, <code>Email</code>, and <code>FavoriteColor</code>,
and you can splice them out at will and independently.</p>
<p>Sum-types, for no clear reason, have less support in the most-established
programming languages. To be precise, user-declared sum-types are not really
available. A boolean is the simplest example of sum-types, it presents two
alternatives <code>type Bool = { False | True }</code>, that is when you have a <code>Bool</code>, you
may have either a <code>False</code> or a <code>True</code> but not both at a same time.  You could
have a type with three alternatives (e.g., to encode a subscription plan with
three tiers <code>type Plan = { Free, Pro, Enterprise }</code>).</p>
<p>With knowledge of product types and sum types, a compiler or a linter can tell
you that you made a mistake (e.g., you forgot to give an <code>Email</code> to build a
<code>User</code>, or you forgot to provide a template for the <code>Pro</code> subscription email).
Indeed, automated tools have enough information about all possible alternative
and all required fields that must co-occur.  Since we are discussing dualities
and we have discussed about the producer/consumer duality. You may already
sense where this post is going: we need to explore what happens to the
consumer-side of a produced sum-type or of a produced product type.</p>
<p>Given that a product type is a co-occurrence of independent facts, when you
produce a product type, the consumer <em>CAN</em> have multiple independent data
handlers and all can execute.  Whereas when you produce a sum type, the
consumer <em>MUST</em> have independent data handlers and only one executes.</p>
<p>Finally, let’s note that a data handlers can also be stored in data types (e.g.,
with lambdas if the language supports it, or with factory-patterns otherwise).
Such data types – containing handlers – themselves can be product and sum
types. Putting everything together, we note that <strong>producers of alternatives
require a the co-occurrence of consumers</strong> whereas <strong>producers of
co-occurrences require alternatives of consumers</strong>. That’s it, our two
dualities are interlocked.</p>
<p>We can illustrate this duality with pictures by displaying a producer and a
consumer being matched together.</p>
<p>On the one hand, we shall illustrate a producer of product-type.  Visually we
try to convey the code that is written with the yellow boxes with <code>...</code>
ellipsis text in them.</p>
<p><img src="images/product-producer.png" alt="product-producer" /></p>
<p>The Producer returns a co-occurrence of three pieces of information (the
product type <code>{A,B,C}</code>). Therefore, the Producer must have code to introduce or
carry-over these three independent piece of information.  Given that the
Producer’s output contains these three pieces of information, the Consumer is
free to pick any alternative combining <code>A</code>, <code>B</code>, or <code>C</code>. When Producer and
Consumer are <em>decoupled</em>, the Consumer may not even have code to consume <code>A</code> or
<code>C</code> and only cares about <code>B</code>.</p>
<p>On the other hand, we also need to illustrate the dual situation where the
Producer provides a sum-type.</p>
<p><img src="images/product-consumer.png" alt="product-consumer" /></p>
<p>Given that the Producer provides an alternative (again, it may be that there is
code for only one possible case), if the Consumer is decoupled from the
Producer, then the Consumer must be ready to handle every case.</p>
<p>In a sense, the side that implements the product-type always has more burden
than the side that implements the sum-type. Indeed, the product-type side is
compelled to provide or be ready to consume all three bits of information
depending on what side it takes.</p>
<h3 id="summary">Summary</h3>
<ul>
<li>consumers and producers are in a duality relationship
</li>
<li>product-types and sum-types are dual of each other
</li>
<li>producers of sum types need to be matched with product-types of consumers, <em>vice versa</em>
</li>
</ul>
<h2 id="consequences">Consequences</h2>
<p>An important, consequence of the interactions of product/sum with
consumer/producer is that you do not need to be a compiler to foresee whether
two pieces of software “connect” well or not.</p>
<p>Indeed, our very-own De Morgan’s law is true from the simple three lines of code up you
throw in a quick script up to the larger monolith you are trying to split
tactically. Simple terms like product-types and sum-types, producer and
consumers allow more insight into the details of a system than other words like
‘api-endpoints’ or ‘data-augmentation’: treat an API with multiple endpoints as
a product-of-consumers, data-augmentation is a way to produce a product-type.</p>
<p>Further, this duality is important in modeling and technical aspects of the code.</p>
<h3 id="code-with-bunch-of-nested-ifs">code with bunch of nested ifs</h3>
<p>A series of conditions:</p>
<ul>
<li>recognize the number of branches you have in total
</li>
<li>write a type with these many branches
</li>
<li>map your context (set of variables) onto this type
</li>
<li>flatten the conditions
</li>
</ul>
<h3 id="data-pipelines">data pipelines</h3>
<p>We often need to integrate diverse data sources and give them a similar shape
(e.g., survey from past year and this year, with slightly different fields).</p>
<p>You can recognize two data sources as being a product (e.g., when you have alternative choices for a user identifier, you want a subset of total information) or a sum type (e.g., you need the union of the dataset).</p>
<h3 id="recognizing-when-to-use-or-work-around-so-called-abstract-code">recognizing when to use or work-around so-called abstract code</h3>
<ul>
<li>sometimes you have interfaces code to “normalize” access
</li>
<li>the idea is to write an abstract piece of logic and let adapters provide implementations
</li>
<li>other pieces of interface code may use these as input too
</li>
<li>however the use of such interface-specific intermediary lead to braided-code, the original output is insufficient, so you still need carry the original objects, you end up adding code to undo features
</li>
</ul>
<h3 id="refactoring-technique-switching-representations">refactoring technique: switching representations</h3>
<p>Rather than providing a sum type as output, you can encode the possible branches as handlers.</p>
<p>Same thing, when you have code that requires callbacks, you could modify it to produce an intermediary structure.</p>
<p>Tradeoffs are opposite: extra structures typically require more RAM but you can inspect and print them. Whereas function calls requier less RAM but cannot provide as much debug information.</p>
<h3 id="auditing-the-importance-of-introducing-new-edge-cases">auditing the importance of introducing new edge cases</h3>
<p>We could consider what happens when <code>A = B</code> is relaxed into <code>A &lt;= B</code> or <code>A &gt;= B</code>, that
would bring us to Liskov substitution principle, variance and covariance. You
can treat the <code>A &gt;= B</code> case by saying that extra-alternatives need extra branches.</p>
<h3 id="monoliths-microservices-and-it-system-architectures">monoliths, microservices, and IT-system architectures</h3>
<p>We assumed so far that <code>A -&gt; B</code> was a function like a Python or Java function.
We can actually think of <code>-&gt;</code> as a many data-transfer mechanisms: remote procedure calls, HTTP queries, task message, SQL queries.</p>
<p>So now if you have a service that produces objects with two possible shapes <code>A or B</code>, you know the consumers will require pairs of branches.</p>
<p>Similarly, you could have a pair of services (e.g., archived-orders and fresh-orders), possibly with different data-format. Your website will thus either need to uniformize.</p>
<p>In short, the sum-product dualities will severely leak into the data-access patterns of your services.</p>
<h1 id="other-dualities">Other dualities</h1>
<h2 id="null-vs-default">null vs. default</h2>
<p>Much has been written about <code>null</code> being the billion-dollar error.
Well, my belief if we should regard <code>defaults</code> with the same horror, because
default values are the dual of null values.</p>
<h2 id="push-vs-pull">push vs. pull</h2>
<p>With evented architectures being trendy, people tend to oversell the power of
push-based architectures over pull-based. However there is a dual tension
between the two.</p>
<p>Push is write and Pull is read.</p>
<p>Some work are inherently push-based: everything that has a sum as input (e.g., two operations that may occur).</p>
<p>Some work are inherently pull-based: everything that requires a product as input (e.g., consensus to know the true value, when debugging you need a product of dataset to recreate a full context).</p>
<p>Thus, no big surprise, push-based architecture actually are full of pull-based
mechanisms.</p>
</section></div><footer class="footing"><div class="social-links"><a href="https://twitter.com/lucasdicioccio">twitter: @lucasdicioccio</a><a href="https://github.com/lucasdicioccio">github: lucasdicioccio</a><a href="https://linkedin.com/in/lucasdicioccio">linkedin: lucasdicioccio</a></div></footer></article></div></body></html>