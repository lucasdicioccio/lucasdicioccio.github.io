<!DOCTYPE HTML><html><head><meta charset="utf-8"><meta name="viewport" content="with=device-width, initial-scale=1.0"><title>Lucas DiCioccio&#39;s blog - On Dualities</title><meta name="author" content="Lucas DiCioccio"><meta name="keywords" content="architecture, haskell, functional programming, programming, software architecture"><meta name="description" content="Dualitiy is technical jargon for &quot;complementary&quot;. Programmers often overlook the role dualities in programming and hence fail to recognize them, even if they are hiding in plain sight. In this article we focus on two important pairs of dual concepts: producers and consumers, sum types and product types."><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Lucas DiCioccio&#39;s blog - On Dualities"><meta name="twitter:site" content="@lucasdicioccio"><meta name="twitter:creator" content="lucasdicioccio"><meta property="twitter:description" content="Dualitiy is technical jargon for &quot;complementary&quot;. Programmers often overlook the role dualities in programming and hence fail to recognize them, even if they are hiding in plain sight. In this article we focus on two important pairs of dual concepts: producers and consumers, sum types and product types."><meta name="type" property="og:type" content="article"><meta name="title" property="og:title" content="Lucas DiCioccio&#39;s blog - On Dualities"><meta name="url" property="og:url" content="https://lucasdicioccio.github.io/on-dualities.html"><meta property="og:description" content="Dualitiy is technical jargon for &quot;complementary&quot;. Programmers often overlook the role dualities in programming and hence fail to recognize them, even if they are hiding in plain sight. In this article we focus on two important pairs of dual concepts: producers and consumers, sum types and product types."><meta name="article:published_time" content="2022-03-01"><meta name="article:tag" content="architecture"><meta name="article:tag" content="haskell"><meta name="article:tag" content="functional programming"><meta name="article:tag" content="programming"><meta name="article:tag" content="software architecture"><style>@import "/css/main.css";.cols {  display: flex;  flex-flow: row;  justify-content: space-around;}</style></head><body><aside class="nav"><a href="/">home</a></aside><div class="main"><article><header class="heading"><h1>On Dualities</h1><p>On <span>Tue, 01 Mar 2022</span>, by <a href="https://twitter.com/lucasdicioccio">@lucasdicioccio</a>, 1724 words, 2 links, 0images.</p><div class="taglist"><div class="tag"><a class="tag-link" href="/topics/architecture.html"><span class="tag-name">architecture</span><span class="tag-count">1</span></a></div><div class="tag"><a class="tag-link" href="/topics/haskell.html"><span class="tag-name">haskell</span><span class="tag-count">5</span></a></div><div class="tag"><a class="tag-link" href="/topics/functional-programming.html"><span class="tag-name">functional programming</span><span class="tag-count">1</span></a></div></div></header><div class="upcoming-notice"><p>This article is still considered unfinished and content may change significantly.</p></div><div class="main-article"><section class="main-section"><p>Functional programming has taught me to <em>simplify</em> superfluous concepts:
identify what are primitive concepts and what are constructions on top these
primitives. The constructions themselves need not be multiplied out of
proportion: it is better to stick to few ways of combining entities and
concepts. Overall, I think I found some internal peace with programming
languages when I could recognize enough of such primitives and how to make use
of them in various programming styles. Among the techniques that I use to
recognize when two concepts complement each other is to emphasize when two
things are in a <em>duality</em>.</p>
<p>A situation of duality is when two concepts cohabit well while appearing in
opposition.  In a sense, two dual concepts connect and perform some
symmetrical dance. I would say that finding that two things are dual is like
realizing that it’s not the Earth that rotates around the Moon, nor the Moon
rotates around Earth, but in facth both celestial bodies dance and rotate
around a same point <a href="https://en.wikipedia.org/wiki/Barycenter#/media/File:Orbit3.gif">(the barycenter)</a>.
Discovering such rules brings clarity and simplicity to our understanding of a
problem. Since a key part of our job in software engineering is to tame
complexity, recognizing such simplifications are useful.</p>
<p>The existence of the barycenter of the Earth-Moon system is a consequence of
the mathematical formulas we use to model the physical world. It is worth
training our sense starting from simple (even simplistic) equations.  For
instance, let’s take the simplest form of duality: the equality of two values.
The two sides of an equality <code>a = b</code> are in a dual relationship: what happens
to <code>a</code> requires a commensurate compensation on <code>b</code>.  In the real world you
rarely encounter some simple rule saying <code>a = b</code>, more often terms like <code>a</code> and
<code>b</code> actually are contraptions. For instance <code>b</code> is the result of something
involving <code>c</code> and <code>d</code> and other values. Whatever the particular instance you
find, what happens to <code>a</code> likely has implications on these <code>c</code> and <code>d</code> and
other values. As systems grow in complexity, such equalities may blossom
unsuspectedly, and if the formula for the equality is too obscured to be
spelled-out, unfathomable dynamics will happen.</p>
<p>Although software is not cosmology, and even if no Great Watchmaker seems
needed to enforce laws of equalities (we trust CPU founders to do so),
dualities exist in software. Software can be modeled with mathematical concepts
from <em>discrete logic</em> rather than calculus and differential equations. If I had
to choose, I would say that the root of all dualities in software are <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan’s laws</a> (in particular, see the section about extensions to predicate and modal logic).
Let’s say that a “negated” value is a <em>consumer</em> whereas a “positive” value is a <em>producer</em>. Also, let’s say that a <code>OR</code> encodes alternatives whereas a <code>AND</code> encodes co-occurrences. Applying De Morgan’s law <code>NOT (x OR y) = (NOT x) AND (NOT y)</code> could be read as <strong>to consume either X or Y we need the co-occurence of a consumer of X and a consumer of Y</strong>.
We will leave such a bureaucratic formalism out of this article but there is
not much more to it: a simple logical rule. Instead, I’ll spend time elaborating at a higher-level. In particular I would like to stress how important the producer–consumer duality is in software and how this duality is interlocked with yet another important duality: the alternative–co-ocurrence duality.</p>
<h1 id="the-producerconsumer-duality">The producer–consumer duality</h1>
<p>We do not write code in a vacuum. Even if we write code for no purpose, the
programming language has logical rules, running a program happens on a physical
machine subject to physical and logical rules of the CPU or those of the
virtual machine.  Even if we only imagine some code without writing it (e.g.,
while sketching out an API in our mind), our imaginary simulation of the
running code will entail some logical rules. In any case some dualities are
likely to arise. In particular, a useful program either consumes some data
(e.g., a configuration file), or produces some data (e.g., a PNG image). More
often, a programs both consume and produce some data but <strong>the
data-consumption-side and data-production-side of a program operate on distinct
sets</strong>.</p>
<p>I specifically want to avoid conflating inputs and outputs with produced and
consumed data. Although I believe that input and output are in a
consumer–producer duality, I also want to encompass side-effects in this
duality. A trick in functional programming is to pretend that the external
world is a hidden input and hidden output of a pure function. The problem I
find with this external-world object is that the external world is both
consumed and produced, apparently giving a symmetrical role to the
external-world object (for the better or the worst, our programming practice
focuses almost only on the program and takes the executing environment as an
unprogrammable thing with its own will). I prefer to conceptualize side-effects
as entities merely produced by programs. Side-effects then are consumed by
their executing environment. In this viewpoint, the program and the executing
environment are the two partners performing a tango dance (or the two opponents
in a tennis-game if you prefer sport over artistic metaphors).  This viewpoint
brings the question: what is the dual to a side-effect? It is something that an
executing environment provides and that a program consumes (and hence it may
destroy it), and I claim that would be pre-conditions.  Summarizing, in this
viewpoint <strong>a program consumes pre-conditions and produces side-effects</strong>.</p>
<p>I spoke about “programs” without precisely describing the kind of program I
wanted to describe. Indeed, I believe that such a duality exists at different
scales of programming. When zooming in at the individual module, object, or
function, we can easily outline pieces of code that produce and consume objects
or data-structures. I believe the same rule exists when zooming out a the
service level. We just lack proper nouns to disambiguate whether a service
mainly produces or consumes other services (indeed, much like the
external-world object trick in FP: we conflate the co-occurrence of two
distinct phenomenon because when focusing on a sole viewpoint both ends meet).
I do not have excellent suggestions to make, but if I were to pick some words
today I would say that, a service is being a <em>producer of functionalities</em> that
are <em>consumed as capabilities</em> by external-services.</p>
<h1 id="the-alternative--co-occurrences-duality">The alternative – co-occurrences duality</h1>
<pre><code>data Bool = False | True
data Bool ~= False + True
</code></pre>
<pre><code>data Branch = Pair CodeA CodeB
data Branch ~= CodeA x CodeB
</code></pre>
<p>Thus if you <em>produce a product type</em> you can have a <em>multiple independent consumers</em> (e.g., two parallel and non-interfering pieces of logic than can both run).
Conversely if you <em>produce a sum type</em> well-behaved code must have <em>one branch per alternative</em> (i.e., two pieces of logic which are mutually exclusive).</p>
<p>Squinting a bit, we realize that a producer which produces <code>product type</code> objects asks for a <code>sum of consumers</code>. Whereas a producer of <code>sum type</code> objects forces a <code>product of consumers</code>.</p>
<p>Formally we can introduce some notations to help discuss more rigorously about
this topic.  Let’s write <code>f: _ -&gt; A</code> for <strong><code>f</code> is a producer of <code>A</code></strong> and <code>g: B -&gt; _</code> for <strong><code>g</code> is a consumer of <code>B</code></strong>. Thus we could write <code>h: X -&gt; Y</code> to say
that <strong><code>h</code> consumes X to produce <code>Y</code></strong>. You may recognize the function type
notation.</p>
<p>Then if we want to feed <code>g</code> with the result of <code>f</code> then the equality <code>A = B</code>
must hold to say that <strong><code>g</code> consumes what <code>f</code> produces</strong>. Now, let’s study what
happens when <code>A</code> is a sum type <code>A = (alternative_1 | alternative_2) = B</code> .</p>
<pre><code>                ---&gt; alternative_1 --- [   ]
               /                       |   |
  o ---[ f ]---                        | g |---- o
               \                       |   |
                ---&gt; alternative_2 --- [   ]
</code></pre>
<h2 id="importance">Importance</h2>
<p>This duality is important in modeling and technical aspects of the code.
In short: you can trade some control-flow complexity into some data complexity.</p>
<h3 id="code-with-bunch-of-nested-ifs">code with bunch of nested ifs</h3>
<p>A series of conditions:</p>
<ul>
<li>recognize the number of branches you have in total
</li>
<li>write a type with these many branches
</li>
<li>map your context (set of variables) onto this type
</li>
<li>flatten the conditions
</li>
</ul>
<h3 id="data-pipelines">data pipelines</h3>
<p>We often need to integrate diverse data sources and give them a similar shape
(e.g., survey from past year and this year, with slightly different fields).</p>
<p>You can recognize two data sources as being a product (e.g., when you have alternative choices for a user identifier, you want a subset of total information) or a sum type (e.g., you need the union of the dataset).</p>
<h3 id="recognizing-when-to-use-or-work-around-so-called-abstract-code">recognizing when to use or work-around so-called abstract code</h3>
<ul>
<li>sometimes you have interfaces code to “normalize” access
</li>
<li>the idea is to write an abstract piece of logic and let adapters provide implementations
</li>
<li>other pieces of interface code may use these as input too
</li>
<li>however the use of such interface-specific intermediary lead to braided-code, the original output is insufficient, so you still need carry the original objects, you end up adding code to undo features
</li>
</ul>
<h3 id="refactoring-technique-switching-representations">refactoring technique: switching representations</h3>
<p>Rather than providing a sum type as output, you can encode the possible branches as handlers.</p>
<p>Same thing, when you have code that requires callbacks, you could modify it to produce an intermediary structure.</p>
<p>Tradeoffs are opposite: extra structures typically require more RAM but you can inspect and print them. Whereas function calls requier less RAM but cannot provide as much debug information.</p>
<h3 id="auditing-the-importance-of-introducing-new-edge-cases">auditing the importance of introducing new edge cases</h3>
<p>We could consider what happens when <code>A = B</code> is relaxed into <code>A &lt;= B</code> or <code>A &gt;= B</code>, that
would bring us to Liskov substitution principle, variance and covariance. You
can treat the <code>A &gt;= B</code> case by saying that extra-alternatives need extra branches.</p>
<h3 id="monoliths-microservices-and-it-system-architectures">monoliths, microservices, and IT-system architectures</h3>
<p>We assumed so far that <code>A -&gt; B</code> was a function like a Python or Java function.
We can actually think of <code>-&gt;</code> as a many data-transfer mechanisms: remote procedure calls, HTTP queries, task message, SQL queries.</p>
<p>So now if you have a service that produces objects with two possible shapes <code>A or B</code>, you know the consumers will require pairs of branches.</p>
<p>Similarly, you could have a pair of services (e.g., archived-orders and fresh-orders), possibly with different data-format. Your website will thus either need to uniformize.</p>
<p>In short, the sum-product dualities will severely leak into the data-access patterns of your services.</p>
<h1 id="other-dualities">Other dualities</h1>
<h2 id="null-vs-default">null vs. default</h2>
<p>Much has been written about <code>null</code> being the billion-dollar error.
Well, my belief if we should regard <code>defaults</code> with the same horror, because
default values are the dual of null values.</p>
<h2 id="push-vs-pull">push vs. pull</h2>
<p>With evented architectures being trendy, people tend to oversell the power of
push-based architectures over pull-based. However there is a dual tension
between the two.</p>
<p>Push is write and Pull is read.</p>
<p>Some work are inherently push-based: everything that has a sum as input (e.g., two operations that may occur).</p>
<p>Some work are inherently pull-based: everything that requires a product as input (e.g., consensus to know the true value, when debugging you need a product of dataset to recreate a full context).</p>
<p>Thus, no big surprise, push-based architecture actually are full of pull-based
mechanisms.</p>
</section></div><footer class="footing"><div class="social-links"><a href="https://twitter.com/lucasdicioccio">twitter: @lucasdicioccio</a><a href="https://github.com/lucasdicioccio">github: lucasdicioccio</a><a href="https://linkedin.com/in/lucasdicioccio">linkedin: lucasdicioccio</a></div></footer></article></div></body></html>