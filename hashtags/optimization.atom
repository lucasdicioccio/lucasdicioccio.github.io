<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title type="text">
        Lucas DiCioccio's blog
    </title>
    <id>
        https://dicioccio.fr/atom.xml
    </id>
    <updated>
        2022-02-09T21:50:00Z
    </updated>
    <entry>
        <id>
            https://dicioccio.fr/optimal-lab-samples-spreading.html
        </id>
        <title type="text">
            Optimal Lab Samples Spreading
        </title>
        <updated>
            2022-02-09T21:50:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;This article illustrates what the work of modeling a problem for constraint &lt;a href="/hashtags/optimization.html"&gt;&lt;span class="hashtag" data-hashtag="optimization"&gt;#optimization&lt;/span&gt;&lt;/a&gt; entails.&lt;/p&gt; &lt;h1 id="a-problem-with-a-vague-description"&gt;A &lt;a href="/hashtags/problem.html"&gt;&lt;span class="hashtag" data-hashtag="problem"&gt;#problem&lt;/span&gt;&lt;/a&gt; with a vague description&lt;/h1&gt; &lt;p&gt;Unless you’ve been living under a rock, you are aware that the COVID19 pandemic happened and is still ongoing. One thing that has become common at least in rich countries is the frequent tests we need to perform to validate whether a person is infected or not. A variety of test technologies have different characteristics, some tests can be done at home (rapid anti-genic tests). Whereas PCR tests need a specific person to carry the &lt;em&gt;sample&lt;/em&gt; then the samples are sent to a &lt;em&gt;laboratory&lt;/em&gt; that processes the PCR check.&lt;/p&gt; &lt;p&gt;Now let’s say there is some imbalance between PCR-check laboratories and some tests sites. A question that may arise is: how do we best allocate samples from various sampling &lt;em&gt;locations&lt;/em&gt; (e.g., pharmacies) to laboratories? There is some delay in sending tests to laboratories, and also there is a maximum delay to wait for a sample (otherwise the sample deteriorates and can no longer provide good material for the test). What do we do for a day, over a week?&lt;/p&gt; &lt;h1 id="an-off-the-shelf-model"&gt;An off-the-shelf model&lt;/h1&gt; &lt;p&gt;Before using a modeling approach solver, it’s always good to verify whether the problem has an easy-to-recognize shape. This instance looks like an &lt;a href="https://en.wikipedia.org/wiki/Maximum_flow_problem"&gt;max-flow problem&lt;/a&gt; where testing locations are sources and laboratories are samples: indeed maximizing the number of samples that go through testing is a way to minize those which are thrown out.&lt;/p&gt; &lt;p&gt;The following example shows a possible max-flow &lt;a href="/hashtags/model.html"&gt;&lt;span class="hashtag" data-hashtag="model"&gt;#model&lt;/span&gt;&lt;/a&gt; to this problem. On the left you have a fictional &lt;code&gt;demand&lt;/code&gt; node and on the right a fictional &lt;code&gt;processed&lt;/code&gt; node. The &lt;code&gt;from&lt;/code&gt; arrows are capacities which corresponds to the demand at each sample-collection location. The symmetric side of processing- capacities are &lt;code&gt;to&lt;/code&gt; arrows. The center arrows with &lt;code&gt;?&lt;/code&gt; are the attribution matrix. We could force some capacities to zero to say a sample-location is too far from a certain site, or leave them infinite to express that any amount of samples can be sent.&lt;/p&gt; &lt;p&gt;&lt;img src="/gen/images/labspread-maxflow.dot.png" alt="max-flow illustration" /&gt;&lt;/p&gt; &lt;p&gt;Running max-flow on this graph would determine how to maximize the number of processed samples. And the actual-values achieved the &lt;code&gt;?&lt;/code&gt; arrows correspond to a best assignment.&lt;/p&gt; &lt;p&gt;This is all good but in real-life we need to consider multiple days and other constraints. The iterated aspects may be annoying to model but somewhat manageable. For instance, we could add staged sources and sinks where some capacity connects a laboratory at two time intervals (this way &lt;em&gt;leftovers&lt;/em&gt; can be post-poned as additional inputs). In the following picture, we add a suffix &lt;code&gt;_0&lt;/code&gt; and &lt;code&gt;_1&lt;/code&gt; to represent the different stages. Thus an arrow &lt;code&gt;lab1_0 -&amp;gt; lab1_1&lt;/code&gt; represents leftovers at &lt;code&gt;lab1&lt;/code&gt; from the first staged processed in the second stage. We could view these arrows across stages as a degenerate form of sending samples between two different places in the time dimension.&lt;/p&gt; &lt;p&gt;&lt;img src="/gen/images/labspread-maxflow-iterated.dot.png" alt="max-flow illustration" /&gt;&lt;/p&gt; &lt;p&gt;Such a model starts to be slightly more cumbersome than the previous one, and also is &lt;em&gt;wrong&lt;/em&gt; because we do not properly model the deadline component. For instance, with many stages we could have a long chain of leftover samples until all samples are processed, irrespective from how old the samples are. Instead of having &lt;code&gt;leftovers&lt;/code&gt; from labs to labs at future time-steps, we rather need the &lt;code&gt;leftover&lt;/code&gt; arrows to go from sampling location to lab at future time-steps. Correcting for this fact we get the following schema:&lt;/p&gt; &lt;p&gt;&lt;img src="/gen/images/labspread-maxflow-iterated2.dot.png" alt="max-flow illustration" /&gt;&lt;/p&gt; &lt;p&gt;This model now seems correct and useful. However, in real-world setups we often refine models as new constraints are discovered or as new decisions are required. For instance, one behavior that would significantly alter the model would be to limit sampling sites to send samples to at most two labs. We may have to scrap our solution because the max-flow algorithm is not “cut” to make choices between alternatives (what we need is a form of knapsack at each sample-collection location). Such situations are common, and they correspond to situations where constraint-programming modeling shines. Constraint programming will let you trade generality for performance (i.e., we expect a slow down by using a more-general approach). Other situations where the adaptability of constraint-programming is useful is to probe what happens when a constraint actually turns-out to be a secondary goal (i.e., we relax a hard constraint into a soft-constraint and pretend we are geniuses).&lt;/p&gt; &lt;p&gt;Enough introduction, let’s see how we could formulate the problem in a constraint-programming language (using &lt;a href="https://minizinc.org/"&gt;MiniZinc&lt;/a&gt; as usual on this blog).&lt;/p&gt; &lt;h1 id="a-constraint-programming-model"&gt;A constraint-programming model&lt;/h1&gt; &lt;p&gt;Remember that to model a constraint-programming problem we need to formulate what are &lt;em&gt;inputs&lt;/em&gt;, &lt;em&gt;decisions&lt;/em&gt;, and &lt;em&gt;constraints&lt;/em&gt;. We also need some form of &lt;em&gt;objective&lt;/em&gt;.&lt;/p&gt; &lt;h2 id="high-level-model"&gt;high-level model&lt;/h2&gt; &lt;p&gt;We will assume that we have some time-based model of the demand in number of tests. We also assume that we know the labs capacities (this is no different from our introductory model).&lt;/p&gt; &lt;p&gt;In our case, a good starting point would be:&lt;/p&gt; &lt;p&gt;&lt;strong&gt;inputs&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;demand for samples from sample-collection locations &lt;/li&gt; &lt;li&gt;PCR lab capacities &lt;/li&gt; &lt;li&gt;some measure of the time it takes to send samples from one testing-site to a lab &lt;/li&gt; &lt;li&gt;the duration for which a sample is valid &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;decisions&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;some assignment from testing-sites to labs &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;constraints&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;samples must be processed within their lifetime or will be wasted &lt;/li&gt; &lt;li&gt;labs total work cannot overshoot their capacity &lt;/li&gt; &lt;li&gt;some form of &lt;strong&gt;conservation law&lt;/strong&gt; to say that samples are either tested in time or thrown away &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;objective&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;minimize the number of samples thrown away otherwise you can always assign zero from any testing-site to any lab &lt;/li&gt; &lt;/ul&gt; &lt;h2 id="formalized-in-minizinc"&gt;formalized in MiniZinc&lt;/h2&gt; &lt;p&gt;The core of the model would be something as follows:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;int: nLab; int: nZone; int: nTime; int: sample_lifetime; set of int: LAB = 1..nLab; set of int: ZONE = 1..nZone; set of int: TIME = 1..nTime; set of int: DELAY = 0..sample_lifetime; % demand of samples produced by zones array[ZONE,TIME] of int: demand; % capacity of labs to process samples, may vary with time to model things like week-ends array[LAB] of int: capacity; % transit represents a delay from one zone to some lab array[ZONE,LAB] of int: transit; % decisions about routing samples: dispatching and dropping samples int: maxAttr = sum(z in ZONE, t in TIME)(demand[z,t]); array[ZONE,LAB,TIME,DELAY] of var 0..maxAttr: dispatch; array[ZONE,TIME] of var 0..maxAttr: dropped; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Which introduces the inputs and the key decisions. We name &lt;code&gt;ZONE&lt;/code&gt; the set of sampling-locations because we could aggregate locations into zones beforehand, but also because we I found it hard to juggle with &lt;code&gt;LAB&lt;/code&gt; and &lt;code&gt;LOC&lt;/code&gt; all the time in my mind.&lt;/p&gt; &lt;p&gt;More importantly, we refined the decision to explicitly add a &lt;code&gt;DELAY&lt;/code&gt; component to the &lt;code&gt;dispatch&lt;/code&gt;-ed amount from a given ZONE to a given LAB at a given TIME. This delay corresponds to the dashed arrows we introduced in the max-flow model before. This extra breakdown is not especially surprising because we need to model the same “allowed physical behavior” whatever modeling technique we use. That said, in this model we went a bit further and we have broken down the total delay into two components: transit times (which are imposed by the &lt;code&gt;transit&lt;/code&gt; matrix) and queuing time (i.e., if a lab is busy one day but as spare capacity the next day we can backlog). The framing is very similar but are being a bit more explicit which chunk of the delay is forced upon us versus what chunk of the delay is a proper decision: this break down is important if you were to iterate on the model, or decide to increase capacity.&lt;/p&gt; &lt;p&gt;We also have a separate explicit &lt;code&gt;dropped&lt;/code&gt; decision, for all the samples that we cannot process. This decision is new compared to the max-flow model because in the max-flow model dropped quantities are implicit: dropped quantities correspond to amount of demand flow under the attributed capacity. In constraint-programming it is somewhat required to be explicit otherwise the solver will typically find an “uninteresting” solution (e.g., deciding that we drop everything implicitly because we have no way to express the conservation law).&lt;/p&gt; &lt;p&gt;Visually I represented this model as follows, in case it helps (demand at different times for a given zone are on the left, load for a given lab is the right). &lt;img src="/images/labspread-study.png" alt="sketch of model" /&gt;&lt;/p&gt; &lt;p&gt;We still need to link everything with constraints and write the objective function.&lt;/p&gt; &lt;h3 id="conservation-law"&gt;conservation law&lt;/h3&gt; &lt;p&gt;The conservation-law is not too complicated: at any given TIME, the demand is partitioned in two sets: dropped quantities and dispatched quantities.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;% must dispatch all demand constraint forall(z in ZONE, t in TIME) (demand[z,t] - dropped[z,t] = sum(l in LAB, d in DELAY)( dispatch[z,l,t,d] )); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Such conservation laws are often “hidden” behind inequalities. In this case I initially had a inequality saying that the dispatched amount had to be below the demand, it took me some time to realize that what is leftover deserves a concept in its own. Then, the conservation law appeared and it became easier to reason and debug with this extra ‘dropped’ variable.&lt;/p&gt; &lt;h3 id="samples-must-reach-a-lab-and-be-processed-within-their-lifetime"&gt;samples must reach a lab and be processed within their lifetime&lt;/h3&gt; &lt;p&gt;Here we are using some &lt;em&gt;implication&lt;/em&gt; connective that says that if the transit time and the considered queuing delay exceeds the sample lifetime, then the dispatched amount for this zone, lab, and delay has to be zero.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;% cannot delay (including transit time) past sample_lifetime constraint forall(z in ZONE, l in LAB, t in TIME, d in DELAY) ((transit[z,l] + d &amp;gt; sample_lifetime) -&amp;gt; dispatch[z,l,t,d] = 0); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This formal statement is worth reading at a slow pace because the formalism is not really a natural way of thinking. What makes such statements hard to parse is that we initially said that we want samples to be processed within their lifetime (i.e., we want a desired outcome to happen) whereas the statement speaks about preventing dispatching (i.e., we prevent the inverse of the desired outcome). I do not claim that it is impossible to reverse the logic, but I found no trivial ways to do so without introducing new variables.&lt;/p&gt; &lt;p&gt;Combined with the conservation law, this constraint will force undispatcheable quantities to move to the dropped quantity.&lt;/p&gt; &lt;h3 id="load-versus-capacity-at-lab"&gt;load versus capacity at LAB&lt;/h3&gt; &lt;p&gt;We need some way to prevent LABs overload. For this we need a definition of load of a LAB at a given time. This load consists of the dispatched amounts (including transit costs and backlog-delays).&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;% helper: workload processed by a lab at a given time (includes delayed dispatches) array[LAB,TIME] of var int: load; constraint forall(l in LAB, t_load in TIME) ( load[l,t_load] = sum(t_route in t_load-sample_lifetime..t_load where t_route &amp;gt; 0, z in ZONE) (dispatch[z,l,t_route,t_load-t_route]) ); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;It takes some work to sum all the right terms, but once we have the load at a given time, the constraint becomes trivial.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;% cannot overload labs constraint forall(l in LAB, t in TIME) (capacity[l] &amp;gt;= load[l,t]); &lt;/code&gt;&lt;/pre&gt; &lt;h3 id="objective-no-waste"&gt;objective: no waste&lt;/h3&gt; &lt;p&gt;This probably is the easiest part of the work. We sum the total dropped amounts and minimize this.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;var int: total_drop = sum(array1d(dropped)); solve minimize total_drop; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Overall, this objective combined with the conservation law gives some intuition about what a performing heuristic could look like: starting by dispatching zero we try to attribute fill labs with from closest zones in total delay. Fortunately, we do not need to write a heuristic and can just run our MiniZinc model.&lt;/p&gt; &lt;h2 id="running-the-model"&gt;Running the model&lt;/h2&gt; &lt;p&gt;You will find my model, some example data and even some synthetic-data generator written with a simple Ruby script at &lt;a href="https://github.com/lucasdicioccio/labspread"&gt;one of my GitHub repos&lt;/a&gt; .&lt;/p&gt; &lt;p&gt;The final model has one modification (see below) but also a slightly different output format than you get by default with MiniZinc (hopefully it’s more readable).&lt;/p&gt; &lt;p&gt;An example simple input that allows to understand what happens is a data file like the following:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;nLab = 3; nZone = 2; nTime = 5; sample_lifetime = 0; capacity = [|1,1,1,1,1 |1,1,1,1,1 |1,1,1,1,1 |]; transit = [|0,0,0 |0,0,0 |]; demand = [|1,1,2,0,10 |1,0,0,2,0 |]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In this data input, we see that there is uniform capacity of &lt;code&gt;1&lt;/code&gt; for tree labs. There is no transit delay, however the lifetime of samples is zero (i.e., we cannot backlog samples). The demand fluctuates at two sample-collection zones and overloads the total capacity at the end (we reach &lt;code&gt;10&lt;/code&gt;, otherwise we only use &lt;code&gt;2&lt;/code&gt;). Here it’s pretty clear that we expect to be able to serve the demand except for &lt;code&gt;7&lt;/code&gt; samples at the last time slot.&lt;/p&gt; &lt;p&gt;If we run the model from GitHub we get some textual output:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;(...truncated by me...) t=4 demand=2 capacity=3 drop=0 sent=(1-&amp;gt;1,0) (1-&amp;gt;2,0) (1-&amp;gt;3,0) (2-&amp;gt;1,1) (2-&amp;gt;2,1) (2-&amp;gt;3,0) load=(1,1)(2,1)(3,0) t=5 demand=10 capacity=3 drop=7 sent=(1-&amp;gt;1,1) (1-&amp;gt;2,1) (1-&amp;gt;3,1) (2-&amp;gt;1,0) (2-&amp;gt;2,0) (2-&amp;gt;3,0) load=(1,1)(2,1)(3,1) total_drop = 7 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We see that the we indeed drop &lt;code&gt;7&lt;/code&gt; in the last time slot but we never lost samples before. All is good. One can then play around starting from the data file and have fun changing parameters. For instance, allowing some extra lifetime, adding transit, and increasing the total demand. We can arrive at situations where backlogging is required.&lt;/p&gt; &lt;p&gt;With this input for instance,&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;nLab = 3; nZone = 2; nTime = 5; sample_lifetime = 2; capacity = [|1,1,1,1,1 |1,1,1,1,1 |1,1,1,1,1 |]; transit = [|0,1,2 |2,1,0 |]; demand = [|4,3,2,0,10 |3,0,10,2,0 |]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The capacity is still &lt;code&gt;3&lt;/code&gt; per day but the demand regularly overshoots (but not always). The full “best” solution for this problem becomes:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;t=1 demand=7 capacity=3 drop=1 sent=(1-&amp;gt;1,2) (1-&amp;gt;2,1) (1-&amp;gt;3,0) (2-&amp;gt;1,0) (2-&amp;gt;2,1) (2-&amp;gt;3,2) load=(1,1)(2,1)(3,1) t=2 demand=3 capacity=3 drop=1 sent=(1-&amp;gt;1,1) (1-&amp;gt;2,0) (1-&amp;gt;3,1) (2-&amp;gt;1,0) (2-&amp;gt;2,0) (2-&amp;gt;3,0) load=(1,1)(2,1)(3,1) t=3 demand=12 capacity=3 drop=6 sent=(1-&amp;gt;1,2) (1-&amp;gt;2,0) (1-&amp;gt;3,0) (2-&amp;gt;1,0) (2-&amp;gt;2,2) (2-&amp;gt;3,2) load=(1,1)(2,1)(3,1) t=4 demand=2 capacity=3 drop=0 sent=(1-&amp;gt;1,0) (1-&amp;gt;2,0) (1-&amp;gt;3,0) (2-&amp;gt;1,0) (2-&amp;gt;2,1) (2-&amp;gt;3,1) load=(1,1)(2,1)(3,1) t=5 demand=10 capacity=3 drop=0 sent=(1-&amp;gt;1,10) (1-&amp;gt;2,0) (1-&amp;gt;3,0) (2-&amp;gt;1,0) (2-&amp;gt;2,0) (2-&amp;gt;3,0) load=(1,1)(2,1)(3,1) total_drop = 8 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;sent&lt;/code&gt; lines correspond to the &lt;code&gt;dispatch&lt;/code&gt; matrix, with the following syntax &lt;code&gt;($zone-&amp;gt;$lab, $quantity)&lt;/code&gt;. We notice some underwhelming fact: when the demand overloads the capacity, labs are working at full-capacity. This realization is pretty important because in general there is not a large amount of wiggle-room to fix a capacity issue with scheduling &lt;strong&gt;to fix the capacity issue, increase capacity or drop the demand&lt;/strong&gt;; this rule of thumb is even more true when lifetimes are short compared to how fast you can increase capacities. This model allows to play with parameters and “see” how this teaching is true. For the story: I wanted to convey this information to the person working for the NHS who asked me about what we could do to help face the crisis; you are facing an fast-growing phenomenon and soon your capacity will be maxed-out. Thus, there will be no gain in being smart, better provide tools to get good visibility and efficient handling, which can play a role in increasing capacity.&lt;/p&gt; &lt;h2 id="avenues-for-modifications"&gt;Avenues for modifications&lt;/h2&gt; &lt;p&gt;It’s always important to step back and see how we could change the model. I do not want to use the word &lt;em&gt;improve&lt;/em&gt; the model because we actually build different models. Indeed: a simple model also requires less input data (which may not be easy to collect), and less testing/debugging work.&lt;/p&gt; &lt;p&gt;We provide a series of modifications that one may want to apply and discuss how we could adapt (or not) the model. The easy-changes have snippets of code to see how the constraint-programming approach is beneficial.&lt;/p&gt; &lt;h3 id="more-time-varying-variables"&gt;More time-varying variables&lt;/h3&gt; &lt;p&gt;Lab capacities are given as a fixed value. However we could easily modify the lab capacities to be known time-varying values. Such a change could allow to model the effect of opening/closing some labs for WE breaks. The change here is pretty limited, we would introduce a &lt;code&gt;TIME&lt;/code&gt; component to the capacity and use it in the adequate constraint:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;array[LAB,TIME] of int: capacity; % cannot overload labs constraint forall(l in LAB, t in TIME) (capacity[l,t] &amp;gt;= load[l,t]); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Such a model is the one I actually implemented first. The time-varying aspect of the capacity is not key in the structure of the problem (i.e., we do not change the number nor the shape of constraints, we merely change the bounds the load can take). Hence, it did not cost me much more to add.&lt;/p&gt; &lt;h3 id="more-physically-correct-model-of-test-performance"&gt;More physically-correct model of test-performance&lt;/h3&gt; &lt;p&gt;The quality of tests may deteriorate with the delay: in current model the ‘value’ of a test is implicitly binary: we get either 1 valid sample before the deadline or 0 past the deadline. We could imagine a different function with a smoother decrease in performance. Such a behavior could also help in providing different qualities or different deadlines depending on the sample-collection sites or the laboratories (e.g., because they use different sampling techniques or material).&lt;/p&gt; &lt;p&gt;For instance, if we attribute some dispatch value that decreases with the DELAY, we could use such an objective (turned into a maximization here).&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;var int: w = sum(z in ZONE, l in LAB, t in TIME, d in DELAY)(dispatch[z,l,t,d] * (sample_lifetime-d)); solve maximize w; &lt;/code&gt;&lt;/pre&gt; &lt;h3 id="varying-processing-costs-at-laboratories"&gt;Varying processing costs at laboratories&lt;/h3&gt; &lt;p&gt;We can imagine that the network of laboratories may process various samples at different costs. The cost function could take into account a different price depending on the LAB. The cost function could even be non-linear with some base-rate and an overshoot cost (it’s a way to relax moderately the capacity constraint). Such extra cost-modeling would lead the optimization to fill in cheapest LABs first in a “water-filling” approach (starting from the cheapest LAB reachable from a given ZONE until the LAB is no longer the cheapest alternative etc.).&lt;/p&gt; &lt;p&gt;We could do something like this:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;var int: w = sum(l in LAB, t in TIME)(processing_cost(l, load[l,t])); solve minimize w + drop_cost * total_drop; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Given a &lt;code&gt;processing_cost&lt;/code&gt; function mapping LABs and loads to a numerical cost we can incorporate the processing cost into the objective. Care as to be taken to still take into account the &lt;code&gt;total_drop&lt;/code&gt; amount and weight it accordingly to the processing_cost (otherwise the solver will cynically figure out that dropping every samples incurs no cost).&lt;/p&gt; &lt;h3 id="more-faithful-representation-of-probabilities"&gt;More faithful representation of probabilities&lt;/h3&gt; &lt;p&gt;Actual demand in test is pretty unknown: using stochastic programming could help having more acceptable results (a typical implementation is to discretize the probability distribution, another one is to produce a large amount of simulated scenarios). The change requires to provide a discretized weighed probability of input demand values instead of one demand value per time step and average over scenarios. I find hard to stay within the constraint-programming model framework for this problem because a constraint-programming model decides once what are the action taken at every future time step. In such a situation, where you believe you need to go all the way to model stochastic behaviors you may as well spend the efforts to model how successive choices can take advantage of the facts that become known as the time passes. Here you may want to reach for bigger guns like &lt;a href="https://www.mit.edu/~dimitrib/Dynamic_Prog_Videos.html"&gt;optimal-control and reinforcement learning&lt;/a&gt; theory (here, a single-stage CP could be a rollout-heuristic – but we are eyeing on state-of-the-art topics rather than on a humble blog post).&lt;/p&gt; &lt;h3 id="more-business-constraints"&gt;More business constraints&lt;/h3&gt; &lt;p&gt;As provided in the introduction. A reason to avoid spending too much time in using an off-the-shelf algorithm can be a simple business-rule such as “a testing site can ship at most twice per day”, which would mean our optimization no-longer looks like a well-studied &lt;em&gt;max-flow&lt;/em&gt; problem. Rather, this real-world problem becomes flavored with a bit of bin-packing because we cannot pick all the variables of the output attribution matrix independently from each other.&lt;/p&gt; &lt;p&gt;Building such a constraint is non-trivial because you need an array of auxiliary variables telling how many LABs a ZONE serves at a given TIME (irrespective of the DELAY). Say you get a &lt;code&gt;sent&lt;/code&gt; array. Then force the cardinality of zeros with a &lt;a href="https://www.minizinc.org/doc-2.5.5/en/lib-globals.html#counting-constraints"&gt;global counting constraint&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;That said, the overall constraint is not that complicated to write.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;% helper: work sent from zone to a lab at a given time (whichever delay is dispatched) array[ZONE,LAB,TIME] of var 0..maxAttr: sent; constraint forall(l in LAB, z in ZONE, t in TIME) (sent[z,l,t] = sum(d in DELAY)(dispatch[z,l,t,d])); % max two sent int: maxShipment = 2; include &amp;quot;globals.mzn&amp;quot;; constraint forall(t in TIME, z in ZONE)( count([sent[z,l,t]|l in LAB],0) &amp;gt;= nLab-maxShipment ); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In that case, switching the solver type may significantly alter performance. It would be useful to force ourselves to model this problem as a mixed-integer-linear-programming problem, but that would become rather complicated if you combine these alterations to the initial problem.&lt;/p&gt; &lt;/section&gt;&lt;section class="main-section"&gt;&lt;h1 id="closing-remarks"&gt;Closing remarks&lt;/h1&gt; &lt;p&gt;Before starting modeling the problem with a constraint-programming language, let’s keep in mind that we should always do the work of trying to apply an off-the-shelf but under-constrained algorithm: sometimes it works (i.e., you are lucky that the solution actually fits the extra constraints), sometimes you get a perspective that is useful for the problem (e.g., here we re-used the idea of &lt;em&gt;leftovers&lt;/em&gt;), and at worst you can also use an “under-constrained” solution to get a approximation or an higher-bound to accept/reject some alternative (e.g., you have two alternatives situations you could reject one alternative because we cannot expect an optimal solution to beat the average of the other alternative).&lt;/p&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/optimal-lab-samples-spreading.html" rel="alternate"/>
        <summary type="text">
            An illustration of how to model a constraint-problem to optimally distribute testing samples to laboratories.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/santa-wrap.html
        </id>
        <title type="text">
            Advent of Haskell 2020: Santa Wrap
        </title>
        <updated>
            2020-12-24T12:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;This article is part of &lt;a href="https://adventofhaskell.com/"&gt;Advent of Haskell&lt;/a&gt; 2020 &lt;span class="emoji" data-emoji="christmas_tree"&gt;🎄&lt;/span&gt;. Make sure to check the other articles too! You will find the code for this blog-post at &lt;a href="https://github.com/lucasdicioccio/santa-wrap/"&gt;the original GitHub publication&lt;/a&gt;.&lt;/p&gt; &lt;h2 id="our-christmas-project"&gt;Our Christmas project&lt;/h2&gt; &lt;p&gt;Year 2020 is terrible. Santa’s Workshop had to take stay-at-home restrictions. However, Elves want to do the utmost to keep Christmas’ spirit alive. This year, Elves will work from home rather than work in the streamlined workshop &lt;span class="emoji" data-emoji="factory"&gt;🏭&lt;/span&gt; . They will get back to a more traditional way of preparing presents, like Elderly Elves who live more than 500 years, remember. In short, every Elf works in their own garage &lt;span class="emoji" data-emoji="house"&gt;🏠&lt;/span&gt;. They receive the Christmas wishlists of neighboring families: crafting toys &lt;span class="emoji" data-emoji="space_invader"&gt;👾&lt;/span&gt;, sewing clothes &lt;span class="emoji" data-emoji="shirt"&gt;👕&lt;/span&gt;, or cooking delicious cookies &lt;span class="emoji" data-emoji="cookie"&gt;🍪&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;One particularly annoying task for work-from-home Elves, however, is to wrap presents &lt;span class="emoji" data-emoji="gift"&gt;🎁&lt;/span&gt;. They had avoided this task in the recent years thanks to automation. Elves all have different pieces of wrapping-paper at home, in particular wrapping-paper rolls vary in ratio and vary in size from one Elf to another one. Elves want some software to help them cut wrapping-paper for the presents they prepare &lt;span class="emoji" data-emoji="scissors"&gt;✂️&lt;/span&gt;. Some Elves have tools to cut paper (think of a cookie-cutter, but for large sheets of paper), whereas others only have cissors. Wrapping may become scarce if used inefficiently, and anyway ordering takes time. Thus, they would like to have a rough idea of how to efficiently cut the paper rolls given their own specific constraints. It does not have to be perfect, but it cannot be completely naive either. Thus, Elves need some creative idea to save Christmas’ spirit. For the better or for the worst Elves resorted to use software &lt;span class="emoji" data-emoji="computer"&gt;💻&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Fortunately, an Elf has learnt Haskell, a language especially good for building small command line tools and with libraries to generate images. He also has learnt MiniZinc, a language especially good for solving this family of problems. Put together, these languages can help building a small tool that Elves can run at home with their own input. This computer-savvy Elf suggests the following &lt;a href="/hashtags/trade-off.html"&gt;&lt;span class="hashtag" data-hashtag="trade-off"&gt;#trade-off&lt;/span&gt;&lt;/a&gt;:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Elves will input the quantity and shape of the wrapping for the presents (or the shape of their cookie-cutter tools that fit for the present) &lt;/li&gt; &lt;li&gt;the shape of the wrapping is blocky, that is, made of various rectangle blocks, rather than arbitrarily shaped (it simplifies cutting and folding paper with rulers and guides anyway) &lt;/li&gt; &lt;li&gt;Elves will also input the size of their own paper sheets &lt;/li&gt; &lt;li&gt;the output is a footprint image of how to cut the paper to fit all present (when possible) Some Elves expected more specialized tools, some cared especially about saving wrapping paper. However, time is running out, our software Elf-ineer only has a day to build this software or it will be too late to save Christmas. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;I am not sure I should reveal this, but, I work in Santa Incorporated oh oh oh. Do not tell your kids! in exchange I’ll explain you how I built &lt;code&gt;santa-wrap&lt;/code&gt; in a rush to help the Elf. Thus, the main goal for this article is to relate how to iterate quickly on a practical one short day project. Secondary goals are to pike your interest about MiniZinc and introduce you a library named &lt;code&gt;minizinc-process&lt;/code&gt;.&lt;/p&gt; &lt;h2 id="approach"&gt;Approach&lt;/h2&gt; &lt;p&gt;The type of problem for cutting wrapping paper is known as a Packing problem. These problems are generally difficult to solve efficiently. However, for small sizes or particular form of constraints, some solutions could be efficiently found (or the litterature may have some heuristics that work well empirically). Generally, the difficulty comes from integrality of constraints, that is you either can wrap a present or not wrap the present, you cannot wrap a fraction of a present. Such problems come up a lot in industrial settings where some resource is scarce. In this particular case, we cheated a bit as we came with an idea to write a blog post. However, with a bit of practice you will recognize packing problems everywhere.&lt;/p&gt; &lt;p&gt;We want to show off how to combine MiniZinc (a mathematical &lt;a href="/hashtags/optimization.html"&gt;&lt;span class="hashtag" data-hashtag="optimization"&gt;#optimization&lt;/span&gt;&lt;/a&gt; language and toolchain) with Haskell (which readers of this Advent of Haskell submission are familiar with). We will show the progression of a tool, with building a value-adding prototype in a day or two of work for some Elf familiar with Haskell and Minizinc.&lt;/p&gt; &lt;h2 id="motivating-our-iterations"&gt;Motivating our Iterations&lt;/h2&gt; &lt;p&gt;The author built this tool in four broad iterations: implement a demo solver in MiniZinc, generate simple pictures for each wrapping, introduce the concept of layout, and, bridge the solver. We motivate each iteration before jumping into lengthier explanations.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Implemeting a solver in MiniZinc&lt;/em&gt;: I wanted to leverage powerful global constraints with their own heuristics/optimized solutions that exist in MiniZinc. Such a model helps us formalize the problem in better terms and understand what are inputs and what are outputs. In a business settings, such prototypes allow to raise the important questions. In that case, the whole problem is solved with a single &lt;a href="https://www.minizinc.org/doc-2.3.0/en/lib-globals.html#packing-constraints"&gt;global contraint&lt;/a&gt; named &lt;code&gt;geost_bb&lt;/code&gt;. Knowing which constraints help modeling a problem is a type of expertise that takes time to acquire but that can change drastically the viability of such a tool.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Generate simple pictures&lt;/em&gt;: our tool needs to generate pictures of the wrapping, and I find a blog-post with picture more appealing than without. Visualizations illustrate the problem. I am not familiar with low-level graphics libraries. I typically use high-level tools for my charts like &lt;a href="https://ggplot2.tidyverse.org/"&gt;ggplot in R&lt;/a&gt; – they typically get in the way if what you want is pixel-perfect position of image width/height. For this exercise, I found &lt;a href="https://hackage.haskell.org/package/JuicyPixels"&gt;JuicyPixels&lt;/a&gt; and I need to validate quickly that JuicyPixels will fit the needs. This library is appealing because I could generate PNGs with little dependencies. I had some experience with &lt;a href="https://hackage.haskell.org/package/gloss"&gt;Gloss&lt;/a&gt;. However, I discarded this choice for I only need static images and not animations (and Gloss has way more dependencies than JuicyPixels).&lt;/p&gt; &lt;p&gt;&lt;em&gt;Introduce the concept of layout&lt;/em&gt;: pictures become more interesting when we start to have multiple boxes. Once I know how to print a layout I am done with the graphical aspects of the problem. Minor improvements can still come later but it is mind-relaxing to call something done. Further, at this point it is easy to show some naive layouts.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Bridge the solver&lt;/em&gt;: this is the boiler-plate part of the work. &lt;code&gt;minizinc-process&lt;/code&gt; actually have a TemplateHaskell helper to generate an input and output representations but this approach is limited: it cannot work with sets in its current version and does not preclude writing boilerplate to transform between “business-domain” representations and solver input/output representations. Plus, the goal of the article is to illustrate the pro/cons. This part of boiler-plate is the one requiring the most care, hence my usage of newtypes to differentiate indices.&lt;/p&gt; &lt;p&gt;Graphically, the following dependency graph shows the various steps I had in mind. &lt;img src="images/deps.png" alt="img" /&gt; In red are the two chunks of work which I assessed has being the most uncertain (i.e., requiring the most discovery) or most meticulous (i.e., spending time building accurate types to reduce the risk of bugs).&lt;/p&gt; &lt;p&gt;Let’s discuss how this four iterations looked like.&lt;/p&gt; &lt;h2 id="the-four-iterations"&gt;The four iterations&lt;/h2&gt; &lt;p&gt;We now dive in more details into each iteration. Recall that I time-boxed this project to the equivalent of a short-day-of-work. Readers should be able to read these independently.&lt;/p&gt; &lt;h3 id="a-solver-in-minizinc"&gt;A solver in MiniZinc&lt;/h3&gt; &lt;p&gt;We basically call the &lt;em&gt;global contstraint&lt;/em&gt; &lt;code&gt;geost_bb&lt;/code&gt;. Let’s unpack how it works, starting from a small MiniZinc overview and a mini tutorial on &lt;code&gt;geost_bb&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;In &lt;a href="https://www.minizinc.org/"&gt;MiniZinc&lt;/a&gt; you separate the structure of a problem (which we call a model) and its particular instance (determined by input parameters). Thus a model can run for various input parameters. Further, the model separate two families of variables: the &lt;em&gt;par&lt;/em&gt; variables (parameters that are given or can be deterministically computed from other parameters) and &lt;em&gt;var&lt;/em&gt; variables (decisions that the solver will make). Constraints are statement that link variables together. The solver, then works out solutions (that is assignments of variables) that are consistent with all constraints. It is typically easy to verify that a given assignment matches all constraints. For instance, in our Santa-Wrap tool can visually inspect whether or not cutting guides for different present intersect. Whereas, it is typically hard to find a given assignment for all possible &lt;em&gt;par&lt;/em&gt; inputs (or an optimal one when a criteria of goodness exists).&lt;/p&gt; &lt;p&gt;In Haskell parlance: &lt;code&gt;solver :: Model -&amp;gt; Parameters -&amp;gt; Maybe Decisions&lt;/code&gt;, which, partially-applied for some &lt;code&gt;Model&lt;/code&gt; would give &lt;code&gt;solveProblem :: Parameters -&amp;gt; Maybe Decisions&lt;/code&gt;. To encode this faithfully in Haskell we would need to ensure that the &lt;code&gt;Parameters&lt;/code&gt; and &lt;code&gt;Decisions&lt;/code&gt; types actually depends on the &lt;code&gt;Model&lt;/code&gt;; somehow, discussing these type-level programming techniques is out of scope for this article.&lt;/p&gt; &lt;p&gt;Typically, writing MiniZinc is a bit like SQL queries: you describe what you want and let the engine fetch it for you. The ability to summon a magic tool to solve our wishes comes with some limitations: expressivity is limited, and you need to be careful what you wish for. For instance, when writing MiniZinc you need to discuss about finite inputs/outputs (e.g, no unbounded recursion). Further, small changes on the structure of the problem can drastically change performance (like switching from a index scan to a table scan in SQL query plan).&lt;/p&gt; &lt;p&gt;The comparison with SQL does not stops at the declarative aspect. Typical domain models in Haskell have collections such as &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List.html"&gt;Lists&lt;/a&gt; or &lt;a href="https://hackage.haskell.org/package/containers-0.6.4.1/docs/Data-Map.html"&gt;Maps&lt;/a&gt; or custom &lt;a href="http://www.cse.chalmers.se/edu/year/2018/course/TDA452/lectures/RecursiveDataTypes.html"&gt;recursively-shaped objects&lt;/a&gt; etc. Once mapped into tabular form in SQL, special conversion care is required. For instance, in Haskell, a type &lt;code&gt;User { age :: Int , height :: Int }&lt;/code&gt; would map to a set of integers (one user-id per user) and two arrays indexed by user-id. So that Haskell domain objects like these.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;users ::&lt;/span&gt; [ &lt;span class="dt"&gt;User&lt;/span&gt; ]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;users &lt;span class="ot"&gt;=&lt;/span&gt; [ &lt;span class="dt"&gt;User&lt;/span&gt; &lt;span class="dv"&gt;23&lt;/span&gt; &lt;span class="dv"&gt;172&lt;/span&gt;, &lt;span class="dt"&gt;User&lt;/span&gt; &lt;span class="dv"&gt;45&lt;/span&gt; &lt;span class="dv"&gt;180&lt;/span&gt;, &lt;span class="dt"&gt;User&lt;/span&gt; &lt;span class="dv"&gt;36&lt;/span&gt; &lt;span class="dv"&gt;165&lt;/span&gt; ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Would translate to the following MiniZinc.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: USER = 1..3; array[USER] of int: age = [ 23, 45, 36 ]; array[USER] of int: height = [ 172, 180, 165 ]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Readers familiar with Relational Algebra, DataParallel Haskell, Columnar Storage, or Entity Component System will find comonalities. We will work this out for our problem in more detail in the last iteration. So now let’s look at &lt;code&gt;geost_bb&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Here is a snapshot of &lt;code&gt;geost_bb&lt;/code&gt; &lt;a href="https://www.minizinc.org/doc-2.5.0/en/lib-globals.html"&gt;documentation&lt;/a&gt; &lt;img src="images/geost-doc.png" alt="img" /&gt;. Which sorts of packs blocky-structure on a multi-dimensional space. This constraint does not try to shrink gaps between objects, it “merely” (I don’t want to downplay how great this is) force assignments of variables such that no overlap exists between the packed objects.&lt;/p&gt; &lt;p&gt;We annotate the parameters below to explain why using this function make sense in Santa-Wrap. Besides the opaque name, it does exactly what we want to help the Elves and even a bit more.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;em&gt;k&lt;/em&gt;: here we live in two dimensions, that an easy parameter, we’ll hardcode it &lt;/li&gt; &lt;li&gt;&lt;em&gt;rect_size&lt;/em&gt;: size of each rectangles along each dimension &lt;/li&gt; &lt;li&gt;&lt;em&gt;rect_offset&lt;/em&gt;: offset of rectangles long each dimension &lt;/li&gt; &lt;li&gt;&lt;em&gt;shape&lt;/em&gt;: wrapping shapes are built from a set of a rectangles, for instance presents we can wrap in a simple rectangle would have a single rectangle. More elaborated wrapping shapes may require two or more adjacent rectangles. For instance the sword here is built with two overlapping rectangles: &lt;img src="images/sword.png" alt="img" /&gt; a rectangle is horizontal (largest &lt;em&gt;rect_size&lt;/em&gt; is the 1st dimension) and another rectangle is vertical (largest &lt;em&gt;rect_size&lt;/em&gt; is the 2nd dimension) and both rectangles are translated along an axis (i.e., one non-zero &lt;em&gt;rect_offset&lt;/em&gt;). Multiple shapes could re-use the same rectangles if they happen to match (hence, saving a bit on the complexity – but we won’t go into this level of sophistication). &lt;/li&gt; &lt;li&gt;&lt;em&gt;l&lt;/em&gt; and &lt;em&gt;u&lt;/em&gt;: upper and lower bounds for each wrapping, in our case all objects can equally be positioned on the wrapping, hence the lower bound is 0 and the upper bound the size of the roll (minus one if you care about millimeters and took no margins of error at all in your measurements) &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Then &lt;code&gt;geost_bb&lt;/code&gt; then contributes constraints to tell the solver to make a number of decisions:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;x&lt;/code&gt;: the coordinates of the &lt;em&gt;wrapping shapes&lt;/em&gt; (which are themselves built of rectangular blocks). For our sword example, we need to add the &lt;code&gt;rect_offset&lt;/code&gt; to the &lt;code&gt;x&lt;/code&gt; coordinate of the shape to position a rectangle. &lt;/li&gt; &lt;li&gt;&lt;code&gt;kind&lt;/code&gt;: the shape used by each object. This mechanism allows &lt;code&gt;geost_bb&lt;/code&gt; to chose any shape for the different objects. External constraints actually prevent &lt;code&gt;geost_bb&lt;/code&gt; does not know how many times it must be using the wrapping-shape for a sword, and unconstrained the solver would rather prefer the simpler wrapping-shape for a book. This mechanism actually is a feature: the freedom to pick among shapes allows to model rotation of shapes, we will not use this for now. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;In our case, for a first version of the tool we do not need to make that many decisions: only &lt;code&gt;x&lt;/code&gt; above is required. Declaring all inputs to give to &lt;code&gt;geost_bb&lt;/code&gt; is required, however. We still need to actually declare our &lt;code&gt;par&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; variables.&lt;/p&gt; &lt;p&gt;We will have to discuss about a number of entities:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;two dimensions: &lt;code&gt;int: nDims = 2; set of int: DIM = 1..nDims&lt;/code&gt; &lt;/li&gt; &lt;li&gt;wrapping shapes: &lt;code&gt;int: nShapes; set of int: SHAPE = 1..nShapes&lt;/code&gt; &lt;/li&gt; &lt;li&gt;rectangular blocks: &lt;code&gt;int: nBlocks; set of int: BLOCK = 1..nBlocks&lt;/code&gt; &lt;/li&gt; &lt;li&gt;each object we need to wrap: &lt;code&gt;int: nObjs; set of int: OBJ = 1..nObjs&lt;/code&gt; &lt;/li&gt; &lt;li&gt;the roll: it is implicit that we cut one roll, so we do not need to declare anything &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Then, some characteristics of entities:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;the size of the roll: &lt;code&gt;int: x_max; int: y_max&lt;/code&gt; &lt;/li&gt; &lt;li&gt;the size of individual rectangular blocks and their offsets in each dimension: &lt;code&gt;array[BLOCK,DIM] of int: rect_sizes; array[BLOCK,DIM] of int: rect_offs&lt;/code&gt; &lt;/li&gt; &lt;li&gt;the coordinates of where to position cuts for our solution: &lt;code&gt;array[OBJ,DIM] of var int: coordinates&lt;/code&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Finally there is relational information linking various entities.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;to each object we associate a given shape (present1 is a Guitar, present2 is a book etc.): &lt;code&gt;array[OBJ] of SHAPE: object_shapes;&lt;/code&gt; &lt;/li&gt; &lt;li&gt;each shape is the collage of a set of rectangle, we could use various external representation to model the set of rectangles (e.g., an &lt;code&gt;array[SHAPE,RECTANGLE] of bool&lt;/code&gt; is isomorphic to an &lt;code&gt;array[SHAPE] of set of RECTANGLE&lt;/code&gt;) but we will stick to the &lt;code&gt;set&lt;/code&gt; representation that &lt;code&gt;geost_bb&lt;/code&gt; requires (using another input would require extra constraints to link input and &lt;code&gt;geost_bb&lt;/code&gt; representations) &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;All in all, the model is in &lt;code&gt;models/santa-wrap.mzn&lt;/code&gt; and an example input for it is &lt;code&gt;models/santa-wrap001.dzn&lt;/code&gt;. You can run it with &lt;code&gt;minizinc models/santa-wrap.mzn models/santa-wrap001.dzn&lt;/code&gt;. And the output I got was:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;coordinates = array2d(1..10, 1..2, [8, 0, 0, 6, 7, 0, 0, 5, 6, 0, 0, 4, 4, 0, 0, 2, 2, 0, 0, 0]); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Which you can read as “first object” is a (8,0), the “second object” is at (0,6) etc. Elves could work with such an output, however a visual display is better. Plus they want to prepare their cutting boards, build guides, or simply pass an eye-check that things are in the right place.&lt;/p&gt; &lt;h3 id="generate-simple-pictures"&gt;Generate simple pictures&lt;/h3&gt; &lt;p&gt;I have had little interest in graphics in the past. Thus I vaguely know some Haskell libraries exist like &lt;a href="https://hackage.haskell.org/package/diagrams"&gt;diagrams&lt;/a&gt;, &lt;code&gt;gloss&lt;/code&gt;, &lt;code&gt;JuicyPixels&lt;/code&gt;, or &lt;a href="https://hackage.haskell.org/package/reanimate"&gt;reanimate&lt;/a&gt;. For this project, I had to dive a bit more and actually pick some library. My choice settled on &lt;code&gt;JuicyPixel&lt;/code&gt; for two main reasons: on the first hand, this library has only a small amount of dependencies (especially system dependencies – &lt;code&gt;gloss&lt;/code&gt; requires some OpenGL). On the other hand, the documentation was welcoming: I looked for &lt;code&gt;IO ()&lt;/code&gt; because I looked for some “main” or “print” equivalent. The first hit on the top module is &lt;code&gt;generateImage&lt;/code&gt;. No kidding, here is the screenshot to prove it: first hit &lt;img src="images/haddock-jp.png" alt="img" /&gt;.&lt;/p&gt; &lt;p&gt;The type information tells me the library actually scans every pixel one by one. It is very likely super inefficient. That said, the cost of optimizing the packing is the major bottleneck in this problem. Elves can wait a minute to save hours. A warming case that does not corroborate the claim that Haskell libraries are poorly documente. My first action was to verify that the example actually works.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-shell"&gt;cabal repl &amp;gt; import Code.Picture &amp;gt; let path = &amp;quot;images/background.png&amp;quot; &amp;gt; let pixelRenderer x y = PixelRGB8 (fromIntegral x) (fromIntegral y) &amp;gt; writePng path $ generateImage pixelRenderer 250 300 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;And voila! &lt;img src="images/background.png" alt="img" /&gt; thank you so much &lt;code&gt;JuicyPixels&lt;/code&gt;. It’s not “too good to be true”: the example works.&lt;/p&gt; &lt;p&gt;Having secured that I can generate PNG, what is left? we need to define some Haskell data types to map loosely with what I’ve learnt is required in the MiniZinc optimization. However we’ll be using Haskell records rather than columnar values. The idea here is to use these data types as main Haskell types for parsing a format that Elves are likely to know such as JSON. Further we want to allow Elves to pass extra information like quantities of each present they will wrap, colors and names for pictures before crafting the guides etc.&lt;/p&gt; &lt;p&gt;Some excerpt:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; {&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; name ::&lt;/span&gt; &lt;span class="dt"&gt;Name&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; colorNum ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; quantity ::&lt;/span&gt; &lt;span class="dt"&gt;Quantity&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rectangles ::&lt;/span&gt; [ &lt;span class="dt"&gt;Rectangle&lt;/span&gt; ]&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt;&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt; {&lt;/span&gt; &lt;span id="10"&gt;&lt;a href="#10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; rectX ::&lt;/span&gt; &lt;span class="dt"&gt;Length&lt;/span&gt;&lt;/span&gt; &lt;span id="11"&gt;&lt;a href="#11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rectY ::&lt;/span&gt; &lt;span class="dt"&gt;Length&lt;/span&gt;&lt;/span&gt; &lt;span id="12"&gt;&lt;a href="#12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; offX ::&lt;/span&gt; &lt;span class="dt"&gt;X&lt;/span&gt;&lt;/span&gt; &lt;span id="13"&gt;&lt;a href="#13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; offY ::&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt;&lt;/span&gt; &lt;span id="14"&gt;&lt;a href="#14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="15"&gt;&lt;a href="#15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Wrappings are built of Rectangles. Each Rectangle as length/width (lengths in both dimensions &lt;code&gt;rectX&lt;/code&gt;, &lt;code&gt;rectY&lt;/code&gt;) as well as some offset in both dimension. In addition, each Wrapping has a name, a quantity and some color to visualize more easily a layout. But before speaking about Layouts, what we can do is to generate pictures for each Wrapping. This way, Elves can calibrate the units and verify individual length.&lt;/p&gt; &lt;p&gt;I need to adapt the &lt;code&gt;JuicyPixels&lt;/code&gt; example I copy pasted to build a function &lt;code&gt;printWrapping :: Wrapping -&amp;gt; IO()&lt;/code&gt;. In short, it has a &lt;code&gt;Wrapping&lt;/code&gt; and its associated &lt;code&gt;Rectangles&lt;/code&gt; in scope and we need to implement &lt;code&gt;pixelRenderer&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;So I’ll build utility functions &lt;code&gt;findRectangle x y&lt;/code&gt; which finds a rectangle with the right sizes and offset to contain the pixel &lt;code&gt;(x,y)&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;A single pixel and rectangle test is&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rectangleContainsPixel x y rect &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;let&lt;/span&gt; x0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offX rect&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; x1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offX rect &lt;span class="op"&gt;+&lt;/span&gt; rectX rect&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offY rect&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offY rect &lt;span class="op"&gt;+&lt;/span&gt; rectY rect&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;in&lt;/span&gt; x0 &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; x &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; x &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; x1 &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; y0 &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; y &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; y &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; y1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Which checks for intervals in both X and Y. The &lt;code&gt;scale&lt;/code&gt; function just multiplies tenfold every magnitude (i.e., a dimension of 1 Length is shown with 10 pixel). With that utility function we can now test every rectangles: if some is found, we color the Pixel with some value, otherwise we use default background value.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;pixelRenderer x y &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;case&lt;/span&gt; findRectangle x y &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;PixelRGB8&lt;/span&gt; (&lt;span class="fu"&gt;fromIntegral&lt;/span&gt; x &lt;span class="ot"&gt;`mod`&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;) (&lt;span class="fu"&gt;fromIntegral&lt;/span&gt; y &lt;span class="ot"&gt;`mod`&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;) &lt;span class="dv"&gt;128&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Just&lt;/span&gt; idx &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; pixelColor idx&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;findRectangle x y &lt;span class="ot"&gt;=&lt;/span&gt; List.findIndex (rectangleContainsPixel x y) (rectangles wrapping)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;I use &lt;code&gt;List.findIndex&lt;/code&gt; so that on a hit i can also attribute some color (see &lt;code&gt;pixelColor :: Int -&amp;gt; PixelRGB8&lt;/code&gt; which defines a palette) and paint the rectangle in a different color.&lt;/p&gt; &lt;p&gt;Another utility function is needed to give &lt;code&gt;JuicyPixel&lt;/code&gt; the size of the picture to create. This size corresponds to the farthest point in the set of off-set rectangles &lt;code&gt;maxX = maximum (0 : [ rectX r + offX r | r &amp;lt;- rectangles wrapping ])&lt;/code&gt;, I named this value the &lt;code&gt;extentX&lt;/code&gt; of a &lt;code&gt;Wrapping&lt;/code&gt; in later commits. I use comprehension list notation. I add a 0 so that &lt;code&gt;maximum&lt;/code&gt; does not crash on an empty list.&lt;/p&gt; &lt;p&gt;Our &lt;code&gt;main&lt;/code&gt; function basically parses &lt;code&gt;stdin&lt;/code&gt; into some &lt;code&gt;[Wrapping]&lt;/code&gt; and &lt;code&gt;traverse&lt;/code&gt; this list with our PNG generator.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;mainParts &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; wrappings &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; eitherDecode&amp;#39; &lt;span class="op"&gt;@&lt;/span&gt;[&lt;span class="dt"&gt;Wrapping&lt;/span&gt;] &lt;span class="op"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="fu"&gt;getContents&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;case&lt;/span&gt; wrappings &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Left&lt;/span&gt; err &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;print&lt;/span&gt; err&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Right&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; traverse_ printWrapping xs&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="fu"&gt;putStrLn&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;done!&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The parsing leverages the automatically-generated &lt;code&gt;instance FromJSON&lt;/code&gt; from &lt;code&gt;aeson&lt;/code&gt; (extension &lt;code&gt;DeriveGeneric&lt;/code&gt;). Note that we use &lt;code&gt;TypeApplications&lt;/code&gt; for the syntax &lt;code&gt;@[Wrapping]&lt;/code&gt; which explicitates what we are decoding from the content in &lt;code&gt;stdin&lt;/code&gt;, which also helps GHC provide less general error message when I change and break things.&lt;/p&gt; &lt;p&gt;This way, our main binary can generate individual images.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-console"&gt;$ santa-wrap parts &amp;lt; input/wrapping001.json $ done! &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The parts are individual &lt;code&gt;.png&lt;/code&gt; files as this listing shows: &lt;img src="images/parts.png" alt="img" /&gt;. Elves can use these parts to prepare some guides to later cut wrapping paper rapidly.&lt;/p&gt; &lt;p&gt;Now let’s finally introduce the concept of layout.&lt;/p&gt; &lt;h3 id="introduce-the-notion-of-layout"&gt;Introduce the notion of layout&lt;/h3&gt; &lt;p&gt;The layout is a collection of positioned wrappings. There’s an obvious Functor instance for Positioned. I could refactor Rectangle into a Positioned Rect. This way, a Layout is a &lt;code&gt;[ Positioned [ Positioned Rect ] ]&lt;/code&gt; and it is probably collapsable into a single list by translating the inner Positioned objects. Something like &lt;code&gt;flatten :: [ Positioned [ Positioned a ] ] -&amp;gt; [ Positioned a ]&lt;/code&gt; I feel tempted to actually dig in this direction. However, I’m far from done and the clock ticks. In short, I will save this for later and perform a good amount of copy-pasting.&lt;/p&gt; &lt;p&gt;The Haskell code is simply:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; {&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; posX ::&lt;/span&gt; &lt;span class="dt"&gt;X&lt;/span&gt; &lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; posY ::&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt; &lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; item ::&lt;/span&gt; a &lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Functor&lt;/span&gt;)&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt; {&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; positionedWrappings ::&lt;/span&gt; [ &lt;span class="dt"&gt;Positioned&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; ]&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;And now my &lt;code&gt;printLayout&lt;/code&gt; function has a very similar &lt;code&gt;pixelRenderer&lt;/code&gt;. Two distinctions though:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;to color a pixel you need to determines if a &lt;code&gt;Wrapping&lt;/code&gt; has a &lt;code&gt;Rectangle&lt;/code&gt; and the &lt;code&gt;Rectangles&lt;/code&gt; are translated by &lt;code&gt;posX&lt;/code&gt; and &lt;code&gt;posY&lt;/code&gt;. &lt;/li&gt; &lt;li&gt;we want to add a few pixels of &lt;code&gt;margin&lt;/code&gt; so that a series of adjacent squares do not appear like a long rectangle, this small margin will ease verifying layouts at a glance. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Hence, our &lt;code&gt;rectangleContainsPixel&lt;/code&gt; test takes all these things into account:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;rectangleContainsPixel ::&lt;/span&gt; &lt;span class="dt"&gt;X&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rectangleContainsPixel posx posy x y rect &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;let&lt;/span&gt; x0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posx &lt;span class="op"&gt;+&lt;/span&gt; offX rect&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; x1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posx &lt;span class="op"&gt;+&lt;/span&gt; offX rect &lt;span class="op"&gt;+&lt;/span&gt; rectX rect&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posy &lt;span class="op"&gt;+&lt;/span&gt; offY rect&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posy &lt;span class="op"&gt;+&lt;/span&gt; offY rect &lt;span class="op"&gt;+&lt;/span&gt; rectY rect&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;in&lt;/span&gt; (x0 &lt;span class="op"&gt;+&lt;/span&gt; margin) &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; x &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; x &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; (x1 &lt;span class="op"&gt;-&lt;/span&gt; margin) &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; (y0 &lt;span class="op"&gt;+&lt;/span&gt; margin) &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; y &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; y &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; (y1 &lt;span class="op"&gt;-&lt;/span&gt; margin)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;How do you verify that the margin is pretty enough? Simply generate a naive Layout function. We just lay out shapes left-to-right.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;linearLayout ::&lt;/span&gt; [ &lt;span class="dt"&gt;Wrapping&lt;/span&gt; ] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;linearLayout wrappings &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; List.zipWith (\w (x,y) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; x y w) wrappings xys&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; xys ::&lt;/span&gt; [(&lt;span class="dt"&gt;X&lt;/span&gt;,&lt;span class="dt"&gt;Y&lt;/span&gt;)]&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; xys &lt;span class="ot"&gt;=&lt;/span&gt; List.scanl placeToTheLeft (&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;) wrappings &lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; placeToTheLeft ::&lt;/span&gt; (&lt;span class="dt"&gt;X&lt;/span&gt;, &lt;span class="dt"&gt;Y&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="dt"&gt;X&lt;/span&gt;, &lt;span class="dt"&gt;Y&lt;/span&gt;)&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; placeToTheLeft (x,y) w &lt;span class="ot"&gt;=&lt;/span&gt; (x &lt;span class="op"&gt;+&lt;/span&gt; extentX w, &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The interesting aspect is the use of &lt;code&gt;List.scanl&lt;/code&gt; to perform a fold an accumulate intermediary values. The accumulator is the position for the next &lt;code&gt;Wrapping&lt;/code&gt; (hence, we start at &lt;code&gt;(0,0)&lt;/code&gt; and then we move right by an amount large enough to ensure there will be no overlap: what we named the &lt;em&gt;extent&lt;/em&gt; of the wrapping shape.&lt;/p&gt; &lt;p&gt;This function does not even take care of the bounds of the roll. This function is merely useful to have some comparison point and to exercise the &lt;code&gt;printLayout&lt;/code&gt; function.&lt;/p&gt; &lt;p&gt;Running the following command will give the image below.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-console"&gt;$ santa-wrap linear-layout ./layout.png &amp;lt; input/wrapping003.json done! &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;img src="images/linear-layout.png" alt="img" /&gt;&lt;/p&gt; &lt;p&gt;Now we see the margins, the coloring. We also have a MiniZinc model for non-naive layouts. Let’s bring the two things together.&lt;/p&gt; &lt;h3 id="actually-bridge-the-haskell-and-minizinc-code"&gt;Actually bridge the Haskell and MiniZinc code&lt;/h3&gt; &lt;p&gt;Showcasing my &lt;code&gt;minizinc-process&lt;/code&gt; library is, a main motivator (second to saving Christmas’ spirit, though).&lt;/p&gt; &lt;p&gt;Remember that, we want to approach ergonomics for the solver so that in Haskell-land it feels like we have a function &lt;code&gt;solver :: Model -&amp;gt; Parameters -&amp;gt; Maybe Decisions&lt;/code&gt;. Here enters &lt;code&gt;minizinc-process&lt;/code&gt;, an helper library that actually uses MiniZinc support for JSON input/outputs. This is feasible with &lt;code&gt;runLastMinizincJSON&lt;/code&gt;, which has type:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;runLastMinizincJSON ::&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; (&lt;span class="dt"&gt;ToJSON&lt;/span&gt; input, &lt;span class="dt"&gt;FromJSON&lt;/span&gt; answer) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;MiniZinc&lt;/span&gt; input answer &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; input &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;Maybe&lt;/span&gt; answer)&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;runLastMinizincJSON &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The typeclass constraints on &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; allow to serialize back and forth using JSON. The &lt;code&gt;Minizinc input answer&lt;/code&gt; actually contains the model (e.g., a filepath to the &lt;code&gt;models/santa-wrap.mzn&lt;/code&gt; file) and parameters for driving MiniZinc (i.e., which solver to use, whether there is a timeout or to search forever, but also, how to create intermediary &lt;code&gt;.json&lt;/code&gt; input files that play the role of the &lt;code&gt;models/santa-wrap001.dzn&lt;/code&gt; for each different possible input). For this project, we use the &lt;code&gt;simpleMiniZinc&lt;/code&gt; constructor to get a &lt;code&gt;Minizinc&lt;/code&gt;that also adds some &lt;code&gt;Hashable&lt;/code&gt; constraint on the input type so that we can generate filenames. Fortunately, &lt;code&gt;Hashable&lt;/code&gt; is generically-derivable as well so little boilerplate is incured.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;runLastMinizincJSON&lt;/code&gt; functions runs for up to the timeout provided in the MiniZinc option and return the latest decisions (if there is any). A more general function &lt;code&gt;runMinizincJSON&lt;/code&gt; exists. This function takes a state-machine named &lt;code&gt;ResultHandler&lt;/code&gt; to handle individual results. Indeed, we can ask MiniZinc to return multiple solutions, prove that there are no more solutions, and handling this variety of cases asks for more complicated types.&lt;/p&gt; &lt;p&gt;The underlying type are:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;SearchState&lt;/span&gt; a&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Exhausted&lt;/span&gt; a&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Incomplete&lt;/span&gt; a&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Unsatisfiable&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;InternalError&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;ResultHandler&lt;/span&gt; obj b&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ResultHandler&lt;/span&gt;&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; {&lt;span class="ot"&gt; handleNext ::&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;SearchState&lt;/span&gt; obj &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (b, &lt;span class="dt"&gt;Maybe&lt;/span&gt; (&lt;span class="dt"&gt;ResultHandler&lt;/span&gt; obj b))&lt;/span&gt; &lt;span id="10"&gt;&lt;a href="#10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The result handler is parametrized by &lt;code&gt;obj&lt;/code&gt; which are the decisions that the solver makes, and the handler is also parametrized by &lt;code&gt;b&lt;/code&gt; – an accumulator state like in a fold. A handler is called each time the search changes SearchState. The handler is free to do what it wants but must return an updated state and an updated handler (or an absence of handler to tell the library that we can stop the search). Later versions of the library will likely generalize IO in the handler to some parametric class.&lt;/p&gt; &lt;p&gt;There is not much more to &lt;code&gt;minizinc-process&lt;/code&gt;. Let’s use it in practice.&lt;/p&gt; &lt;p&gt;We need to translate two worldviews for the same information, back and forth. MiniZinc expects data in array shapes and other parameters giving the length of these arrays whereas our Haskell data is meant to help interactions with users. Hence, the Haskell datatypes closely follow Elf-semantics. Typically, translation code between two worldviews benefits from careful newtypes to distinguish array indices. Indeed, every entity becomes identified by an index and it is all too common to make an error. Multi-dimensional arrays have some support for types in MiniZinc but the data serialized in JSON do not.&lt;/p&gt; &lt;p&gt;The risk we want to reduce is to mix-up array indices and mix-up the terminology. This is where newtypes shine in Haskell. Two extensions, &lt;code&gt;DerivingStrategies&lt;/code&gt; and &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; come handy to save on boilerplate.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; stock &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; stock &lt;span class="dt"&gt;Eq&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Hashable&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; stock &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Hashable&lt;/span&gt;&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;We can now write an Haskell data type for the input. This data type has fields mapping closely the names of &lt;code&gt;par&lt;/code&gt; variables in MiniZinc (which you find declared in the &lt;code&gt;./models/santa-wrap001.dzn&lt;/code&gt;). Arrays map to lists, two dimensional arrays become nested lists. Sets required me to define an indirection named &lt;code&gt;MinizincSet&lt;/code&gt; (will be merged upstream) to match MiniZinc expectations for its JSON inputs. Thus, my Input and Output types become.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt; {&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; nBlocks ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rect_sizes ::&lt;/span&gt; [[&lt;span class="dt"&gt;Int&lt;/span&gt;]]&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rect_offs ::&lt;/span&gt; [[&lt;span class="dt"&gt;Int&lt;/span&gt;]]&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; nShapes ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; shapes ::&lt;/span&gt; [ &lt;span class="dt"&gt;MinizincSet&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; ]&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; nObjs ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; object_shapes ::&lt;/span&gt; [ &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; ]&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; x_max ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="10"&gt;&lt;a href="#10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; y_max ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="11"&gt;&lt;a href="#11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="12"&gt;&lt;a href="#12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Hashable&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt;&lt;/span&gt; &lt;span id="13"&gt;&lt;a href="#13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt;&lt;/span&gt; &lt;span id="14"&gt;&lt;a href="#14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="15"&gt;&lt;a href="#15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt; {&lt;/span&gt; &lt;span id="16"&gt;&lt;a href="#16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; coordinates ::&lt;/span&gt; [ (&lt;span class="dt"&gt;X&lt;/span&gt;, &lt;span class="dt"&gt;Y&lt;/span&gt;) ]&lt;/span&gt; &lt;span id="17"&gt;&lt;a href="#17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; }&lt;/span&gt; &lt;span id="18"&gt;&lt;a href="#18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="19"&gt;&lt;a href="#19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The rest of the work now requires to build a &lt;code&gt;convertInput&lt;/code&gt; function that takes Haskell domain values, map that into an Input. This mapping will require to give integral IDs to entities. For instance, each individual &lt;code&gt;Wrapping&lt;/code&gt; in the input requires as many &lt;code&gt;OBJECT&lt;/code&gt; as the &lt;code&gt;quantity&lt;/code&gt; requires. I typically use list-comprehensions and zipping with &lt;code&gt;[1..]&lt;/code&gt; to achieve this indexing.&lt;/p&gt; &lt;p&gt;For instance, each &lt;code&gt;Wrapping&lt;/code&gt; has one &lt;code&gt;SHAPE&lt;/code&gt; in our problem. Thus, we provide an indexed list of shapes and its “originating” &lt;code&gt;Wrapping&lt;/code&gt; as follows.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;indexedWrappings ::&lt;/span&gt; [(&lt;span class="dt"&gt;ShapeIdx&lt;/span&gt;, &lt;span class="dt"&gt;Wrapping&lt;/span&gt;)]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;indexedWrappings &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;zip&lt;/span&gt; (&lt;span class="fu"&gt;fmap&lt;/span&gt; &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;]) wrappings&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;BLOCK&lt;/code&gt; and their &lt;code&gt;rect_sizes, rect_offs&lt;/code&gt; are a bit more complicated. To build everything we want, we need a “table” with, for each SHAPE, what BLOCK it is made of, and the “originating” &lt;code&gt;Rectangle&lt;/code&gt; to get carry the sizes and offsets.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;indexedRects ::&lt;/span&gt; [(&lt;span class="dt"&gt;ShapeIdx&lt;/span&gt;, &lt;span class="dt"&gt;BlockIdx&lt;/span&gt;, &lt;span class="dt"&gt;Rectangle&lt;/span&gt;)]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;indexedRects &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;zipWith&lt;/span&gt; (\blockIdx (shapeIdx, r) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (shapeIdx, blockIdx, r))&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; (&lt;span class="fu"&gt;fmap&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; [ &lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt; ])&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; [ (shapeIdx, r) &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx,w) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedWrappings, r &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; rectangles w ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;We can then compute the number of &lt;code&gt;BLOCK&lt;/code&gt;, which is &lt;code&gt;nBlocks = length indexedRects&lt;/code&gt;. An optimization could have been to share equal blocks when shared across &lt;code&gt;SHAPEs&lt;/code&gt; (i.e., when a same &lt;code&gt;Rectangle&lt;/code&gt; appears in two &lt;code&gt;Wrappings&lt;/code&gt;). Let’s not suffer from early optimization.&lt;/p&gt; &lt;p&gt;We can now build the &lt;code&gt;rect_sizes&lt;/code&gt; and &lt;code&gt;rect_offs&lt;/code&gt; of each &lt;code&gt;BLOCK&lt;/code&gt; by directly looking at the values associated in the “originating” &lt;code&gt;Rectangle&lt;/code&gt;.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rect_sizes &lt;span class="ot"&gt;=&lt;/span&gt; [ [rectX r, rectY r] &lt;span class="op"&gt;|&lt;/span&gt; (_,_,r) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedRects ]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rect_offs &lt;span class="ot"&gt;=&lt;/span&gt; [ [offX r, offY r] &lt;span class="op"&gt;|&lt;/span&gt; (_,_,r) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedRects ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;and the relational information “which SHAPE contains which BLOCK” is a reading of the ‘join’ of the &lt;code&gt;indexedRects&lt;/code&gt; and the &lt;code&gt;indexedWrappings&lt;/code&gt; tables. Again, we use comprehension-lists to the cardinal product of the two tables (and collecting that in &lt;code&gt;MinzincSet&lt;/code&gt;).&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;shapes &lt;span class="ot"&gt;=&lt;/span&gt; [ &lt;span class="dt"&gt;MinizincSet&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; [ blockIdx &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx2,blockIdx,_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedRects&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; , shapeIdx1 &lt;span class="op"&gt;==&lt;/span&gt; shapeIdx2&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ]&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx1,_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedWrappings&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Performance could become a concern for large amount of &lt;code&gt;Wrapping&lt;/code&gt; and large amount of &lt;code&gt;Rectangle&lt;/code&gt;. However, again, we are not chasing seconds in serialization/translation code as we are ready to spend minutes of solver-time to saves hours to our Elves. If data proves this piece of code is the bottleneck in practice, we can then try to optimize further this type of code. Since the code is pure, it is really amenable to property testing under QuickCheck or HedgeHog: for any data, both the (slow)-reference and (putatively-optimized)-candidate functions are returning equal outputs.&lt;/p&gt; &lt;p&gt;Finally, our MiniZinc model wants &lt;code&gt;OBJECT&lt;/code&gt;, one per present rather than one per Wrapping objects (the Haskell data model holds a quantity). I mistakenly did two things at a time: expanding quantities and associating a Shape to each Wrapping. &lt;code&gt;flattenedWrappings&lt;/code&gt; in the heat to release something early for our Elves.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;flattenedWrappings ::&lt;/span&gt; [(&lt;span class="dt"&gt;ShapeIdx&lt;/span&gt;, &lt;span class="dt"&gt;Wrapping&lt;/span&gt;)]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;flattenedWrappings &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;mconcat&lt;/span&gt; [ &lt;span class="fu"&gt;replicate&lt;/span&gt; (quantity w) (shapeIdx, w) &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx, w) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedWrappings ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;This code means that if we have &lt;code&gt;Wrapping { name = abc , quantity = 2 }&lt;/code&gt; and &lt;code&gt;Wrapping {name = def, quantity = 5}&lt;/code&gt; then we have to lay out seven &lt;code&gt;OBJECT&lt;/code&gt;, two of &lt;code&gt;SHAPE&lt;/code&gt; associated to &lt;code&gt;abc&lt;/code&gt; and five of &lt;code&gt;SHAPE&lt;/code&gt; associated to &lt;code&gt;def&lt;/code&gt;. The corresponding boilerplate is:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;nObjs &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;length&lt;/span&gt; flattenedWrappings&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;object_shapes &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;fmap&lt;/span&gt; &lt;span class="fu"&gt;fst&lt;/span&gt; flattenedWrappings&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;I think this covers most of the boiler-plate. Extra function arguments are the size of the roll&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;x_max &lt;span class="ot"&gt;=&lt;/span&gt; sizeX&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;y_max &lt;span class="ot"&gt;=&lt;/span&gt; sizeY&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;It is tempting to just write the “forward translation code” and call it a day. In reality, if you were a consumer of such a library, you would like to minimize this horrendous boiler plate, and you still need some “reverse translation code”. Be kind to your users. You have done a lot of work to create “indexed” arrays once, you’d rather not duplicate this code. Even if you do not duplicate the code, having colocated everything within the constraints of a pure function will guarantee you that no non-determinism creeps in. Hence, you should make a “reverse translation function” at the same time as you translate forward. Bonus: you can guarantee that calls of unsafe functions (like array indexing) actually are safe because you are writing the providing and consuming dynamically-shaped data at the same place.&lt;/p&gt; &lt;p&gt;Indeed, because we have access to &lt;code&gt;flattenedWrappings&lt;/code&gt; our “reverse translation code” is a single line.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;layoutOutput ::&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;layoutOutput (&lt;span class="dt"&gt;Output&lt;/span&gt; coords) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;zipWith&lt;/span&gt; (\w (x,y) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; x y w) [w &lt;span class="op"&gt;|&lt;/span&gt; (_,w) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; flattenedWrappings] coords&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Writing all this boilerplate takes time (hence why I circled it red at the beginning in my dependency graph for the tasks in this project). Such translation code would be hard to generate in the general case. Hence I do not have very good solutions but to be careful and use &lt;code&gt;newtype&lt;/code&gt; for each index. The good news, however, is that it is pretty easy to debug: generate simple cases with one then two &lt;code&gt;Wrapping&lt;/code&gt;, observe the generated &lt;code&gt;.json&lt;/code&gt; file.&lt;/p&gt; &lt;p&gt;At last we can be gratified. A simple &lt;code&gt;main&lt;/code&gt; that ressembles the one for &lt;code&gt;linearLayout&lt;/code&gt; allows us to generate layouts for given roll sizes.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-console"&gt;$ santa-wrap minizinc-layout ./layout-190x150.png 190 150 &amp;lt; input/wrapping003.json done! $ santa-wrap minizinc-layout ./layout-170x160.png 170 160 &amp;lt; input/wrapping003.json done! $ santa-wrap minizinc-layout ./layout-170x159.png 170 159 &amp;lt; input/wrapping003.json no layout found! &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The first command greets us with the following picture &lt;img src="./images/layout-190x150.png" alt="img" /&gt;. We can try shrinking the Y-coordinates, 160 is still good, but 159 is too hard (note: it is actually infeasible but the &lt;code&gt;runLastMinizincJSON&lt;/code&gt; function makes no distinctions between timeout and unfeasible). Visual inspection of the Y=160 case seems to show that the two cross-shaped and the big rectangle are the main reasons to limit the roll size &lt;img src="./images/layout-190x150.png" alt="img" /&gt;.&lt;/p&gt; &lt;p&gt;Convince yourself with this picture (done by modifying the input JSON to delete everything but the &lt;em&gt;shoes&lt;/em&gt; and the &lt;em&gt;sword&lt;/em&gt; entries: &lt;img src="./images/layout-restricted.png" alt="img" /&gt;.&lt;/p&gt; &lt;p&gt;OK, with this &lt;code&gt;santa-wrap&lt;/code&gt; tool, Elves are in good shape to save Christmas’ spirit. Thank you MiniZinc and Haskell!&lt;/p&gt; &lt;p&gt;For the fun try packing that yourselves (input is &lt;code&gt;input/wrapping005.json&lt;/code&gt;) &lt;img src="images/layout-robot-200x240.png" alt="img" /&gt;&lt;/p&gt; &lt;h2 id="discussion"&gt;Discussion&lt;/h2&gt; &lt;p&gt;Given more times, a number of possible improvements could happen. For a work project more discussions with the Elves would help adding more constraints to the Model. We next discuss some possible “improvements”.&lt;/p&gt; &lt;h3 id="possible-improvements"&gt;Possible improvements&lt;/h3&gt; &lt;p&gt;Elves have deadlines too, although they would love to keep improving their tools, they have other important (albeit slightly more mundane) tasks at their day jobs. Besides the discussion about Positioned being an interesting abstraction, I want to discuss improvements to the solver/problem itself and illustrate how business ideas are generated/pruned with such discussions.&lt;/p&gt; &lt;p&gt;A user may suggest improvements to the tool, but not all improvements are equally easy to introduce. Here are a few options:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;easy: reduce some cost (material spent) ; you would need to change the satisfyability into some optimiziation trying to minimize the area bounded by maximum X-Y coordinates &lt;/li&gt; &lt;li&gt;medium: pick an orientation (left-right vs. up-down) ; you would need to change Input, Output, and the model to tell which shapes an object can take, but &lt;code&gt;geost&lt;/code&gt; already takes care of that &lt;/li&gt; &lt;li&gt;hard: attribute multiple rolls at once ; you would need to change Input, Output, and the model to pass a number rolls (maybe to each one their size) and modify the MiniZinc model to decide a roll for each object; you’d generate two pictures per problem &lt;/li&gt; &lt;li&gt;crazy-hard: time taken to cut with cissors ; you would need to significantly alter the model to express the notion of “gaps” or “external”. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;In a typical setup I would propose to deliver the easy and medium improvements before calling the tool done. I would suggest to propose the hard improvement as more data is generated to understand if Elves actually would benefit from such changes. I would root against the crazy hard, and even propose to equip Elves with cutting-tools and drop cissors would probably use total surface as a good enough proxy, simulators can help assess how bad.&lt;/p&gt; &lt;p&gt;Elves would love to hear about your improvement suggestions or merge requests! Feel free to contact me or to open some Issues to discuss them together.&lt;/p&gt; &lt;h3 id="epilogue"&gt;Epilogue&lt;/h3&gt; &lt;p&gt;Alright, this blog post was longer than I expected. I wanted to show how Haskell can be used to solve a very practical problem and also put onto words some “tactical thinking” to avoid losing time on the less-important aspects (the one I have not circled red in my dependency diagram). My main challenge was to time-box my work to one day of code: on top of my Elvish missions I have a day job and all-in-all this is a good constraint to simulate a real-world situation. The information I had before starting: I knew &lt;code&gt;JuicyPixels&lt;/code&gt; existed but had never used it before, I sort of framed the Santa-Wrap problem to illustrate a non-trivial MiniZinc global (&lt;code&gt;geost_bb&lt;/code&gt; arguably is pretty advanced). I built the &lt;code&gt;minizinc-process&lt;/code&gt; library and wanted a pretext to show-case it. I could have taken a shortcut as &lt;code&gt;minizinc-process&lt;/code&gt; offers some TemplateHaskell to generate &lt;code&gt;Input&lt;/code&gt; and &lt;code&gt;Output&lt;/code&gt; datatypes (with no newtypes and no support for sets, the pedagogy would have suffered).&lt;/p&gt; &lt;p&gt;An advantage of the Haskell + MiniZinc combination is to be able to use each tool for what they are best at. Haskell allows me to write solid backend services and command line tools whereas MiniZinc allows me to model using MiniZinc IDE (e.g., with a nice syntax for multi-dimensional arrays). In this setup the key difficulty is the boilerplate code required to translate inputs and outputs.&lt;/p&gt; &lt;p&gt;I hope this article piqued your interest. Feel free to contact me if you are curious whether these types of techniques are a good fit for you. I gave a presentation of MiniZinc at an online event this year, and you will find much more on the website and on the Coursera lessons (time consuming).&lt;/p&gt; &lt;p&gt;Thanks to Advent of Haskell organizers and all the other articles authors.&lt;/p&gt; &lt;p&gt;I wish you all the best for the end of 2020 and cheers to a better 2021!&lt;/p&gt; &lt;p&gt;Oh oh oh!&lt;/p&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/santa-wrap.html" rel="alternate"/>
        <summary type="text">
            We help Santa Elves optimize cutting wrapping paper to accomodate various shapes. The difficult optimization requires a dedicated solver in MiniZinc. Haskell allows to integrate with MiniZinc, reads JSON and outputs a PNG image with the footprint of the positionned shapes to cut. This article shows that a one-day-of-work project can reach pretty far.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/talks.html
        </id>
        <title type="text">
            Talks and Docs
        </title>
        <updated>
            1970-01-01T00:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;I am a bit more quiet now that I have a daughter and now that the pandemic started devastating the world but I’ve done quite a few presentations in the past. I will probably blog more in the future. In addition I’ve added a link of document templates that you may find useful.&lt;/p&gt; &lt;p&gt;If you feel interested in some &lt;a href="/hashtags/talks.html"&gt;&lt;span class="hashtag" data-hashtag="talks"&gt;#talks&lt;/span&gt;&lt;/a&gt; becoming articles (or, on the opposite and article becoming a talk), please enquire.&lt;/p&gt; &lt;/section&gt;&lt;section class="main-section"&gt;&lt;h2 id="haskell-and-functional-programming"&gt;Haskell and Functional Programming&lt;/h2&gt; &lt;p&gt;Most of my talks spree was while actively learning and applying Haskell to real-world problems (in a sense I still do but not in a professional context).&lt;/p&gt; &lt;h3 id="the-haskell-pyramid"&gt;The Haskell Pyramid&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A recurring talk I gave (and other people did as well) to explain why Haskell seems so mystic to bystanders. It sort of diffused and has inspired a few people to detail what further better than I would.&lt;/p&gt; &lt;p&gt;&lt;em&gt;gist&lt;/em&gt; You can be productive in Haskell with ‘simple haskell’, but no-one is discussing ‘simple haskell’ on the social networks.&lt;/p&gt; &lt;p&gt;&lt;em&gt;related&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;em&gt;not affiliated&lt;/em&gt; &lt;a href="https://www.reddit.com/r/haskell/comments/gwkn79/question_regarding_the_haskell_pyramid/"&gt;A reddit post asking what is the base of the pyramid&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;em&gt;not affiliated&lt;/em&gt; a proposition of a &lt;a href="https://nicksanford.io/posts/haskell-pyramid/"&gt;Haskell pyramid&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;em&gt;not affiliated&lt;/em&gt; a proposition for &lt;a href="https://gilmi.me/blog/post/2021/03/16/bottom-haskell-pyramid"&gt;the bottom of the Haskell pyramid&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1bSANLVcGnfVIFjicj81Uo_MYQhsF0FZi_EF-NEKFecE/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="functional-is-a-direction"&gt;Functional is a direction&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;gist:&lt;/em&gt; If you plot the programming languages on an X/Y graph with &lt;code&gt;X&lt;/code&gt; as the quality of the local reasoning and &lt;code&gt;Y&lt;/code&gt; the level of formalism you use. You’ll notice that languages tend to appear and move to the upper-right direction &lt;span class="emoji" data-emoji="arrow_upper_right"&gt;↗️&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1VkRkSgI6PTRli8j8SR0cASJEOLz8zUhMaV3Z9ItsMYE/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="haskell-teachings-applied-to-architecture"&gt;Haskell teachings applied to architecture&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; I am a software architect and I’ve designed pretty big systems. Haskell’s closeness to mathematical abstractions are useful to think. For instance, the duality between &lt;code&gt;sum-types&lt;/code&gt; and &lt;code&gt;product-types&lt;/code&gt; is a &lt;strong&gt;duality&lt;/strong&gt; you will find between &lt;code&gt;producers&lt;/code&gt; and &lt;code&gt;consumers&lt;/code&gt; services in large companies.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1HinBAMjkL5qNSRku8XntAhkniRbelLHQcwLyUyPr2X8/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="prodapi"&gt;ProdAPI&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; Slides showing how ProdAPI modularizes a service application like in web-service architectures.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1xpvw8bFWhA4mw4JJVc6ywYimU7O50oQ-exApyHyzmrw/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/lucasdicioccio/prodapi"&gt;github&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="grpc-native"&gt;gRPC native&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A talk I gave to introduce my gRPC library during Zurihac2020.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1MS7TxkpnSsorzbgg25boSZzOZr9iwPpXVh2Bcygb5JU/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/haskell-grpc-native"&gt;github&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="http2-client"&gt;http2-client&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A talk I gave to introduce my http2-client library at a Haskell-Paris Meetup.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1qD9Q2zrSMf0MsP4siWlbr7n7V78vZUggmZMtdv7Qu1U/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/lucasdicioccio/http2-client"&gt;github&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="composing-web-apis-with-servant"&gt;Composing Web APIs with Servant&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A talk I gave to introduce the amazing Servant library to write web-API and clients at a While42-London. It’s a bit lengthy as it tries to share my concept of ‘composition’. That said, the visualizations/animations of how to match ‘types together’ in a Servant API can be helpful. I guess most of the content is still up to date (early 2022) because the Servant concept are rock solid.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/110Xl7ZVKWEipc6jRbkIFye2Htp1VEJ-DAjRFK_s6Frg/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="an-introduction-to-functional-programming"&gt;An introduction to functional programming&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A talk I gave at Veepee to explain FP basics. I got plenty of appraisal from colleagues at the time, so I guess it is a decently-good starting material to get a feeling of things like &lt;strong&gt;immutability&lt;/strong&gt; , &lt;strong&gt;map&lt;/strong&gt; and &lt;strong&gt;fold&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1R5ODUBOtCxIbLBD_0xUG3prHQ6-OLyAEMwWVCIp5YxE/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="les-monades-en-comptant-sur-ses-doigts"&gt;Les monades en comptant sur ses doigts&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A monad-tutorial I gave at at Haskell-Paris meetup. Only the title of this talk is in French.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1qAcG-zfxQKH0EmYzl5MVj0Z_BAWbuRrbMsQI6L67jPc/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h2 id="minizinc-and-constraint-programming"&gt;MiniZinc and Constraint-Programming&lt;/h2&gt; &lt;p&gt;I have fallen in love with modeling and optimizing engineering (but not only) problems. You will likely see Alloy-content pop up at some point as well. &lt;a href="/hashtags/optimization.html"&gt;&lt;span class="hashtag" data-hashtag="optimization"&gt;#optimization&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id="constraint-programming-with-minizinc"&gt;Constraint-Programming with MiniZinc&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; A constraint-programming introduction I gave for VPTech. We also solve the cabbage-goat-wolf problem in MiniZinc.&lt;/p&gt; &lt;p&gt;&lt;em&gt;related&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;em&gt;not affiliated&lt;/em&gt; &lt;a href="https://www.sasnauskas.eu/solving-river-crossing-puzzles-with-minizinc/"&gt;solving river crossing puzzles&lt;/a&gt; , my talk inspired Raimondas Sasnauskas to write down the solution to the cabbage-goat-wolf problem I used towards the later parts of the talk. His article is a good tutorial. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1Ze7jR6VbFNxLcvVYz9xmDfWKfXbgjUXpsH98doDB0lE/edit?usp=sharing"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=kiX1FOw1GUU"&gt;youtube recording&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h2 id="architecture-and-site-reliability-engineering"&gt;Architecture and Site-Reliability Engineering&lt;/h2&gt; &lt;p&gt;I was an &lt;a href="/hashtags/SRE.html"&gt;&lt;span class="hashtag" data-hashtag="SRE"&gt;#SRE&lt;/span&gt;&lt;/a&gt; in one of the most hectic team at Google. Add this my especially-bad luck and one could say I’ve handled quite a lot of incidents. Then I’ve been an Architect in a pretty large company with a lot of complex business processes, a good amount of old and poorly-understood code where challenges abund.&lt;/p&gt; &lt;h3 id="aborder-la-production-comme-un-sre-fr"&gt;Aborder la production comme un SRE &lt;span class="emoji" data-emoji="fr"&gt;🇫🇷&lt;/span&gt;&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;&lt;em&gt;summary&lt;/em&gt; Trying to convey what the SRE approach is. When I gave this talk, few people were interested in the term SRE. In France we alas mostly renamed Devops but here in this &lt;strong&gt;recording in French&lt;/strong&gt; I explain what the SRE approach and mindset is in the place I’ve experienced it.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/presentation/d/1sG5635YGkczUxwqNm1d7CsOPIzBaMQdjgpuVlS6kMG0/edit#slide=id.g1e386fa4fb_0_0"&gt;google slides&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=lSqyeckTLl8"&gt;youtube recording&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="post-mortem-template"&gt;Post-Mortem Template&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;A good post-mortem takes time to write but it’s a goldmine of information. I’ve written this template after a request from a friend who had trouble going past the ‘incident report’ that was only scratching the surface. So I wrote a template of Post-Mortem with some text of a pseudo story of things that went wrong.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/document/d/1c48bRufHkWmSTUZv6RJuDQJOFXLRuV_TRZTX28XLCh4/edit?usp=sharing"&gt;google doc&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="design-doc-template"&gt;Design-Doc Template&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;A template of Design-Doc. A number of sections may be superfluous depending on how fast. But what is key (besides motivating the problem you are trying to solve) is to properly define the axes of analysis from the proper solution-analysis.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://docs.google.com/document/d/1roAP7yafVq_ZwO7F66Q5T_gS_ZElWf3aYBPHooJkmU0/edit#"&gt;google doc&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h3 id="vacat-page-template"&gt;Vacat Page Template&lt;/h3&gt; &lt;div class="talk"&gt; &lt;p&gt;A Vacat Page is a page intentionally left blank. Good vacat pages are hard to find. I’ve taken the freedom to plagiarize a vacat page from a book I paid 90euros.&lt;/p&gt; &lt;p&gt;&lt;em&gt;links&lt;/em&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="/page-intentionally-left-blank.html"&gt;vacat page template&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt;&lt;section class="main-section"&gt;&lt;script type="text/javascript"&gt; (function(){ const xs = [... document.getElementsByTagName("h3")]; xs.forEach((x) =&gt; { const title = x.innerHTML ?? 'about your blog'; const subject = `About your blog: ${title}`; const elt = document.createElement("a"); elt.innerHTML = " 📧"; elt.setAttribute("class", "enquire-link") elt.setAttribute("href", `mailto:lucas@dicioccio.fr?subject=${subject}`); x.appendChild(elt); }); })() &lt;/script&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/talks.html" rel="alternate"/>
        <summary type="text">
            A list of slides (with recording links when available) for presentations I gave. Also some template documents for architecture/devops.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/readings.html
        </id>
        <title type="text">
            Reading List
        </title>
        <updated>
            1970-01-01T00:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;h1 id="haskell-garbage-collection"&gt;Haskell Garbage Collection&lt;/h1&gt; &lt;p&gt;Functional programming used to have a bad reputation of being slow mostly due to garbage-collection. The Haskell garbage-collector (GC) actually has received some care and a number of options or programming constructs allow to reduce GC pause times.&lt;/p&gt; &lt;h2 id="theory"&gt;Theory&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/gen-gc-for-haskell.pdf"&gt;Generational GC For Haskell&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://simonmar.github.io/posts/2015-07-28-optimising-garbage-collection-overhead-in-sigma.html"&gt;Optimising GC Overhead&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://simonmar.github.io/bib/exploringbarrier04_abstract.html"&gt;Incremental GC&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://wiki.haskell.org/GHC/Memory_Management"&gt;GHC Memory management&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://www.well-typed.com/blog/2018/05/ghc-special-gc-objects/"&gt;GHC Special Objects&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2 id="hands-on-optimization"&gt;Hands-On Optimization&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/"&gt;Writing Fast Haskell&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://chrisdone.com/posts/fast-haskell-c-parsing-xml#the-dom-speed"&gt;Fast XML parser&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/haskell-perf/checklist"&gt;Performance Checklist&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2 id="real-world-reports"&gt;Real-World Reports&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://www.reddit.com/r/haskell/comments/13cpm3/waiting_for_garbage_collection_can_kill/"&gt;Parallelism and GC&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://www.reddit.com/r/haskell/comments/5g8nd0/golangs_realtime_gc_in_theory_and_practice_from/"&gt;Pushers moving away from Haskell to Go for GC reasons&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://www.reddit.com/r/haskell/comments/1kcce9/haskell_is_not_real_time_ready_yet/"&gt;Is Haskell real-time ready yet?&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h1 id="systems"&gt;Systems&lt;/h1&gt; &lt;p&gt;There always is a host of interesting things to learn by studying complicated systems.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="http://aosabook.org/en/index.html"&gt;The Architecture of Open Source Applications&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="http://www.redbook.io/"&gt;Readings in db systems&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://cstack.github.io/db_tutorial/"&gt;How does a database work?&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h1 id="optimization"&gt;Optimization&lt;/h1&gt; &lt;p&gt;It’s a bit harder to find good blog-style material on &lt;a href="/hashtags/optimization.html"&gt;&lt;span class="hashtag" data-hashtag="optimization"&gt;#optimization&lt;/span&gt;&lt;/a&gt; topics. Besides &lt;a href="/topics/optimization.html"&gt;articles on this site&lt;/a&gt; here are some links.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://ocw.mit.edu/courses/institute-for-data-systems-and-society/ids-338j-multidisciplinary-system-design-optimization-spring-2010/index.htm?utm_source=OCWDept&amp;amp;utm_medium=CarouselSm&amp;amp;utm_campaign=FeaturedCourse"&gt;Multidisciplinary optimization&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://matthewcrews.com/blog/2020/12/2020-12-21/"&gt;Maximizing profitability of inventory&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h1 id="static-and-personal-site-technology"&gt;Static and personal site technology&lt;/h1&gt; &lt;p&gt;If you read &lt;a href="/how-this-blog-works.html"&gt;how this blog is built&lt;/a&gt;, you’ll figure out that I have some affection for personal and personalized websites. Thus I collect (do not hesitate to send yours to me) other viewpoints on how they built their website.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://j3s.sh/thought/my-website-is-one-binary.html"&gt;My Website is one binary&lt;/a&gt; by jes &lt;/li&gt; &lt;li&gt;XHTMLBoy’s &lt;a href="https://xhtmlboi.github.io/articles/yocaml.html"&gt;Website recipe&lt;/a&gt; &lt;/li&gt; &lt;li&gt;A list of &lt;a href="https://brainbaking.com/post/2022/04/cool-things-people-do-with-their-blogs/"&gt;Cool things people do with their blogs&lt;/a&gt; by Wouter Groeneveld &lt;/li&gt; &lt;/ul&gt; &lt;h1 id="misc"&gt;MISC&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://gist.github.com/lucasdicioccio/256f854a17320b13856b"&gt;gilded tulip&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/readings.html" rel="alternate"/>
        <summary type="text">
            A collection of links and readings.
        </summary>
    </entry>
</feed>
