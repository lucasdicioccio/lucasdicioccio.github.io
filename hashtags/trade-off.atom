<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title type="text">
        Lucas DiCioccio's blog
    </title>
    <id>
        https://dicioccio.fr/atom.xml
    </id>
    <updated>
        2022-05-03T01:00:00Z
    </updated>
    <entry>
        <id>
            https://dicioccio.fr/dhall-section-demo.html
        </id>
        <title type="text">
            Scripting subsets of page contents in Dhall.
        </title>
        <updated>
            2022-05-03T01:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;Since I‚Äôve started building my own blog engine, I wanted some limited &lt;a href="/hashtags/scripting.html"&gt;&lt;span class="hashtag" data-hashtag="scripting"&gt;#scripting&lt;/span&gt;&lt;/a&gt; capabilities in the text-processing engine. A specific case I had in mind was to generate some tables or listings for what you currently find on the &lt;a href="/readings.html"&gt;/readings.html&lt;/a&gt; or on the &lt;a href="/tips.html"&gt;/tips.html&lt;/a&gt; page. I would like something like &lt;a href="http://microformats.org/"&gt;Microformats&lt;/a&gt;, but tactically applied to individual articles, with little ceremony.&lt;/p&gt; &lt;p&gt;A more telling example could be a &lt;a href="/hashtags/photo.html"&gt;&lt;span class="hashtag" data-hashtag="photo"&gt;#photo&lt;/span&gt;&lt;/a&gt; gallery where we list a dozen of images. For each image you‚Äôd want a title, an URL, a preferred background color for the frame, maybe a caption etc. Hand-editing such galleries is a lot of work, and the extra ceremony to store less than 100 records in a DB is not worth it. There‚Äôs a gap to fill&lt;/p&gt; &lt;p&gt;This article demonstrates and discusses a PoC using the Dhall programming language as a specific step.&lt;/p&gt; &lt;h2 id="high-level-need"&gt;high-level need&lt;/h2&gt; &lt;p&gt;What is common in the type of pages where I would like some minimal templating is:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;I want to reference and organize a moderately large amount of items. &lt;/li&gt; &lt;li&gt;items within a collection have a common structure (e.g., a link to a page would have a title, an URL, some language, and some description from myself). &lt;/li&gt; &lt;li&gt;I want to present, ideally with some mechanical template to keep the styling/HTML-structure consistent. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Thus I have &lt;strong&gt;three distinct characteristics to carve out&lt;/strong&gt;:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;ol&gt; &lt;li&gt;define the structure of items &lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;&lt;ol start="2"&gt; &lt;li&gt;list a collection of items &lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;&lt;ol start="3"&gt; &lt;li&gt;implement some template I use to present these &lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Separating 1. and 2. is a matter of getting some type and some syntax to write values. Separating 3. requires a novel feature in my blog-engine: to interpret some structure into some HTML chunk to embed in a longer article. Current generators only produce targets as fully-contained output objects (that then must be embedded via other HTML primitives like &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags).&lt;/p&gt; &lt;h2 id="mini-design"&gt;mini design&lt;/h2&gt; &lt;p&gt;Let‚Äôs go through my design process. This is a retroactive recount of the process I took rather than an upfront design-doc.&lt;/p&gt; &lt;h3 id="current-situation"&gt;current situation&lt;/h3&gt; &lt;p&gt;Absent a proper solution for this need, I so far hand-write all these pages. A downside is that I need to carefully write CommonMark if I want to apply some CSS uniformly. More annoying is if I want to add a non-trivial and verbose annotations (e.g., adding a &lt;code&gt;mailto:&lt;/code&gt; link). This process is &lt;em&gt;fastidious&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;I do not want to trade fastidiousness for significant extra complexity. Indeed, in these tasks there is a risk to end up for a similarly-fastidious process involving more moving bits‚Ä¶ What I want to avoid is:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;a. having a separate database, connectors, and section capable of reading the database at production-time &lt;/li&gt; &lt;li&gt;b. writing data structures in the Haskell-side of the blog-engine, including templates just for each type of listing &lt;/li&gt; &lt;li&gt;c. writing some JS that fetches a JSON-list and render only in the client &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Adding a database (a.) is the latest thing I would like to do because of all the deployment and extra changes required. I know this time will come if I want to do things like comments, but let me push it further. At this point, even SQLite would be too much overhead to add schemas, populate data etc.&lt;/p&gt; &lt;p&gt;Writing Haskell-code (b.) and would be fine regarding the structure definition, however I do not like to ‚Äúsplit‚Äù an article between multiple sources. A reason why I wrote a blog-engine was to avoid distractions while focusing on writing an article.&lt;/p&gt; &lt;p&gt;Of the three, I think that writing all the logic client-side (c.) probably would be the least intrusive to my writing flow. However, clients that do not support JavaScript would miss the content. I‚Äôm fine with JavaScript when it is &lt;em&gt;required&lt;/em&gt; or when it is a &lt;em&gt;nice to have&lt;/em&gt;. Usage of JS for just laying-out the meaty-content is something I frown upon.&lt;/p&gt; &lt;p&gt;Summarizing, I was searching for some way to embed logic that would return some HTML provided some type locally-defined and locally-filled in an article document.&lt;/p&gt; &lt;h3 id="filling-in-the-gap"&gt;filling in the gap&lt;/h3&gt; &lt;p&gt;To fill the gap, there are a two key decisions to make:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;a. what scripting language(s) to support? &lt;/li&gt; &lt;li&gt;b. at which point of the computation pipeline should I incorporate this engine? &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For the first question (a), I want some minimal and non-trivial language. I do not want to invest much time on the particular choice because I want to try different things rather than do some proper analysis to answer the second (b) question. Indeed, if the cost for demonstrating (a) happens to be small, then I get a pretty good starting point to answer or try &lt;a href="/hashtags/trade-off.html"&gt;&lt;span class="hashtag" data-hashtag="trade-off"&gt;#trade-off&lt;/span&gt;&lt;/a&gt; in (b).&lt;/p&gt; &lt;p&gt;Working on the &lt;a href="/halogen-demo.html"&gt;Halogen demo article&lt;/a&gt; I was reminded about &lt;a href="https://dhall-lang.org/"&gt;Dhall&lt;/a&gt; as an improved YAML/JavaScript for configuration. Configurations are very similar to Microformats, so why no try Dhall first?&lt;/p&gt; &lt;p&gt;Rather than providing a lengthy discussion, I‚Äôll leave only bullet points around pro/cons (note that I realize that these bullet points for pro/cons could themselves become microformats).&lt;/p&gt; &lt;h4 id="advantages"&gt;Advantages&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;incorporating Dhall is a full demonstration of how scripted evaluations (I want some opaque IO returning some CommonMark) &lt;/li&gt; &lt;li&gt;still a first stone in some more advanced form of pipeline/build-system &lt;/li&gt; &lt;li&gt;Dhall has the ability to import libraries with little package management pain, I could use this to re-use parts across articles, it‚Äôs a good nice to have &lt;/li&gt; &lt;li&gt;interoperability between Dhall and Haskell is a bliss (the &lt;a href="https://twitter.com/GabriellaG439"&gt;Dhall author&lt;/a&gt; is a &lt;a href="https://www.haskellforall.com/"&gt;prolific Haskell engineer&lt;/a&gt;) &lt;/li&gt; &lt;/ul&gt; &lt;h4 id="limitations"&gt;Limitations&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;so far, no extra environment is passed to the Dhall interpreter (the Dhall code does not know about its surroundings, article title or any other data &lt;span class="emoji" data-emoji="arrow_right"&gt;‚û°Ô∏è&lt;/span&gt; for later) &lt;/li&gt; &lt;li&gt;no dependency between sections are planned (need to do detection cycles or find other approaches &lt;span class="emoji" data-emoji="arrow_right"&gt;‚û°Ô∏è&lt;/span&gt; for later) &lt;/li&gt; &lt;/ul&gt; &lt;h4 id="drawbacks"&gt;Drawbacks&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;evaluating Dhall code costs extra time, CPUs, and file-descriptors (especially important while I care about automatic reloads of previews when editing articles) &lt;/li&gt; &lt;li&gt;intermediary results are opaque and hidden, if some final HTML is wrong, I need to know what has been generated as intermediary &lt;/li&gt; &lt;li&gt;risk of adding non-deterministic content generation (e.g., breaking because I‚Äôve no network, some hackers inserting duck picks or spam because the evaluator fetches from the Internet) &lt;/li&gt; &lt;/ul&gt; &lt;h4 id="summary"&gt;Summary&lt;/h4&gt; &lt;p&gt;Dhall still seems a darn-good choice. None of the drawbacks are fatal flaws and can be mitigated. The most dangerous in my opinion is the evaluation costs. I will likely mitigate it using some cacheing in the future. I need to keep in mind that there are two evaluation phases in my blog engine: one computing targets and another one rendering targets. Both have their trade-offs.&lt;/p&gt; &lt;p&gt;Non-determinism is heavily mitigated while sticking to Dhall, so I expect no big surprises. When adapting the pattern to other languages (e.g., if I ever want to run some python) then I will have to be more careful.&lt;/p&gt; &lt;h2 id="result"&gt;result&lt;/h2&gt; &lt;p&gt;I spent less than two hours, including family interruptions &lt;span class="emoji" data-emoji="baby"&gt;üë∂&lt;/span&gt; and babbling-around time. The implementation so far is extremely primitive, though.&lt;/p&gt; &lt;p&gt;I decided to interpret the Dhall code while loading the Site targets rather than while generating targets. As much as I wanted to avoid this option, it is the pragmatic choice: on the one hand, I interpret sections‚Äô Commonmark in different places (e.g., for rendering HTML but also when analyzing content or generating a JSON AST). On the other hand, cache control and idempotency is more obvious to control at this early phase: one execution of the script gives one website-worth of recipes.&lt;/p&gt; &lt;p&gt;Overall I had to do the following changes:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;add a new format (defining a new pattern, and parser pattern) in my section-files &lt;/li&gt; &lt;li&gt;import the Dhall package and runtime (it‚Äôs a Haskell library, nothing different from importing an HTTP-client here) &lt;/li&gt; &lt;li&gt;insert some case-switch on the section format in the code that loads an Article &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;And that‚Äôs all.&lt;/p&gt; &lt;p&gt;You can see for yourself in &lt;a href="/gen/out/dhall-section-demo.cmark__full-diff"&gt;the commit diff&lt;/a&gt; . And you can see this &lt;a href="/gen/out/dhall-section-demo.cmark__source-cmark"&gt;whole article source&lt;/a&gt; including the &lt;code&gt;dhall&lt;/code&gt; section.&lt;/p&gt; &lt;p&gt;Later, I added a local ‚Äúcache‚Äù of the Dhall prelude so that live-reloading my Dhall-code does not reload the Dhall prelude from the internet each time. Since Dhall supports cached import, the local cache requires little extra work: I just have this &lt;a href="/gen/out/dhall-section-demo.cmark__local-dhall-prelude-cache"&gt;file with a checksum-verified network import&lt;/a&gt;, which I then import as a filesystem-local import with &lt;code&gt;let prelude = ./dhall/Prelude.dhall&lt;/code&gt;.&lt;/p&gt; &lt;h3 id="future"&gt;future&lt;/h3&gt; &lt;p&gt;In the future, the Dhall object to return will be a beefier record rather than just a blob &lt;code&gt;List Text&lt;/code&gt;. For instance, we could return extra information as metadata or as extra instructions that do not find their way in the HTML. Also, the Dhall code could return something else than Commonmark, we could &lt;a href="https://github.com/andrewthad/dhall-html"&gt;directly generate HTML&lt;/a&gt; or JSON values.&lt;/p&gt; &lt;/section&gt;&lt;section class="main-section"&gt;&lt;div id="generated-section"&gt; &lt;p&gt;‚Äì‚Äì start of generated section ‚Äì‚Äì&lt;/p&gt; &lt;h1 id="this-section-is-generated"&gt;this section is generated&lt;/h1&gt; &lt;p&gt;This whole &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt; is interpreted from Dhall to Cmark to HTML. The content likely is the boundary at which point I enjoy having some templating mechanism over repeating the same thing many times. Indeed, if my data-type changes (adding columns) I need some help. Same if the template changes (adding fields, changing the markup).&lt;/p&gt; &lt;p&gt;In this example, I use two Dhall functions as two templates for a same dataset. Styling is then done in CSS.&lt;/p&gt; &lt;h2 id="table-layout"&gt;table layout&lt;/h2&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;author&lt;/th&gt; &lt;th&gt;note&lt;/th&gt; &lt;th&gt;website&lt;/th&gt; &lt;th&gt;personal comment&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Alice&lt;/td&gt; &lt;td&gt;7/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;secret santa barbara&lt;/a&gt;&lt;/td&gt; &lt;td&gt;good to learn about the city&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;8/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;sponge's den&lt;/a&gt;&lt;/td&gt; &lt;td&gt;other cartoons are funnier but okay&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Cindy&lt;/td&gt; &lt;td&gt;3/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;hello world I'm Cindy&lt;/a&gt;&lt;/td&gt; &lt;td&gt;abandonned site&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dave&lt;/td&gt; &lt;td&gt;9/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;blog of a developer&lt;/a&gt;&lt;/td&gt; &lt;td&gt;he sings so well&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Emil&lt;/td&gt; &lt;td&gt;2/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;eating some chewing gum&lt;/a&gt;&lt;/td&gt; &lt;td&gt;French movies...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Felicia&lt;/td&gt; &lt;td&gt;6/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;yet another a website&lt;/a&gt;&lt;/td&gt; &lt;td&gt;average&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Gerard&lt;/td&gt; &lt;td&gt;3/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;tech lead lead leader&lt;/a&gt;&lt;/td&gt; &lt;td&gt;lots of words to say nothing&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Hortense&lt;/td&gt; &lt;td&gt;8/10&lt;/td&gt; &lt;td&gt;&lt;a href=https://www.example.com&gt;lotta tasty recipes&lt;/a&gt;&lt;/td&gt; &lt;td&gt;miam miam&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;h2 id="tiles-layout"&gt;tiles layout&lt;/h2&gt; &lt;div class="tileset"&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Alice&lt;/span&gt; &lt;span class="note"&gt;7/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;secret santa barbara&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;good to learn about the city&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Bob&lt;/span&gt; &lt;span class="note"&gt;8/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;sponge's den&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;other cartoons are funnier but okay&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Cindy&lt;/span&gt; &lt;span class="note"&gt;3/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;hello world I'm Cindy&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;abandonned site&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Dave&lt;/span&gt; &lt;span class="note"&gt;&lt;i class="heart"/&gt;&amp;hearts;&lt;/i&gt;9/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;blog of a developer&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;he sings so well&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Emil&lt;/span&gt; &lt;span class="note"&gt;2/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;eating some chewing gum&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;French movies...&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Felicia&lt;/span&gt; &lt;span class="note"&gt;6/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;yet another a website&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;average&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Gerard&lt;/span&gt; &lt;span class="note"&gt;3/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;tech lead lead leader&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;lots of words to say nothing&lt;/div&gt; &lt;/div&gt; &lt;div class="tile" draggable="true"&gt; &lt;div class="heading"&gt; &lt;span class="name"&gt;Hortense&lt;/span&gt; &lt;span class="note"&gt;8/10&lt;/span&gt; &lt;/div&gt; &lt;div class="link"&gt;&lt;a href=https://www.example.com&gt;lotta tasty recipes&lt;/a&gt;&lt;/div&gt; &lt;div class="commnet"&gt;miam miam&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;‚Äì‚Äì end of generated section ‚Äì‚Äì&lt;/p&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/dhall-section-demo.html" rel="alternate"/>
        <summary type="text">
            A demo of using Dhall as an intermediary step for my blog-engine sections.
        </summary>
    </entry>
    <entry>
        <id>
            https://dicioccio.fr/santa-wrap.html
        </id>
        <title type="text">
            Advent of Haskell 2020: Santa Wrap
        </title>
        <updated>
            2020-12-24T12:00:00Z
        </updated>
        <author>
            <name>
                Lucas DiCioccio
            </name>
        </author>
        <content type="html">
            &lt;div class="main-article"&gt;&lt;section class="main-section"&gt;&lt;p&gt;This article is part of &lt;a href="https://adventofhaskell.com/"&gt;Advent of Haskell&lt;/a&gt; 2020 &lt;span class="emoji" data-emoji="christmas_tree"&gt;üéÑ&lt;/span&gt;. Make sure to check the other articles too! You will find the code for this blog-post at &lt;a href="https://github.com/lucasdicioccio/santa-wrap/"&gt;the original GitHub publication&lt;/a&gt;.&lt;/p&gt; &lt;h2 id="our-christmas-project"&gt;Our Christmas project&lt;/h2&gt; &lt;p&gt;Year 2020 is terrible. Santa‚Äôs Workshop had to take stay-at-home restrictions. However, Elves want to do the utmost to keep Christmas‚Äô spirit alive. This year, Elves will work from home rather than work in the streamlined workshop &lt;span class="emoji" data-emoji="factory"&gt;üè≠&lt;/span&gt; . They will get back to a more traditional way of preparing presents, like Elderly Elves who live more than 500 years, remember. In short, every Elf works in their own garage &lt;span class="emoji" data-emoji="house"&gt;üè†&lt;/span&gt;. They receive the Christmas wishlists of neighboring families: crafting toys &lt;span class="emoji" data-emoji="space_invader"&gt;üëæ&lt;/span&gt;, sewing clothes &lt;span class="emoji" data-emoji="shirt"&gt;üëï&lt;/span&gt;, or cooking delicious cookies &lt;span class="emoji" data-emoji="cookie"&gt;üç™&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;One particularly annoying task for work-from-home Elves, however, is to wrap presents &lt;span class="emoji" data-emoji="gift"&gt;üéÅ&lt;/span&gt;. They had avoided this task in the recent years thanks to automation. Elves all have different pieces of wrapping-paper at home, in particular wrapping-paper rolls vary in ratio and vary in size from one Elf to another one. Elves want some software to help them cut wrapping-paper for the presents they prepare &lt;span class="emoji" data-emoji="scissors"&gt;‚úÇÔ∏è&lt;/span&gt;. Some Elves have tools to cut paper (think of a cookie-cutter, but for large sheets of paper), whereas others only have cissors. Wrapping may become scarce if used inefficiently, and anyway ordering takes time. Thus, they would like to have a rough idea of how to efficiently cut the paper rolls given their own specific constraints. It does not have to be perfect, but it cannot be completely naive either. Thus, Elves need some creative idea to save Christmas‚Äô spirit. For the better or for the worst Elves resorted to use software &lt;span class="emoji" data-emoji="computer"&gt;üíª&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Fortunately, an Elf has learnt Haskell, a language especially good for building small command line tools and with libraries to generate images. He also has learnt MiniZinc, a language especially good for solving this family of problems. Put together, these languages can help building a small tool that Elves can run at home with their own input. This computer-savvy Elf suggests the following &lt;a href="/hashtags/trade-off.html"&gt;&lt;span class="hashtag" data-hashtag="trade-off"&gt;#trade-off&lt;/span&gt;&lt;/a&gt;:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Elves will input the quantity and shape of the wrapping for the presents (or the shape of their cookie-cutter tools that fit for the present) &lt;/li&gt; &lt;li&gt;the shape of the wrapping is blocky, that is, made of various rectangle blocks, rather than arbitrarily shaped (it simplifies cutting and folding paper with rulers and guides anyway) &lt;/li&gt; &lt;li&gt;Elves will also input the size of their own paper sheets &lt;/li&gt; &lt;li&gt;the output is a footprint image of how to cut the paper to fit all present (when possible) Some Elves expected more specialized tools, some cared especially about saving wrapping paper. However, time is running out, our software Elf-ineer only has a day to build this software or it will be too late to save Christmas. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;I am not sure I should reveal this, but, I work in Santa Incorporated oh oh oh. Do not tell your kids! in exchange I‚Äôll explain you how I built &lt;code&gt;santa-wrap&lt;/code&gt; in a rush to help the Elf. Thus, the main goal for this article is to relate how to iterate quickly on a practical one short day project. Secondary goals are to pike your interest about MiniZinc and introduce you a library named &lt;code&gt;minizinc-process&lt;/code&gt;.&lt;/p&gt; &lt;h2 id="approach"&gt;Approach&lt;/h2&gt; &lt;p&gt;The type of problem for cutting wrapping paper is known as a Packing problem. These problems are generally difficult to solve efficiently. However, for small sizes or particular form of constraints, some solutions could be efficiently found (or the litterature may have some heuristics that work well empirically). Generally, the difficulty comes from integrality of constraints, that is you either can wrap a present or not wrap the present, you cannot wrap a fraction of a present. Such problems come up a lot in industrial settings where some resource is scarce. In this particular case, we cheated a bit as we came with an idea to write a blog post. However, with a bit of practice you will recognize packing problems everywhere.&lt;/p&gt; &lt;p&gt;We want to show off how to combine MiniZinc (a mathematical &lt;a href="/hashtags/optimization.html"&gt;&lt;span class="hashtag" data-hashtag="optimization"&gt;#optimization&lt;/span&gt;&lt;/a&gt; language and toolchain) with Haskell (which readers of this Advent of Haskell submission are familiar with). We will show the progression of a tool, with building a value-adding prototype in a day or two of work for some Elf familiar with Haskell and Minizinc.&lt;/p&gt; &lt;h2 id="motivating-our-iterations"&gt;Motivating our Iterations&lt;/h2&gt; &lt;p&gt;The author built this tool in four broad iterations: implement a demo solver in MiniZinc, generate simple pictures for each wrapping, introduce the concept of layout, and, bridge the solver. We motivate each iteration before jumping into lengthier explanations.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Implemeting a solver in MiniZinc&lt;/em&gt;: I wanted to leverage powerful global constraints with their own heuristics/optimized solutions that exist in MiniZinc. Such a model helps us formalize the problem in better terms and understand what are inputs and what are outputs. In a business settings, such prototypes allow to raise the important questions. In that case, the whole problem is solved with a single &lt;a href="https://www.minizinc.org/doc-2.3.0/en/lib-globals.html#packing-constraints"&gt;global contraint&lt;/a&gt; named &lt;code&gt;geost_bb&lt;/code&gt;. Knowing which constraints help modeling a problem is a type of expertise that takes time to acquire but that can change drastically the viability of such a tool.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Generate simple pictures&lt;/em&gt;: our tool needs to generate pictures of the wrapping, and I find a blog-post with picture more appealing than without. Visualizations illustrate the problem. I am not familiar with low-level graphics libraries. I typically use high-level tools for my charts like &lt;a href="https://ggplot2.tidyverse.org/"&gt;ggplot in R&lt;/a&gt; ‚Äì they typically get in the way if what you want is pixel-perfect position of image width/height. For this exercise, I found &lt;a href="https://hackage.haskell.org/package/JuicyPixels"&gt;JuicyPixels&lt;/a&gt; and I need to validate quickly that JuicyPixels will fit the needs. This library is appealing because I could generate PNGs with little dependencies. I had some experience with &lt;a href="https://hackage.haskell.org/package/gloss"&gt;Gloss&lt;/a&gt;. However, I discarded this choice for I only need static images and not animations (and Gloss has way more dependencies than JuicyPixels).&lt;/p&gt; &lt;p&gt;&lt;em&gt;Introduce the concept of layout&lt;/em&gt;: pictures become more interesting when we start to have multiple boxes. Once I know how to print a layout I am done with the graphical aspects of the problem. Minor improvements can still come later but it is mind-relaxing to call something done. Further, at this point it is easy to show some naive layouts.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Bridge the solver&lt;/em&gt;: this is the boiler-plate part of the work. &lt;code&gt;minizinc-process&lt;/code&gt; actually have a TemplateHaskell helper to generate an input and output representations but this approach is limited: it cannot work with sets in its current version and does not preclude writing boilerplate to transform between ‚Äúbusiness-domain‚Äù representations and solver input/output representations. Plus, the goal of the article is to illustrate the pro/cons. This part of boiler-plate is the one requiring the most care, hence my usage of newtypes to differentiate indices.&lt;/p&gt; &lt;p&gt;Graphically, the following dependency graph shows the various steps I had in mind. &lt;img src="images/deps.png" alt="img" /&gt; In red are the two chunks of work which I assessed has being the most uncertain (i.e., requiring the most discovery) or most meticulous (i.e., spending time building accurate types to reduce the risk of bugs).&lt;/p&gt; &lt;p&gt;Let‚Äôs discuss how this four iterations looked like.&lt;/p&gt; &lt;h2 id="the-four-iterations"&gt;The four iterations&lt;/h2&gt; &lt;p&gt;We now dive in more details into each iteration. Recall that I time-boxed this project to the equivalent of a short-day-of-work. Readers should be able to read these independently.&lt;/p&gt; &lt;h3 id="a-solver-in-minizinc"&gt;A solver in MiniZinc&lt;/h3&gt; &lt;p&gt;We basically call the &lt;em&gt;global contstraint&lt;/em&gt; &lt;code&gt;geost_bb&lt;/code&gt;. Let‚Äôs unpack how it works, starting from a small MiniZinc overview and a mini tutorial on &lt;code&gt;geost_bb&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;In &lt;a href="https://www.minizinc.org/"&gt;MiniZinc&lt;/a&gt; you separate the structure of a problem (which we call a model) and its particular instance (determined by input parameters). Thus a model can run for various input parameters. Further, the model separate two families of variables: the &lt;em&gt;par&lt;/em&gt; variables (parameters that are given or can be deterministically computed from other parameters) and &lt;em&gt;var&lt;/em&gt; variables (decisions that the solver will make). Constraints are statement that link variables together. The solver, then works out solutions (that is assignments of variables) that are consistent with all constraints. It is typically easy to verify that a given assignment matches all constraints. For instance, in our Santa-Wrap tool can visually inspect whether or not cutting guides for different present intersect. Whereas, it is typically hard to find a given assignment for all possible &lt;em&gt;par&lt;/em&gt; inputs (or an optimal one when a criteria of goodness exists).&lt;/p&gt; &lt;p&gt;In Haskell parlance: &lt;code&gt;solver :: Model -&amp;gt; Parameters -&amp;gt; Maybe Decisions&lt;/code&gt;, which, partially-applied for some &lt;code&gt;Model&lt;/code&gt; would give &lt;code&gt;solveProblem :: Parameters -&amp;gt; Maybe Decisions&lt;/code&gt;. To encode this faithfully in Haskell we would need to ensure that the &lt;code&gt;Parameters&lt;/code&gt; and &lt;code&gt;Decisions&lt;/code&gt; types actually depends on the &lt;code&gt;Model&lt;/code&gt;; somehow, discussing these type-level programming techniques is out of scope for this article.&lt;/p&gt; &lt;p&gt;Typically, writing MiniZinc is a bit like SQL queries: you describe what you want and let the engine fetch it for you. The ability to summon a magic tool to solve our wishes comes with some limitations: expressivity is limited, and you need to be careful what you wish for. For instance, when writing MiniZinc you need to discuss about finite inputs/outputs (e.g, no unbounded recursion). Further, small changes on the structure of the problem can drastically change performance (like switching from a index scan to a table scan in SQL query plan).&lt;/p&gt; &lt;p&gt;The comparison with SQL does not stops at the declarative aspect. Typical domain models in Haskell have collections such as &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List.html"&gt;Lists&lt;/a&gt; or &lt;a href="https://hackage.haskell.org/package/containers-0.6.4.1/docs/Data-Map.html"&gt;Maps&lt;/a&gt; or custom &lt;a href="http://www.cse.chalmers.se/edu/year/2018/course/TDA452/lectures/RecursiveDataTypes.html"&gt;recursively-shaped objects&lt;/a&gt; etc. Once mapped into tabular form in SQL, special conversion care is required. For instance, in Haskell, a type &lt;code&gt;User { age :: Int , height :: Int }&lt;/code&gt; would map to a set of integers (one user-id per user) and two arrays indexed by user-id. So that Haskell domain objects like these.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;users ::&lt;/span&gt; [ &lt;span class="dt"&gt;User&lt;/span&gt; ]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;users &lt;span class="ot"&gt;=&lt;/span&gt; [ &lt;span class="dt"&gt;User&lt;/span&gt; &lt;span class="dv"&gt;23&lt;/span&gt; &lt;span class="dv"&gt;172&lt;/span&gt;, &lt;span class="dt"&gt;User&lt;/span&gt; &lt;span class="dv"&gt;45&lt;/span&gt; &lt;span class="dv"&gt;180&lt;/span&gt;, &lt;span class="dt"&gt;User&lt;/span&gt; &lt;span class="dv"&gt;36&lt;/span&gt; &lt;span class="dv"&gt;165&lt;/span&gt; ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Would translate to the following MiniZinc.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;set of int: USER = 1..3; array[USER] of int: age = [ 23, 45, 36 ]; array[USER] of int: height = [ 172, 180, 165 ]; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Readers familiar with Relational Algebra, DataParallel Haskell, Columnar Storage, or Entity Component System will find comonalities. We will work this out for our problem in more detail in the last iteration. So now let‚Äôs look at &lt;code&gt;geost_bb&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Here is a snapshot of &lt;code&gt;geost_bb&lt;/code&gt; &lt;a href="https://www.minizinc.org/doc-2.5.0/en/lib-globals.html"&gt;documentation&lt;/a&gt; &lt;img src="images/geost-doc.png" alt="img" /&gt;. Which sorts of packs blocky-structure on a multi-dimensional space. This constraint does not try to shrink gaps between objects, it ‚Äúmerely‚Äù (I don‚Äôt want to downplay how great this is) force assignments of variables such that no overlap exists between the packed objects.&lt;/p&gt; &lt;p&gt;We annotate the parameters below to explain why using this function make sense in Santa-Wrap. Besides the opaque name, it does exactly what we want to help the Elves and even a bit more.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;em&gt;k&lt;/em&gt;: here we live in two dimensions, that an easy parameter, we‚Äôll hardcode it &lt;/li&gt; &lt;li&gt;&lt;em&gt;rect_size&lt;/em&gt;: size of each rectangles along each dimension &lt;/li&gt; &lt;li&gt;&lt;em&gt;rect_offset&lt;/em&gt;: offset of rectangles long each dimension &lt;/li&gt; &lt;li&gt;&lt;em&gt;shape&lt;/em&gt;: wrapping shapes are built from a set of a rectangles, for instance presents we can wrap in a simple rectangle would have a single rectangle. More elaborated wrapping shapes may require two or more adjacent rectangles. For instance the sword here is built with two overlapping rectangles: &lt;img src="images/sword.png" alt="img" /&gt; a rectangle is horizontal (largest &lt;em&gt;rect_size&lt;/em&gt; is the 1st dimension) and another rectangle is vertical (largest &lt;em&gt;rect_size&lt;/em&gt; is the 2nd dimension) and both rectangles are translated along an axis (i.e., one non-zero &lt;em&gt;rect_offset&lt;/em&gt;). Multiple shapes could re-use the same rectangles if they happen to match (hence, saving a bit on the complexity ‚Äì but we won‚Äôt go into this level of sophistication). &lt;/li&gt; &lt;li&gt;&lt;em&gt;l&lt;/em&gt; and &lt;em&gt;u&lt;/em&gt;: upper and lower bounds for each wrapping, in our case all objects can equally be positioned on the wrapping, hence the lower bound is 0 and the upper bound the size of the roll (minus one if you care about millimeters and took no margins of error at all in your measurements) &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Then &lt;code&gt;geost_bb&lt;/code&gt; then contributes constraints to tell the solver to make a number of decisions:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;x&lt;/code&gt;: the coordinates of the &lt;em&gt;wrapping shapes&lt;/em&gt; (which are themselves built of rectangular blocks). For our sword example, we need to add the &lt;code&gt;rect_offset&lt;/code&gt; to the &lt;code&gt;x&lt;/code&gt; coordinate of the shape to position a rectangle. &lt;/li&gt; &lt;li&gt;&lt;code&gt;kind&lt;/code&gt;: the shape used by each object. This mechanism allows &lt;code&gt;geost_bb&lt;/code&gt; to chose any shape for the different objects. External constraints actually prevent &lt;code&gt;geost_bb&lt;/code&gt; does not know how many times it must be using the wrapping-shape for a sword, and unconstrained the solver would rather prefer the simpler wrapping-shape for a book. This mechanism actually is a feature: the freedom to pick among shapes allows to model rotation of shapes, we will not use this for now. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;In our case, for a first version of the tool we do not need to make that many decisions: only &lt;code&gt;x&lt;/code&gt; above is required. Declaring all inputs to give to &lt;code&gt;geost_bb&lt;/code&gt; is required, however. We still need to actually declare our &lt;code&gt;par&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; variables.&lt;/p&gt; &lt;p&gt;We will have to discuss about a number of entities:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;two dimensions: &lt;code&gt;int: nDims = 2; set of int: DIM = 1..nDims&lt;/code&gt; &lt;/li&gt; &lt;li&gt;wrapping shapes: &lt;code&gt;int: nShapes; set of int: SHAPE = 1..nShapes&lt;/code&gt; &lt;/li&gt; &lt;li&gt;rectangular blocks: &lt;code&gt;int: nBlocks; set of int: BLOCK = 1..nBlocks&lt;/code&gt; &lt;/li&gt; &lt;li&gt;each object we need to wrap: &lt;code&gt;int: nObjs; set of int: OBJ = 1..nObjs&lt;/code&gt; &lt;/li&gt; &lt;li&gt;the roll: it is implicit that we cut one roll, so we do not need to declare anything &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Then, some characteristics of entities:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;the size of the roll: &lt;code&gt;int: x_max; int: y_max&lt;/code&gt; &lt;/li&gt; &lt;li&gt;the size of individual rectangular blocks and their offsets in each dimension: &lt;code&gt;array[BLOCK,DIM] of int: rect_sizes; array[BLOCK,DIM] of int: rect_offs&lt;/code&gt; &lt;/li&gt; &lt;li&gt;the coordinates of where to position cuts for our solution: &lt;code&gt;array[OBJ,DIM] of var int: coordinates&lt;/code&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Finally there is relational information linking various entities.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;to each object we associate a given shape (present1 is a Guitar, present2 is a book etc.): &lt;code&gt;array[OBJ] of SHAPE: object_shapes;&lt;/code&gt; &lt;/li&gt; &lt;li&gt;each shape is the collage of a set of rectangle, we could use various external representation to model the set of rectangles (e.g., an &lt;code&gt;array[SHAPE,RECTANGLE] of bool&lt;/code&gt; is isomorphic to an &lt;code&gt;array[SHAPE] of set of RECTANGLE&lt;/code&gt;) but we will stick to the &lt;code&gt;set&lt;/code&gt; representation that &lt;code&gt;geost_bb&lt;/code&gt; requires (using another input would require extra constraints to link input and &lt;code&gt;geost_bb&lt;/code&gt; representations) &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;All in all, the model is in &lt;code&gt;models/santa-wrap.mzn&lt;/code&gt; and an example input for it is &lt;code&gt;models/santa-wrap001.dzn&lt;/code&gt;. You can run it with &lt;code&gt;minizinc models/santa-wrap.mzn models/santa-wrap001.dzn&lt;/code&gt;. And the output I got was:&lt;/p&gt; &lt;pre&gt;&lt;code class="language-minizinc"&gt;coordinates = array2d(1..10, 1..2, [8, 0, 0, 6, 7, 0, 0, 5, 6, 0, 0, 4, 4, 0, 0, 2, 2, 0, 0, 0]); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Which you can read as ‚Äúfirst object‚Äù is a (8,0), the ‚Äúsecond object‚Äù is at (0,6) etc. Elves could work with such an output, however a visual display is better. Plus they want to prepare their cutting boards, build guides, or simply pass an eye-check that things are in the right place.&lt;/p&gt; &lt;h3 id="generate-simple-pictures"&gt;Generate simple pictures&lt;/h3&gt; &lt;p&gt;I have had little interest in graphics in the past. Thus I vaguely know some Haskell libraries exist like &lt;a href="https://hackage.haskell.org/package/diagrams"&gt;diagrams&lt;/a&gt;, &lt;code&gt;gloss&lt;/code&gt;, &lt;code&gt;JuicyPixels&lt;/code&gt;, or &lt;a href="https://hackage.haskell.org/package/reanimate"&gt;reanimate&lt;/a&gt;. For this project, I had to dive a bit more and actually pick some library. My choice settled on &lt;code&gt;JuicyPixel&lt;/code&gt; for two main reasons: on the first hand, this library has only a small amount of dependencies (especially system dependencies ‚Äì &lt;code&gt;gloss&lt;/code&gt; requires some OpenGL). On the other hand, the documentation was welcoming: I looked for &lt;code&gt;IO ()&lt;/code&gt; because I looked for some ‚Äúmain‚Äù or ‚Äúprint‚Äù equivalent. The first hit on the top module is &lt;code&gt;generateImage&lt;/code&gt;. No kidding, here is the screenshot to prove it: first hit &lt;img src="images/haddock-jp.png" alt="img" /&gt;.&lt;/p&gt; &lt;p&gt;The type information tells me the library actually scans every pixel one by one. It is very likely super inefficient. That said, the cost of optimizing the packing is the major bottleneck in this problem. Elves can wait a minute to save hours. A warming case that does not corroborate the claim that Haskell libraries are poorly documente. My first action was to verify that the example actually works.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-shell"&gt;cabal repl &amp;gt; import Code.Picture &amp;gt; let path = &amp;quot;images/background.png&amp;quot; &amp;gt; let pixelRenderer x y = PixelRGB8 (fromIntegral x) (fromIntegral y) &amp;gt; writePng path $ generateImage pixelRenderer 250 300 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;And voila! &lt;img src="images/background.png" alt="img" /&gt; thank you so much &lt;code&gt;JuicyPixels&lt;/code&gt;. It‚Äôs not ‚Äútoo good to be true‚Äù: the example works.&lt;/p&gt; &lt;p&gt;Having secured that I can generate PNG, what is left? we need to define some Haskell data types to map loosely with what I‚Äôve learnt is required in the MiniZinc optimization. However we‚Äôll be using Haskell records rather than columnar values. The idea here is to use these data types as main Haskell types for parsing a format that Elves are likely to know such as JSON. Further we want to allow Elves to pass extra information like quantities of each present they will wrap, colors and names for pictures before crafting the guides etc.&lt;/p&gt; &lt;p&gt;Some excerpt:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; {&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; name ::&lt;/span&gt; &lt;span class="dt"&gt;Name&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; colorNum ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; quantity ::&lt;/span&gt; &lt;span class="dt"&gt;Quantity&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rectangles ::&lt;/span&gt; [ &lt;span class="dt"&gt;Rectangle&lt;/span&gt; ]&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt;&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt; {&lt;/span&gt; &lt;span id="10"&gt;&lt;a href="#10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; rectX ::&lt;/span&gt; &lt;span class="dt"&gt;Length&lt;/span&gt;&lt;/span&gt; &lt;span id="11"&gt;&lt;a href="#11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rectY ::&lt;/span&gt; &lt;span class="dt"&gt;Length&lt;/span&gt;&lt;/span&gt; &lt;span id="12"&gt;&lt;a href="#12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; offX ::&lt;/span&gt; &lt;span class="dt"&gt;X&lt;/span&gt;&lt;/span&gt; &lt;span id="13"&gt;&lt;a href="#13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; offY ::&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt;&lt;/span&gt; &lt;span id="14"&gt;&lt;a href="#14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="15"&gt;&lt;a href="#15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Wrappings are built of Rectangles. Each Rectangle as length/width (lengths in both dimensions &lt;code&gt;rectX&lt;/code&gt;, &lt;code&gt;rectY&lt;/code&gt;) as well as some offset in both dimension. In addition, each Wrapping has a name, a quantity and some color to visualize more easily a layout. But before speaking about Layouts, what we can do is to generate pictures for each Wrapping. This way, Elves can calibrate the units and verify individual length.&lt;/p&gt; &lt;p&gt;I need to adapt the &lt;code&gt;JuicyPixels&lt;/code&gt; example I copy pasted to build a function &lt;code&gt;printWrapping :: Wrapping -&amp;gt; IO()&lt;/code&gt;. In short, it has a &lt;code&gt;Wrapping&lt;/code&gt; and its associated &lt;code&gt;Rectangles&lt;/code&gt; in scope and we need to implement &lt;code&gt;pixelRenderer&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;So I‚Äôll build utility functions &lt;code&gt;findRectangle x y&lt;/code&gt; which finds a rectangle with the right sizes and offset to contain the pixel &lt;code&gt;(x,y)&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;A single pixel and rectangle test is&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rectangleContainsPixel x y rect &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;let&lt;/span&gt; x0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offX rect&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; x1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offX rect &lt;span class="op"&gt;+&lt;/span&gt; rectX rect&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offY rect&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; offY rect &lt;span class="op"&gt;+&lt;/span&gt; rectY rect&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;in&lt;/span&gt; x0 &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; x &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; x &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; x1 &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; y0 &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; y &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; y &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; y1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Which checks for intervals in both X and Y. The &lt;code&gt;scale&lt;/code&gt; function just multiplies tenfold every magnitude (i.e., a dimension of 1 Length is shown with 10 pixel). With that utility function we can now test every rectangles: if some is found, we color the Pixel with some value, otherwise we use default background value.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;pixelRenderer x y &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;case&lt;/span&gt; findRectangle x y &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;PixelRGB8&lt;/span&gt; (&lt;span class="fu"&gt;fromIntegral&lt;/span&gt; x &lt;span class="ot"&gt;`mod`&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;) (&lt;span class="fu"&gt;fromIntegral&lt;/span&gt; y &lt;span class="ot"&gt;`mod`&lt;/span&gt; &lt;span class="dv"&gt;32&lt;/span&gt;) &lt;span class="dv"&gt;128&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Just&lt;/span&gt; idx &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; pixelColor idx&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;findRectangle x y &lt;span class="ot"&gt;=&lt;/span&gt; List.findIndex (rectangleContainsPixel x y) (rectangles wrapping)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;I use &lt;code&gt;List.findIndex&lt;/code&gt; so that on a hit i can also attribute some color (see &lt;code&gt;pixelColor :: Int -&amp;gt; PixelRGB8&lt;/code&gt; which defines a palette) and paint the rectangle in a different color.&lt;/p&gt; &lt;p&gt;Another utility function is needed to give &lt;code&gt;JuicyPixel&lt;/code&gt; the size of the picture to create. This size corresponds to the farthest point in the set of off-set rectangles &lt;code&gt;maxX = maximum (0 : [ rectX r + offX r | r &amp;lt;- rectangles wrapping ])&lt;/code&gt;, I named this value the &lt;code&gt;extentX&lt;/code&gt; of a &lt;code&gt;Wrapping&lt;/code&gt; in later commits. I use comprehension list notation. I add a 0 so that &lt;code&gt;maximum&lt;/code&gt; does not crash on an empty list.&lt;/p&gt; &lt;p&gt;Our &lt;code&gt;main&lt;/code&gt; function basically parses &lt;code&gt;stdin&lt;/code&gt; into some &lt;code&gt;[Wrapping]&lt;/code&gt; and &lt;code&gt;traverse&lt;/code&gt; this list with our PNG generator.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;mainParts &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; wrappings &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; eitherDecode&amp;#39; &lt;span class="op"&gt;@&lt;/span&gt;[&lt;span class="dt"&gt;Wrapping&lt;/span&gt;] &lt;span class="op"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="fu"&gt;getContents&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;case&lt;/span&gt; wrappings &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Left&lt;/span&gt; err &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;print&lt;/span&gt; err&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;Right&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; traverse_ printWrapping xs&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="fu"&gt;putStrLn&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;done!&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The parsing leverages the automatically-generated &lt;code&gt;instance FromJSON&lt;/code&gt; from &lt;code&gt;aeson&lt;/code&gt; (extension &lt;code&gt;DeriveGeneric&lt;/code&gt;). Note that we use &lt;code&gt;TypeApplications&lt;/code&gt; for the syntax &lt;code&gt;@[Wrapping]&lt;/code&gt; which explicitates what we are decoding from the content in &lt;code&gt;stdin&lt;/code&gt;, which also helps GHC provide less general error message when I change and break things.&lt;/p&gt; &lt;p&gt;This way, our main binary can generate individual images.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-console"&gt;$ santa-wrap parts &amp;lt; input/wrapping001.json $ done! &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The parts are individual &lt;code&gt;.png&lt;/code&gt; files as this listing shows: &lt;img src="images/parts.png" alt="img" /&gt;. Elves can use these parts to prepare some guides to later cut wrapping paper rapidly.&lt;/p&gt; &lt;p&gt;Now let‚Äôs finally introduce the concept of layout.&lt;/p&gt; &lt;h3 id="introduce-the-notion-of-layout"&gt;Introduce the notion of layout&lt;/h3&gt; &lt;p&gt;The layout is a collection of positioned wrappings. There‚Äôs an obvious Functor instance for Positioned. I could refactor Rectangle into a Positioned Rect. This way, a Layout is a &lt;code&gt;[ Positioned [ Positioned Rect ] ]&lt;/code&gt; and it is probably collapsable into a single list by translating the inner Positioned objects. Something like &lt;code&gt;flatten :: [ Positioned [ Positioned a ] ] -&amp;gt; [ Positioned a ]&lt;/code&gt; I feel tempted to actually dig in this direction. However, I‚Äôm far from done and the clock ticks. In short, I will save this for later and perform a good amount of copy-pasting.&lt;/p&gt; &lt;p&gt;The Haskell code is simply:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; {&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; posX ::&lt;/span&gt; &lt;span class="dt"&gt;X&lt;/span&gt; &lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; posY ::&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt; &lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; item ::&lt;/span&gt; a &lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Functor&lt;/span&gt;)&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt; {&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; positionedWrappings ::&lt;/span&gt; [ &lt;span class="dt"&gt;Positioned&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; ]&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;And now my &lt;code&gt;printLayout&lt;/code&gt; function has a very similar &lt;code&gt;pixelRenderer&lt;/code&gt;. Two distinctions though:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;to color a pixel you need to determines if a &lt;code&gt;Wrapping&lt;/code&gt; has a &lt;code&gt;Rectangle&lt;/code&gt; and the &lt;code&gt;Rectangles&lt;/code&gt; are translated by &lt;code&gt;posX&lt;/code&gt; and &lt;code&gt;posY&lt;/code&gt;. &lt;/li&gt; &lt;li&gt;we want to add a few pixels of &lt;code&gt;margin&lt;/code&gt; so that a series of adjacent squares do not appear like a long rectangle, this small margin will ease verifying layouts at a glance. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Hence, our &lt;code&gt;rectangleContainsPixel&lt;/code&gt; test takes all these things into account:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;rectangleContainsPixel ::&lt;/span&gt; &lt;span class="dt"&gt;X&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Rectangle&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rectangleContainsPixel posx posy x y rect &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;let&lt;/span&gt; x0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posx &lt;span class="op"&gt;+&lt;/span&gt; offX rect&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; x1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posx &lt;span class="op"&gt;+&lt;/span&gt; offX rect &lt;span class="op"&gt;+&lt;/span&gt; rectX rect&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y0 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posy &lt;span class="op"&gt;+&lt;/span&gt; offY rect&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; y1 &lt;span class="ot"&gt;=&lt;/span&gt; scale &lt;span class="op"&gt;$&lt;/span&gt; posy &lt;span class="op"&gt;+&lt;/span&gt; offY rect &lt;span class="op"&gt;+&lt;/span&gt; rectY rect&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;in&lt;/span&gt; (x0 &lt;span class="op"&gt;+&lt;/span&gt; margin) &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; x &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; x &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; (x1 &lt;span class="op"&gt;-&lt;/span&gt; margin) &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; (y0 &lt;span class="op"&gt;+&lt;/span&gt; margin) &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; y &lt;span class="op"&gt;&amp;amp;&amp;amp;&lt;/span&gt; y &lt;span class="op"&gt;&amp;lt;&lt;/span&gt; (y1 &lt;span class="op"&gt;-&lt;/span&gt; margin)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;How do you verify that the margin is pretty enough? Simply generate a naive Layout function. We just lay out shapes left-to-right.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;linearLayout ::&lt;/span&gt; [ &lt;span class="dt"&gt;Wrapping&lt;/span&gt; ] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;linearLayout wrappings &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; List.zipWith (\w (x,y) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; x y w) wrappings xys&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; xys ::&lt;/span&gt; [(&lt;span class="dt"&gt;X&lt;/span&gt;,&lt;span class="dt"&gt;Y&lt;/span&gt;)]&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; xys &lt;span class="ot"&gt;=&lt;/span&gt; List.scanl placeToTheLeft (&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;) wrappings &lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; placeToTheLeft ::&lt;/span&gt; (&lt;span class="dt"&gt;X&lt;/span&gt;, &lt;span class="dt"&gt;Y&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Wrapping&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="dt"&gt;X&lt;/span&gt;, &lt;span class="dt"&gt;Y&lt;/span&gt;)&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; placeToTheLeft (x,y) w &lt;span class="ot"&gt;=&lt;/span&gt; (x &lt;span class="op"&gt;+&lt;/span&gt; extentX w, &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The interesting aspect is the use of &lt;code&gt;List.scanl&lt;/code&gt; to perform a fold an accumulate intermediary values. The accumulator is the position for the next &lt;code&gt;Wrapping&lt;/code&gt; (hence, we start at &lt;code&gt;(0,0)&lt;/code&gt; and then we move right by an amount large enough to ensure there will be no overlap: what we named the &lt;em&gt;extent&lt;/em&gt; of the wrapping shape.&lt;/p&gt; &lt;p&gt;This function does not even take care of the bounds of the roll. This function is merely useful to have some comparison point and to exercise the &lt;code&gt;printLayout&lt;/code&gt; function.&lt;/p&gt; &lt;p&gt;Running the following command will give the image below.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-console"&gt;$ santa-wrap linear-layout ./layout.png &amp;lt; input/wrapping003.json done! &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;img src="images/linear-layout.png" alt="img" /&gt;&lt;/p&gt; &lt;p&gt;Now we see the margins, the coloring. We also have a MiniZinc model for non-naive layouts. Let‚Äôs bring the two things together.&lt;/p&gt; &lt;h3 id="actually-bridge-the-haskell-and-minizinc-code"&gt;Actually bridge the Haskell and MiniZinc code&lt;/h3&gt; &lt;p&gt;Showcasing my &lt;code&gt;minizinc-process&lt;/code&gt; library is, a main motivator (second to saving Christmas‚Äô spirit, though).&lt;/p&gt; &lt;p&gt;Remember that, we want to approach ergonomics for the solver so that in Haskell-land it feels like we have a function &lt;code&gt;solver :: Model -&amp;gt; Parameters -&amp;gt; Maybe Decisions&lt;/code&gt;. Here enters &lt;code&gt;minizinc-process&lt;/code&gt;, an helper library that actually uses MiniZinc support for JSON input/outputs. This is feasible with &lt;code&gt;runLastMinizincJSON&lt;/code&gt;, which has type:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;runLastMinizincJSON ::&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; (&lt;span class="dt"&gt;ToJSON&lt;/span&gt; input, &lt;span class="dt"&gt;FromJSON&lt;/span&gt; answer) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;MiniZinc&lt;/span&gt; input answer &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; input &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;Maybe&lt;/span&gt; answer)&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;runLastMinizincJSON &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The typeclass constraints on &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; allow to serialize back and forth using JSON. The &lt;code&gt;Minizinc input answer&lt;/code&gt; actually contains the model (e.g., a filepath to the &lt;code&gt;models/santa-wrap.mzn&lt;/code&gt; file) and parameters for driving MiniZinc (i.e., which solver to use, whether there is a timeout or to search forever, but also, how to create intermediary &lt;code&gt;.json&lt;/code&gt; input files that play the role of the &lt;code&gt;models/santa-wrap001.dzn&lt;/code&gt; for each different possible input). For this project, we use the &lt;code&gt;simpleMiniZinc&lt;/code&gt; constructor to get a &lt;code&gt;Minizinc&lt;/code&gt;that also adds some &lt;code&gt;Hashable&lt;/code&gt; constraint on the input type so that we can generate filenames. Fortunately, &lt;code&gt;Hashable&lt;/code&gt; is generically-derivable as well so little boilerplate is incured.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;runLastMinizincJSON&lt;/code&gt; functions runs for up to the timeout provided in the MiniZinc option and return the latest decisions (if there is any). A more general function &lt;code&gt;runMinizincJSON&lt;/code&gt; exists. This function takes a state-machine named &lt;code&gt;ResultHandler&lt;/code&gt; to handle individual results. Indeed, we can ask MiniZinc to return multiple solutions, prove that there are no more solutions, and handling this variety of cases asks for more complicated types.&lt;/p&gt; &lt;p&gt;The underlying type are:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;SearchState&lt;/span&gt; a&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Exhausted&lt;/span&gt; a&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Incomplete&lt;/span&gt; a&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Unsatisfiable&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;InternalError&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;ResultHandler&lt;/span&gt; obj b&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ResultHandler&lt;/span&gt;&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; {&lt;span class="ot"&gt; handleNext ::&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;SearchState&lt;/span&gt; obj &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (b, &lt;span class="dt"&gt;Maybe&lt;/span&gt; (&lt;span class="dt"&gt;ResultHandler&lt;/span&gt; obj b))&lt;/span&gt; &lt;span id="10"&gt;&lt;a href="#10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The result handler is parametrized by &lt;code&gt;obj&lt;/code&gt; which are the decisions that the solver makes, and the handler is also parametrized by &lt;code&gt;b&lt;/code&gt; ‚Äì an accumulator state like in a fold. A handler is called each time the search changes SearchState. The handler is free to do what it wants but must return an updated state and an updated handler (or an absence of handler to tell the library that we can stop the search). Later versions of the library will likely generalize IO in the handler to some parametric class.&lt;/p&gt; &lt;p&gt;There is not much more to &lt;code&gt;minizinc-process&lt;/code&gt;. Let‚Äôs use it in practice.&lt;/p&gt; &lt;p&gt;We need to translate two worldviews for the same information, back and forth. MiniZinc expects data in array shapes and other parameters giving the length of these arrays whereas our Haskell data is meant to help interactions with users. Hence, the Haskell datatypes closely follow Elf-semantics. Typically, translation code between two worldviews benefits from careful newtypes to distinguish array indices. Indeed, every entity becomes identified by an index and it is all too common to make an error. Multi-dimensional arrays have some support for types in MiniZinc but the data serialized in JSON do not.&lt;/p&gt; &lt;p&gt;The risk we want to reduce is to mix-up array indices and mix-up the terminology. This is where newtypes shine in Haskell. Two extensions, &lt;code&gt;DerivingStrategies&lt;/code&gt; and &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; come handy to save on boilerplate.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; stock &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; stock &lt;span class="dt"&gt;Eq&lt;/span&gt;&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Hashable&lt;/span&gt;&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; stock &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Hashable&lt;/span&gt;&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;We can now write an Haskell data type for the input. This data type has fields mapping closely the names of &lt;code&gt;par&lt;/code&gt; variables in MiniZinc (which you find declared in the &lt;code&gt;./models/santa-wrap001.dzn&lt;/code&gt;). Arrays map to lists, two dimensional arrays become nested lists. Sets required me to define an indirection named &lt;code&gt;MinizincSet&lt;/code&gt; (will be merged upstream) to match MiniZinc expectations for its JSON inputs. Thus, my Input and Output types become.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt; {&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; nBlocks ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rect_sizes ::&lt;/span&gt; [[&lt;span class="dt"&gt;Int&lt;/span&gt;]]&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; rect_offs ::&lt;/span&gt; [[&lt;span class="dt"&gt;Int&lt;/span&gt;]]&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; nShapes ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; shapes ::&lt;/span&gt; [ &lt;span class="dt"&gt;MinizincSet&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; ]&lt;/span&gt; &lt;span id="7"&gt;&lt;a href="#7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; nObjs ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="8"&gt;&lt;a href="#8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; object_shapes ::&lt;/span&gt; [ &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; ]&lt;/span&gt; &lt;span id="9"&gt;&lt;a href="#9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; x_max ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="10"&gt;&lt;a href="#10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ,&lt;span class="ot"&gt; y_max ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span id="11"&gt;&lt;a href="#11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="12"&gt;&lt;a href="#12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Hashable&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt;&lt;/span&gt; &lt;span id="13"&gt;&lt;a href="#13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt; &lt;span class="dt"&gt;Input&lt;/span&gt;&lt;/span&gt; &lt;span id="14"&gt;&lt;a href="#14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt; &lt;span id="15"&gt;&lt;a href="#15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt; {&lt;/span&gt; &lt;span id="16"&gt;&lt;a href="#16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt; coordinates ::&lt;/span&gt; [ (&lt;span class="dt"&gt;X&lt;/span&gt;, &lt;span class="dt"&gt;Y&lt;/span&gt;) ]&lt;/span&gt; &lt;span id="17"&gt;&lt;a href="#17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; }&lt;/span&gt; &lt;span id="18"&gt;&lt;a href="#18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/span&gt; &lt;span id="19"&gt;&lt;a href="#19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The rest of the work now requires to build a &lt;code&gt;convertInput&lt;/code&gt; function that takes Haskell domain values, map that into an Input. This mapping will require to give integral IDs to entities. For instance, each individual &lt;code&gt;Wrapping&lt;/code&gt; in the input requires as many &lt;code&gt;OBJECT&lt;/code&gt; as the &lt;code&gt;quantity&lt;/code&gt; requires. I typically use list-comprehensions and zipping with &lt;code&gt;[1..]&lt;/code&gt; to achieve this indexing.&lt;/p&gt; &lt;p&gt;For instance, each &lt;code&gt;Wrapping&lt;/code&gt; has one &lt;code&gt;SHAPE&lt;/code&gt; in our problem. Thus, we provide an indexed list of shapes and its ‚Äúoriginating‚Äù &lt;code&gt;Wrapping&lt;/code&gt; as follows.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;indexedWrappings ::&lt;/span&gt; [(&lt;span class="dt"&gt;ShapeIdx&lt;/span&gt;, &lt;span class="dt"&gt;Wrapping&lt;/span&gt;)]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;indexedWrappings &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;zip&lt;/span&gt; (&lt;span class="fu"&gt;fmap&lt;/span&gt; &lt;span class="dt"&gt;ShapeIdx&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;]) wrappings&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;BLOCK&lt;/code&gt; and their &lt;code&gt;rect_sizes, rect_offs&lt;/code&gt; are a bit more complicated. To build everything we want, we need a ‚Äútable‚Äù with, for each SHAPE, what BLOCK it is made of, and the ‚Äúoriginating‚Äù &lt;code&gt;Rectangle&lt;/code&gt; to get carry the sizes and offsets.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;indexedRects ::&lt;/span&gt; [(&lt;span class="dt"&gt;ShapeIdx&lt;/span&gt;, &lt;span class="dt"&gt;BlockIdx&lt;/span&gt;, &lt;span class="dt"&gt;Rectangle&lt;/span&gt;)]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;indexedRects &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;zipWith&lt;/span&gt; (\blockIdx (shapeIdx, r) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (shapeIdx, blockIdx, r))&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; (&lt;span class="fu"&gt;fmap&lt;/span&gt; &lt;span class="dt"&gt;BlockIdx&lt;/span&gt; [ &lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt; ])&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; [ (shapeIdx, r) &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx,w) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedWrappings, r &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; rectangles w ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;We can then compute the number of &lt;code&gt;BLOCK&lt;/code&gt;, which is &lt;code&gt;nBlocks = length indexedRects&lt;/code&gt;. An optimization could have been to share equal blocks when shared across &lt;code&gt;SHAPEs&lt;/code&gt; (i.e., when a same &lt;code&gt;Rectangle&lt;/code&gt; appears in two &lt;code&gt;Wrappings&lt;/code&gt;). Let‚Äôs not suffer from early optimization.&lt;/p&gt; &lt;p&gt;We can now build the &lt;code&gt;rect_sizes&lt;/code&gt; and &lt;code&gt;rect_offs&lt;/code&gt; of each &lt;code&gt;BLOCK&lt;/code&gt; by directly looking at the values associated in the ‚Äúoriginating‚Äù &lt;code&gt;Rectangle&lt;/code&gt;.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rect_sizes &lt;span class="ot"&gt;=&lt;/span&gt; [ [rectX r, rectY r] &lt;span class="op"&gt;|&lt;/span&gt; (_,_,r) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedRects ]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rect_offs &lt;span class="ot"&gt;=&lt;/span&gt; [ [offX r, offY r] &lt;span class="op"&gt;|&lt;/span&gt; (_,_,r) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedRects ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;and the relational information ‚Äúwhich SHAPE contains which BLOCK‚Äù is a reading of the ‚Äòjoin‚Äô of the &lt;code&gt;indexedRects&lt;/code&gt; and the &lt;code&gt;indexedWrappings&lt;/code&gt; tables. Again, we use comprehension-lists to the cardinal product of the two tables (and collecting that in &lt;code&gt;MinzincSet&lt;/code&gt;).&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;shapes &lt;span class="ot"&gt;=&lt;/span&gt; [ &lt;span class="dt"&gt;MinizincSet&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; [ blockIdx &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx2,blockIdx,_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedRects&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; , shapeIdx1 &lt;span class="op"&gt;==&lt;/span&gt; shapeIdx2&lt;/span&gt; &lt;span id="4"&gt;&lt;a href="#4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ]&lt;/span&gt; &lt;span id="5"&gt;&lt;a href="#5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx1,_) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedWrappings&lt;/span&gt; &lt;span id="6"&gt;&lt;a href="#6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Performance could become a concern for large amount of &lt;code&gt;Wrapping&lt;/code&gt; and large amount of &lt;code&gt;Rectangle&lt;/code&gt;. However, again, we are not chasing seconds in serialization/translation code as we are ready to spend minutes of solver-time to saves hours to our Elves. If data proves this piece of code is the bottleneck in practice, we can then try to optimize further this type of code. Since the code is pure, it is really amenable to property testing under QuickCheck or HedgeHog: for any data, both the (slow)-reference and (putatively-optimized)-candidate functions are returning equal outputs.&lt;/p&gt; &lt;p&gt;Finally, our MiniZinc model wants &lt;code&gt;OBJECT&lt;/code&gt;, one per present rather than one per Wrapping objects (the Haskell data model holds a quantity). I mistakenly did two things at a time: expanding quantities and associating a Shape to each Wrapping. &lt;code&gt;flattenedWrappings&lt;/code&gt; in the heat to release something early for our Elves.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;flattenedWrappings ::&lt;/span&gt; [(&lt;span class="dt"&gt;ShapeIdx&lt;/span&gt;, &lt;span class="dt"&gt;Wrapping&lt;/span&gt;)]&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;flattenedWrappings &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;mconcat&lt;/span&gt; [ &lt;span class="fu"&gt;replicate&lt;/span&gt; (quantity w) (shapeIdx, w) &lt;span class="op"&gt;|&lt;/span&gt; (shapeIdx, w) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; indexedWrappings ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;This code means that if we have &lt;code&gt;Wrapping { name = abc , quantity = 2 }&lt;/code&gt; and &lt;code&gt;Wrapping {name = def, quantity = 5}&lt;/code&gt; then we have to lay out seven &lt;code&gt;OBJECT&lt;/code&gt;, two of &lt;code&gt;SHAPE&lt;/code&gt; associated to &lt;code&gt;abc&lt;/code&gt; and five of &lt;code&gt;SHAPE&lt;/code&gt; associated to &lt;code&gt;def&lt;/code&gt;. The corresponding boilerplate is:&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;nObjs &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;length&lt;/span&gt; flattenedWrappings&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;object_shapes &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;fmap&lt;/span&gt; &lt;span class="fu"&gt;fst&lt;/span&gt; flattenedWrappings&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;I think this covers most of the boiler-plate. Extra function arguments are the size of the roll&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;x_max &lt;span class="ot"&gt;=&lt;/span&gt; sizeX&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;y_max &lt;span class="ot"&gt;=&lt;/span&gt; sizeY&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;It is tempting to just write the ‚Äúforward translation code‚Äù and call it a day. In reality, if you were a consumer of such a library, you would like to minimize this horrendous boiler plate, and you still need some ‚Äúreverse translation code‚Äù. Be kind to your users. You have done a lot of work to create ‚Äúindexed‚Äù arrays once, you‚Äôd rather not duplicate this code. Even if you do not duplicate the code, having colocated everything within the constraints of a pure function will guarantee you that no non-determinism creeps in. Hence, you should make a ‚Äúreverse translation function‚Äù at the same time as you translate forward. Bonus: you can guarantee that calls of unsafe functions (like array indexing) actually are safe because you are writing the providing and consuming dynamically-shaped data at the same place.&lt;/p&gt; &lt;p&gt;Indeed, because we have access to &lt;code&gt;flattenedWrappings&lt;/code&gt; our ‚Äúreverse translation code‚Äù is a single line.&lt;/p&gt; &lt;div class="code code--highlighted"&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode"&gt;&lt;code class="sourceCode"&gt;&lt;span id="1"&gt;&lt;a href="#1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;layoutOutput ::&lt;/span&gt; &lt;span class="dt"&gt;Output&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt;&lt;/span&gt; &lt;span id="2"&gt;&lt;a href="#2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;layoutOutput (&lt;span class="dt"&gt;Output&lt;/span&gt; coords) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Layout&lt;/span&gt;&lt;/span&gt; &lt;span id="3"&gt;&lt;a href="#3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt; &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;zipWith&lt;/span&gt; (\w (x,y) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Positioned&lt;/span&gt; x y w) [w &lt;span class="op"&gt;|&lt;/span&gt; (_,w) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; flattenedWrappings] coords&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Writing all this boilerplate takes time (hence why I circled it red at the beginning in my dependency graph for the tasks in this project). Such translation code would be hard to generate in the general case. Hence I do not have very good solutions but to be careful and use &lt;code&gt;newtype&lt;/code&gt; for each index. The good news, however, is that it is pretty easy to debug: generate simple cases with one then two &lt;code&gt;Wrapping&lt;/code&gt;, observe the generated &lt;code&gt;.json&lt;/code&gt; file.&lt;/p&gt; &lt;p&gt;At last we can be gratified. A simple &lt;code&gt;main&lt;/code&gt; that ressembles the one for &lt;code&gt;linearLayout&lt;/code&gt; allows us to generate layouts for given roll sizes.&lt;/p&gt; &lt;pre&gt;&lt;code class="language-console"&gt;$ santa-wrap minizinc-layout ./layout-190x150.png 190 150 &amp;lt; input/wrapping003.json done! $ santa-wrap minizinc-layout ./layout-170x160.png 170 160 &amp;lt; input/wrapping003.json done! $ santa-wrap minizinc-layout ./layout-170x159.png 170 159 &amp;lt; input/wrapping003.json no layout found! &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The first command greets us with the following picture &lt;img src="./images/layout-190x150.png" alt="img" /&gt;. We can try shrinking the Y-coordinates, 160 is still good, but 159 is too hard (note: it is actually infeasible but the &lt;code&gt;runLastMinizincJSON&lt;/code&gt; function makes no distinctions between timeout and unfeasible). Visual inspection of the Y=160 case seems to show that the two cross-shaped and the big rectangle are the main reasons to limit the roll size &lt;img src="./images/layout-190x150.png" alt="img" /&gt;.&lt;/p&gt; &lt;p&gt;Convince yourself with this picture (done by modifying the input JSON to delete everything but the &lt;em&gt;shoes&lt;/em&gt; and the &lt;em&gt;sword&lt;/em&gt; entries: &lt;img src="./images/layout-restricted.png" alt="img" /&gt;.&lt;/p&gt; &lt;p&gt;OK, with this &lt;code&gt;santa-wrap&lt;/code&gt; tool, Elves are in good shape to save Christmas‚Äô spirit. Thank you MiniZinc and Haskell!&lt;/p&gt; &lt;p&gt;For the fun try packing that yourselves (input is &lt;code&gt;input/wrapping005.json&lt;/code&gt;) &lt;img src="images/layout-robot-200x240.png" alt="img" /&gt;&lt;/p&gt; &lt;h2 id="discussion"&gt;Discussion&lt;/h2&gt; &lt;p&gt;Given more times, a number of possible improvements could happen. For a work project more discussions with the Elves would help adding more constraints to the Model. We next discuss some possible ‚Äúimprovements‚Äù.&lt;/p&gt; &lt;h3 id="possible-improvements"&gt;Possible improvements&lt;/h3&gt; &lt;p&gt;Elves have deadlines too, although they would love to keep improving their tools, they have other important (albeit slightly more mundane) tasks at their day jobs. Besides the discussion about Positioned being an interesting abstraction, I want to discuss improvements to the solver/problem itself and illustrate how business ideas are generated/pruned with such discussions.&lt;/p&gt; &lt;p&gt;A user may suggest improvements to the tool, but not all improvements are equally easy to introduce. Here are a few options:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;easy: reduce some cost (material spent) ; you would need to change the satisfyability into some optimiziation trying to minimize the area bounded by maximum X-Y coordinates &lt;/li&gt; &lt;li&gt;medium: pick an orientation (left-right vs. up-down) ; you would need to change Input, Output, and the model to tell which shapes an object can take, but &lt;code&gt;geost&lt;/code&gt; already takes care of that &lt;/li&gt; &lt;li&gt;hard: attribute multiple rolls at once ; you would need to change Input, Output, and the model to pass a number rolls (maybe to each one their size) and modify the MiniZinc model to decide a roll for each object; you‚Äôd generate two pictures per problem &lt;/li&gt; &lt;li&gt;crazy-hard: time taken to cut with cissors ; you would need to significantly alter the model to express the notion of ‚Äúgaps‚Äù or ‚Äúexternal‚Äù. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;In a typical setup I would propose to deliver the easy and medium improvements before calling the tool done. I would suggest to propose the hard improvement as more data is generated to understand if Elves actually would benefit from such changes. I would root against the crazy hard, and even propose to equip Elves with cutting-tools and drop cissors would probably use total surface as a good enough proxy, simulators can help assess how bad.&lt;/p&gt; &lt;p&gt;Elves would love to hear about your improvement suggestions or merge requests! Feel free to contact me or to open some Issues to discuss them together.&lt;/p&gt; &lt;h3 id="epilogue"&gt;Epilogue&lt;/h3&gt; &lt;p&gt;Alright, this blog post was longer than I expected. I wanted to show how Haskell can be used to solve a very practical problem and also put onto words some ‚Äútactical thinking‚Äù to avoid losing time on the less-important aspects (the one I have not circled red in my dependency diagram). My main challenge was to time-box my work to one day of code: on top of my Elvish missions I have a day job and all-in-all this is a good constraint to simulate a real-world situation. The information I had before starting: I knew &lt;code&gt;JuicyPixels&lt;/code&gt; existed but had never used it before, I sort of framed the Santa-Wrap problem to illustrate a non-trivial MiniZinc global (&lt;code&gt;geost_bb&lt;/code&gt; arguably is pretty advanced). I built the &lt;code&gt;minizinc-process&lt;/code&gt; library and wanted a pretext to show-case it. I could have taken a shortcut as &lt;code&gt;minizinc-process&lt;/code&gt; offers some TemplateHaskell to generate &lt;code&gt;Input&lt;/code&gt; and &lt;code&gt;Output&lt;/code&gt; datatypes (with no newtypes and no support for sets, the pedagogy would have suffered).&lt;/p&gt; &lt;p&gt;An advantage of the Haskell + MiniZinc combination is to be able to use each tool for what they are best at. Haskell allows me to write solid backend services and command line tools whereas MiniZinc allows me to model using MiniZinc IDE (e.g., with a nice syntax for multi-dimensional arrays). In this setup the key difficulty is the boilerplate code required to translate inputs and outputs.&lt;/p&gt; &lt;p&gt;I hope this article piqued your interest. Feel free to contact me if you are curious whether these types of techniques are a good fit for you. I gave a presentation of MiniZinc at an online event this year, and you will find much more on the website and on the Coursera lessons (time consuming).&lt;/p&gt; &lt;p&gt;Thanks to Advent of Haskell organizers and all the other articles authors.&lt;/p&gt; &lt;p&gt;I wish you all the best for the end of 2020 and cheers to a better 2021!&lt;/p&gt; &lt;p&gt;Oh oh oh!&lt;/p&gt; &lt;/section&gt;&lt;/div&gt;
        </content>
        <link href="https://dicioccio.fr/santa-wrap.html" rel="alternate"/>
        <summary type="text">
            We help Santa Elves optimize cutting wrapping paper to accomodate various shapes. The difficult optimization requires a dedicated solver in MiniZinc. Haskell allows to integrate with MiniZinc, reads JSON and outputs a PNG image with the footprint of the positionned shapes to cut. This article shows that a one-day-of-work project can reach pretty far.
        </summary>
    </entry>
</feed>
